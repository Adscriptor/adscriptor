{
  "!name": "AdWordsApi",
  "!define": {
    "Charts.AreaChartBuilder": {
      "build": {
        "!type": "fn() -> Charts.Chart",
        "!doc": "Builds the chart."
      },
      "reverseCategories": {
        "!type": "fn() -> Charts.AreaChartBuilder",
        "!doc": "Reverses the drawing of series in the domain axis.  For vertical-range charts (such as line,\n area or column charts), this means the horizontal axis is drawn from right to left.  For\n horizontal-range charts (such as bar charts), this means the vertical axis is drawn from top\n to bottom.  For pie charts, this means the slices are drawn counterclockwise.\n\n \n \n // Creates a pie chart builder and sets drawing of the slices in a counter-clockwise manner.\n var builder = Charts.newPieChart();\n builder.reverseCategories();\n "
      },
      "setBackgroundColor": {
        "!type": "fn(cssValue: string) -> Charts.AreaChartBuilder",
        "!doc": "Sets the background color for the chart.\n\n \n \n // Creates a line chart builder and sets the background color to gray\n var builder = Charts.newLineChart();\n builder.setBackgroundColor(&quot;gray&quot;);\n "
      },
      "setColors": {
        "!type": "fn(cssValues: [string]) -> Charts.AreaChartBuilder",
        "!doc": "Sets the colors for the lines in the chart.\n\n \n \n // Creates a line chart builder and sets the first two lines to be drawn in green and red,\n // respectively.\n var builder = Charts.newLineChart();\n builder.setColors([&quot;green&quot;, &quot;red&quot;]);\n "
      },
      "setDataSourceUrl": {
        "!type": "fn(url: string) -> Charts.AreaChartBuilder",
        "!doc": "Sets the data source URL that will be used to pull data in from an\n external source, such as Google Sheets.\n If a data source URL and a DataTable are provided, the data source URL is ignored.\n\n For more information about querying data sources, check out the \n Google Charts documentation."
      },
      "setDataTable": {
        "!type": "fn(tableBuilder: DataTableBuilder) -> Charts.AreaChartBuilder",
        "!doc": "Sets the data table to use for the chart using a DataTableBuilder.  This is a convenience\n method for setting the data table without needing to call build()."
      },
      "setDataTable ": {
        "!type": "fn(table: DataTableSource) -> Charts.AreaChartBuilder",
        "!doc": "Sets the data table which contains the lines for the chart, as well as the X-axis labels.\n The first column should be a string, and contain the horizontal axis labels. Any number of\n columns can follow, all must be numeric.  Each column is displayed as a separate line."
      },
      "setDataViewDefinition": {
        "!type": "fn(dataViewDefinition: Charts.DataViewDefinition) -> Charts.AreaChartBuilder",
        "!doc": "Sets the data view definition to use for the chart."
      },
      "setDimensions": {
        "!type": "fn(width: number, height: number) -> Charts.AreaChartBuilder",
        "!doc": "Sets the dimensions for the chart."
      },
      "setLegendPosition": {
        "!type": "fn(position: Charts.Position) -> Charts.AreaChartBuilder",
        "!doc": "Sets the position of the legend with respect to the chart.  By default, there will be no\n legend.\n\n \n \n // Creates a line chart builder and sets the legend position to right.\n var builder = Charts.newLineChart();\n builder.setLegendPosition(Charts.Position.RIGHT);\n "
      },
      "setLegendTextStyle": {
        "!type": "fn(textStyle: Charts.TextStyle) -> Charts.AreaChartBuilder",
        "!doc": "Sets the text style of the chart legend.\n\n \n \n // Creates a line chart builder and sets it up for a  blue, 26-point legend.\n var textStyleBuilder = Charts.newTextStyle().setColor(&#39;#0000FF&#39;).setFontSize(26);\n var style = textStyleBuilder.build();\n var builder = Charts.newLineChart();\n builder.setLegendTextStyle(style);\n "
      },
      "setOption": {
        "!type": "fn(option: string, value: object) -> Charts.AreaChartBuilder",
        "!doc": "Sets advanced options for this chart. See\n the available options for this chart.\n This method has no effect if the given option is invalid.\n\n \n\n \n \n // Build an area chart with a 1-second animation duration.\n var builder = Charts.newAreaChart();\n builder.setOption(&#39;animation.duration&#39;, 1000); \n var chart = builder.build();\n "
      },
      "setPointStyle": {
        "!type": "fn(style: Charts.PointStyle) -> Charts.AreaChartBuilder",
        "!doc": "Sets the style for points in the line.  By default, points will have no particular styles,\n and only the line will be visible.\n\n \n \n // Creates a line chart builder and sets large point style.\n var builder = Charts.newLineChart();\n builder.setPointStyle(Charts.PointStyle.LARGE);\n "
      },
      "setRange": {
        "!type": "fn(start: number, end: number) -> Charts.AreaChartBuilder",
        "!doc": "Sets the range for the chart.\n \n If any data points fall outside the range, the range will be expanded to include those data\n points."
      },
      "setStacked": {
        "!type": "fn() -> Charts.AreaChartBuilder",
        "!doc": "Uses stacked lines, meaning that line and bar values are stacked (accumulated).  By default,\n there is no stacking."
      },
      "setTitle": {
        "!type": "fn(chartTitle: string) -> Charts.AreaChartBuilder",
        "!doc": "Sets the title of the chart.  The title will be displayed centered above the chart.\n\n \n \n // Creates a line chart builder and title to &#39;My Line Chart&#39;.\n var builder = Charts.newLineChart();\n builder.setTitle(&#39;My Line Chart&#39;)\n "
      },
      "setTitleTextStyle": {
        "!type": "fn(textStyle: Charts.TextStyle) -> Charts.AreaChartBuilder",
        "!doc": "Sets the text style of the chart title.\n\n \n \n // Creates a line chart builder and sets it up for a  blue, 26-point title.\n var textStyleBuilder = Charts.newTextStyle().setColor(&#39;#0000FF&#39;).setFontSize(26);\n var style = textStyleBuilder.build();\n var builder = Charts.newLineChart();\n builder.setTitleTextStyle(style);\n "
      },
      "setXAxisTextStyle": {
        "!type": "fn(textStyle: Charts.TextStyle) -> Charts.AreaChartBuilder",
        "!doc": "Sets the horizontal axis text style.\n\n \n \n // Creates a line chart builder and sets the X-axis text style to blue, 18-point font.\n var textStyle = Charts.newTextStyle().setColor(&#39;blue&#39;).setFontSize(18).build();\n var builder = Charts.newLineChart();\n builder.setXAxisTextStyle(textStyle);\n "
      },
      "setXAxisTitle": {
        "!type": "fn(title: string) -> Charts.AreaChartBuilder",
        "!doc": "Adds a title to the horizontal axis.  The title will be centered and will appear below\n the axis value labels.\n\n \n \n // Creates a line chart builder and sets the X-axis title.\n var builder = Charts.newLineChart();\n builder.setTitle(&#39;X-axis Title&#39;)\n "
      },
      "setXAxisTitleTextStyle": {
        "!type": "fn(textStyle: Charts.TextStyle) -> Charts.AreaChartBuilder",
        "!doc": "Sets the horizontal axis title text style.\n\n \n \n // Creates a line chart builder and sets the X-axis title text style to blue, 18-point font.\n var textStyle = Charts.newTextStyle().setColor(&#39;blue&#39;).setFontSize(18).build();\n var builder = Charts.newLineChart();\n builder.setXAxisTitleTextStyle(textStyle);\n "
      },
      "setYAxisTextStyle": {
        "!type": "fn(textStyle: Charts.TextStyle) -> Charts.AreaChartBuilder",
        "!doc": "Sets the vertical axis text style.\n\n \n \n // Creates a line chart builder and sets the Y-axis text style to blue, 18-point font.\n var textStyle = Charts.newTextStyle().setColor(&#39;blue&#39;).setFontSize(18).build();\n var builder = Charts.newLineChart();\n builder.setYAxisTextStyle(textStyle);\n "
      },
      "setYAxisTitle": {
        "!type": "fn(title: string) -> Charts.AreaChartBuilder",
        "!doc": "Adds a title to the vertical axis.  The title will be centered and will appear to the\n left of the value labels.\n\n \n \n // Creates a line chart builder and sets the Y-axis title.\n var builder = Charts.newLineChart();\n builder.setYAxisTitle(&#39;Y-axis Title&#39;)\n "
      },
      "setYAxisTitleTextStyle": {
        "!type": "fn(textStyle: Charts.TextStyle) -> Charts.AreaChartBuilder",
        "!doc": "Sets the vertical axis title text style.\n\n \n \n // Creates a line chart builder and sets the Y-axis title text style to blue, 18-point font.\n var textStyle = Charts.newTextStyle().setColor(&#39;blue&#39;).setFontSize(18).build();\n var builder = Charts.newLineChart();\n builder.setYAxisTitleTextStyle(textStyle);\n "
      },
      "useLogScale": {
        "!type": "fn() -> Charts.AreaChartBuilder",
        "!doc": "Makes the range axis into a logarithmic scale (requires all values to be positive).  The range\n axis will be the vertical axis for vertical charts (line, area, column, etc.) and the\n horizontal axis for horizontal charts (bar, etc.)"
      }
    },
    "Charts.BarChartBuilder": {
      "build": {
        "!type": "fn() -> Charts.Chart",
        "!doc": "Builds the chart."
      },
      "reverseCategories": {
        "!type": "fn() -> Charts.BarChartBuilder",
        "!doc": "Reverses the drawing of series in the domain axis.  For vertical-range charts (such as line,\n area or column charts), this means the horizontal axis is drawn from right to left.  For\n horizontal-range charts (such as bar charts), this means the vertical axis is drawn from top\n to bottom.  For pie charts, this means the slices are drawn counterclockwise.\n\n \n \n // Creates a pie chart builder and sets drawing of the slices in a counter-clockwise manner.\n var builder = Charts.newPieChart();\n builder.reverseCategories();\n "
      },
      "reverseDirection": {
        "!type": "fn() -> Charts.BarChartBuilder",
        "!doc": "Reverses the direction in which the bars grow along the horizontal axis.  By default, values\n grow from left to right.  Calling this method will cause them to grow from right to left."
      },
      "setBackgroundColor": {
        "!type": "fn(cssValue: string) -> Charts.BarChartBuilder",
        "!doc": "Sets the background color for the chart.\n\n \n \n // Creates a line chart builder and sets the background color to gray\n var builder = Charts.newLineChart();\n builder.setBackgroundColor(&quot;gray&quot;);\n "
      },
      "setColors": {
        "!type": "fn(cssValues: [string]) -> Charts.BarChartBuilder",
        "!doc": "Sets the colors for the lines in the chart.\n\n \n \n // Creates a line chart builder and sets the first two lines to be drawn in green and red,\n // respectively.\n var builder = Charts.newLineChart();\n builder.setColors([&quot;green&quot;, &quot;red&quot;]);\n "
      },
      "setDataSourceUrl": {
        "!type": "fn(url: string) -> Charts.BarChartBuilder",
        "!doc": "Sets the data source URL that will be used to pull data in from an\n external source, such as Google Sheets.\n If a data source URL and a DataTable are provided, the data source URL is ignored.\n\n For more information about querying data sources, check out the \n Google Charts documentation."
      },
      "setDataTable": {
        "!type": "fn(tableBuilder: DataTableBuilder) -> Charts.BarChartBuilder",
        "!doc": "Sets the data table to use for the chart using a DataTableBuilder.  This is a convenience\n method for setting the data table without needing to call build()."
      },
      "setDataTable ": {
        "!type": "fn(table: DataTableSource) -> Charts.BarChartBuilder",
        "!doc": "Sets the data table which contains the lines for the chart, as well as the X-axis labels.\n The first column should be a string, and contain the horizontal axis labels. Any number of\n columns can follow, all must be numeric.  Each column is displayed as a separate line."
      },
      "setDataViewDefinition": {
        "!type": "fn(dataViewDefinition: Charts.DataViewDefinition) -> Charts.BarChartBuilder",
        "!doc": "Sets the data view definition to use for the chart."
      },
      "setDimensions": {
        "!type": "fn(width: number, height: number) -> Charts.BarChartBuilder",
        "!doc": "Sets the dimensions for the chart."
      },
      "setLegendPosition": {
        "!type": "fn(position: Charts.Position) -> Charts.BarChartBuilder",
        "!doc": "Sets the position of the legend with respect to the chart.  By default, there will be no\n legend.\n\n \n \n // Creates a line chart builder and sets the legend position to right.\n var builder = Charts.newLineChart();\n builder.setLegendPosition(Charts.Position.RIGHT);\n "
      },
      "setLegendTextStyle": {
        "!type": "fn(textStyle: Charts.TextStyle) -> Charts.BarChartBuilder",
        "!doc": "Sets the text style of the chart legend.\n\n \n \n // Creates a line chart builder and sets it up for a  blue, 26-point legend.\n var textStyleBuilder = Charts.newTextStyle().setColor(&#39;#0000FF&#39;).setFontSize(26);\n var style = textStyleBuilder.build();\n var builder = Charts.newLineChart();\n builder.setLegendTextStyle(style);\n "
      },
      "setOption": {
        "!type": "fn(option: string, value: object) -> Charts.BarChartBuilder",
        "!doc": "Sets advanced options for this chart. See\n the available options for this chart.\n This method has no effect if the given option is invalid.\n\n \n\n \n \n // Build a bar chart with a 1-second animation duration.\n var builder = Charts.newBarChart();\n builder.setOption(&#39;animation.duration&#39;, 1000); \n var chart = builder.build();\n "
      },
      "setRange": {
        "!type": "fn(start: number, end: number) -> Charts.BarChartBuilder",
        "!doc": "Sets the range for the chart.\n \n If any data points fall outside the range, the range will be expanded to include those data\n points."
      },
      "setStacked": {
        "!type": "fn() -> Charts.BarChartBuilder",
        "!doc": "Uses stacked lines, meaning that line and bar values are stacked (accumulated).  By default,\n there is no stacking."
      },
      "setTitle": {
        "!type": "fn(chartTitle: string) -> Charts.BarChartBuilder",
        "!doc": "Sets the title of the chart.  The title will be displayed centered above the chart.\n\n \n \n // Creates a line chart builder and title to &#39;My Line Chart&#39;.\n var builder = Charts.newLineChart();\n builder.setTitle(&#39;My Line Chart&#39;)\n "
      },
      "setTitleTextStyle": {
        "!type": "fn(textStyle: Charts.TextStyle) -> Charts.BarChartBuilder",
        "!doc": "Sets the text style of the chart title.\n\n \n \n // Creates a line chart builder and sets it up for a  blue, 26-point title.\n var textStyleBuilder = Charts.newTextStyle().setColor(&#39;#0000FF&#39;).setFontSize(26);\n var style = textStyleBuilder.build();\n var builder = Charts.newLineChart();\n builder.setTitleTextStyle(style);\n "
      },
      "setXAxisTextStyle": {
        "!type": "fn(textStyle: Charts.TextStyle) -> Charts.BarChartBuilder",
        "!doc": "Sets the horizontal axis text style.\n\n \n \n // Creates a line chart builder and sets the X-axis text style to blue, 18-point font.\n var textStyle = Charts.newTextStyle().setColor(&#39;blue&#39;).setFontSize(18).build();\n var builder = Charts.newLineChart();\n builder.setXAxisTextStyle(textStyle);\n "
      },
      "setXAxisTitle": {
        "!type": "fn(title: string) -> Charts.BarChartBuilder",
        "!doc": "Adds a title to the horizontal axis.  The title will be centered and will appear below\n the axis value labels.\n\n \n \n // Creates a line chart builder and sets the X-axis title.\n var builder = Charts.newLineChart();\n builder.setTitle(&#39;X-axis Title&#39;)\n "
      },
      "setXAxisTitleTextStyle": {
        "!type": "fn(textStyle: Charts.TextStyle) -> Charts.BarChartBuilder",
        "!doc": "Sets the horizontal axis title text style.\n\n \n \n // Creates a line chart builder and sets the X-axis title text style to blue, 18-point font.\n var textStyle = Charts.newTextStyle().setColor(&#39;blue&#39;).setFontSize(18).build();\n var builder = Charts.newLineChart();\n builder.setXAxisTitleTextStyle(textStyle);\n "
      },
      "setYAxisTextStyle": {
        "!type": "fn(textStyle: Charts.TextStyle) -> Charts.BarChartBuilder",
        "!doc": "Sets the vertical axis text style.\n\n \n \n // Creates a line chart builder and sets the Y-axis text style to blue, 18-point font.\n var textStyle = Charts.newTextStyle().setColor(&#39;blue&#39;).setFontSize(18).build();\n var builder = Charts.newLineChart();\n builder.setYAxisTextStyle(textStyle);\n "
      },
      "setYAxisTitle": {
        "!type": "fn(title: string) -> Charts.BarChartBuilder",
        "!doc": "Adds a title to the vertical axis.  The title will be centered and will appear to the\n left of the value labels.\n\n \n \n // Creates a line chart builder and sets the Y-axis title.\n var builder = Charts.newLineChart();\n builder.setYAxisTitle(&#39;Y-axis Title&#39;)\n "
      },
      "setYAxisTitleTextStyle": {
        "!type": "fn(textStyle: Charts.TextStyle) -> Charts.BarChartBuilder",
        "!doc": "Sets the vertical axis title text style.\n\n \n \n // Creates a line chart builder and sets the Y-axis title text style to blue, 18-point font.\n var textStyle = Charts.newTextStyle().setColor(&#39;blue&#39;).setFontSize(18).build();\n var builder = Charts.newLineChart();\n builder.setYAxisTitleTextStyle(textStyle);\n "
      },
      "useLogScale": {
        "!type": "fn() -> Charts.BarChartBuilder",
        "!doc": "Makes the range axis into a logarithmic scale (requires all values to be positive).  The range\n axis will be the vertical axis for vertical charts (line, area, column, etc.) and the\n horizontal axis for horizontal charts (bar, etc.)"
      }
    },
    "Charts.CategoryFilterBuilder": {
      "build": {
        "!type": "fn() -> Charts.Control",
        "!doc": "Builds a control."
      },
      "setAllowMultiple": {
        "!type": "fn(allowMultiple: bool) -> Charts.CategoryFilterBuilder",
        "!doc": "Sets whether multiple values can be selected, rather than just one. The default value of\n this option is true (allowing multiple selection).\n\n \n \n // Creates a category filter and disallows multiple value selection.\n var builder = Charts.newCategoryFilter().setAllowMultiple(false);\n "
      },
      "setAllowNone": {
        "!type": "fn(allowNone: bool) -> Charts.CategoryFilterBuilder",
        "!doc": "Sets whether the user is allowed not to choose any value. If false the user must choose at\n least one value from the available ones. The default value of this option is true.\n\n \n \n // Creates a category filter and force the user to choose at least one value.\n var builder = Charts.newCategoryFilter().setAllowNone(false);\n "
      },
      "setAllowTyping": {
        "!type": "fn(allowTyping: bool) -> Charts.CategoryFilterBuilder",
        "!doc": "Sets whether the user is allowed to type in a text field to narrow down the list of possible\n choices (via an autocompleter), or not. The default value of this option is true (allowing the\n user to type in values in the picker).\n\n \n \n // Creates a category filter and disallows the user from typing in text to filter the values,\n // so the user must use the drop down to pick values.\n var builder = Charts.newCategoryFilter().setAllowTyping(false);\n "
      },
      "setCaption": {
        "!type": "fn(caption: string) -> Charts.CategoryFilterBuilder",
        "!doc": "Sets the caption to display inside the value picker widget when no item is selected.\n\n \n \n // Creates a category filter with a caption.\n var builder = Charts.newCategoryFilter().setCaption(&#39;select a value&#39;);\n "
      },
      "setDataTable": {
        "!type": "fn(tableBuilder: DataTableBuilder) -> Charts.CategoryFilterBuilder",
        "!doc": "Sets the data table to use for the control using a DataTableBuilder.\n\n This is a convenience method for setting the data table without needing to call\n build()."
      },
      "setDataTable ": {
        "!type": "fn(table: DataTableSource) -> Charts.CategoryFilterBuilder",
        "!doc": "Sets the control data table, which will be the control's underlying data model."
      },
      "setFilterColumnIndex": {
        "!type": "fn(columnIndex: number) -> Charts.CategoryFilterBuilder",
        "!doc": "Sets the index of the data table column to filter on.\n\n The values of that column will determine whether or not each row should be filtered.\n It is mandatory to set either this or the column label using\n setFilterColumnLabel(columnLabel)."
      },
      "setFilterColumnLabel": {
        "!type": "fn(columnLabel: string) -> Charts.CategoryFilterBuilder",
        "!doc": "Sets the label of the data table column to filter on.\n\n The values of that column will determine whether or not each row should be filtered.\n It is mandatory to set either this or a column index using setFilterColumnIndex(columnIndex)."
      },
      "setLabel": {
        "!type": "fn(label: string) -> Charts.CategoryFilterBuilder",
        "!doc": "Sets the label to display next to the slider.\n\n If unspecified, the label of the column the control operates on will be used."
      },
      "setLabelSeparator": {
        "!type": "fn(labelSeparator: string) -> Charts.CategoryFilterBuilder",
        "!doc": "Sets a separator string appended to the label, to visually separate the\n label from the category picker."
      },
      "setLabelStacking": {
        "!type": "fn(orientation: Charts.Orientation) -> Charts.CategoryFilterBuilder",
        "!doc": "Sets whether the label should display above (vertical stacking) or beside (horizontal stacking)\n the input field."
      },
      "setSelectedValuesLayout": {
        "!type": "fn(layout: Charts.PickerValuesLayout) -> Charts.CategoryFilterBuilder",
        "!doc": "Sets how to display selected values, when multiple selection is allowed.\n\n \n \n // Creates a category filter and sets it to display selected values below the picker.\n var builder = Charts.newCategoryFilter()\n     .setSelectedValuesLayout(Charts.PickerValuesLayout.BELOW);\n "
      },
      "setSortValues": {
        "!type": "fn(sortValues: bool) -> Charts.CategoryFilterBuilder",
        "!doc": "Sets whether the values to choose from should be sorted.\n\n \n \n // Creates a category filter that sorts the values.\n var builder = Charts.newCategoryFilter().setSortValues(true);\n "
      },
      "setValues": {
        "!type": "fn(values: [string]) -> Charts.CategoryFilterBuilder",
        "!doc": "Sets the list of values (categories) the user can choose from.\n\n \n \n // Creates a category filter with two choices.\n var builder = Charts.newCategoryFilter().setValues([&#39;choice 1&#39;,&#39;choice 2&#39;]);\n "
      }
    },
    "Charts.Chart": {
      "getAs": {
        "!type": "fn(contentType: string) -> Blob",
        "!doc": "Return the data inside this object as a blob converted to the specified content type. This\n method adds the appropriate extension to the filename ? for example, \"myfile.pdf\". However, it\n assumes that the part of the filename that follows the last period (if any) is an existing\n extension that should be replaced. Consequently, \"ChristmasList.12.25.2014\" will become\n \"ChristmasList.12.25.pdf\"."
      },
      "getBlob": {
        "!type": "fn() -> Blob",
        "!doc": "Return the data inside this object as a blob."
      },
      "getId": {
        "!type": "fn() -> string",
        "!doc": "Returns the id that has been assigned to this object.\n \n This can be used in conjunction with app.getElementById() to retrieve a reference to this\n object."
      },
      "getOptions": {
        "!type": "fn() -> Charts.ChartOptions",
        "!doc": "Returns the options for this chart, such as height, colors, axes, etc.\n \n The returned options are immutable."
      },
      "getType": {
        "!type": "fn() -> string",
        "!doc": "Gets the type of this object."
      },
      "setId": {
        "!type": "fn(id: string) -> Charts.Chart",
        "!doc": "Sets the id of this Chart to be used with UiApp."
      }
    },
    "Charts.ChartOptions": {
      "get": {
        "!type": "fn(option: string) -> object",
        "!doc": "Returns a configured option for this chart."
      }
    },
    "Charts.ChartType": {
      "AREA": {
        "!type": "Charts.ChartType",
        "!doc": "Area chart"
      },
      "BAR": {
        "!type": "Charts.ChartType",
        "!doc": "Bar chart"
      },
      "COLUMN": {
        "!type": "Charts.ChartType",
        "!doc": "Column chart"
      },
      "LINE": {
        "!type": "Charts.ChartType",
        "!doc": "Line chart"
      },
      "PIE": {
        "!type": "Charts.ChartType",
        "!doc": "Pie chart"
      },
      "SCATTER": {
        "!type": "Charts.ChartType",
        "!doc": "Scatter chart"
      },
      "TABLE": {
        "!type": "Charts.ChartType",
        "!doc": "Table chart"
      }
    },
    "Charts.ColumnChartBuilder": {
      "build": {
        "!type": "fn() -> Charts.Chart",
        "!doc": "Builds the chart."
      },
      "reverseCategories": {
        "!type": "fn() -> Charts.ColumnChartBuilder",
        "!doc": "Reverses the drawing of series in the domain axis.  For vertical-range charts (such as line,\n area or column charts), this means the horizontal axis is drawn from right to left.  For\n horizontal-range charts (such as bar charts), this means the vertical axis is drawn from top\n to bottom.  For pie charts, this means the slices are drawn counterclockwise.\n\n \n \n // Creates a pie chart builder and sets drawing of the slices in a counter-clockwise manner.\n var builder = Charts.newPieChart();\n builder.reverseCategories();\n "
      },
      "setBackgroundColor": {
        "!type": "fn(cssValue: string) -> Charts.ColumnChartBuilder",
        "!doc": "Sets the background color for the chart.\n\n \n \n // Creates a line chart builder and sets the background color to gray\n var builder = Charts.newLineChart();\n builder.setBackgroundColor(&quot;gray&quot;);\n "
      },
      "setColors": {
        "!type": "fn(cssValues: [string]) -> Charts.ColumnChartBuilder",
        "!doc": "Sets the colors for the lines in the chart.\n\n \n \n // Creates a line chart builder and sets the first two lines to be drawn in green and red,\n // respectively.\n var builder = Charts.newLineChart();\n builder.setColors([&quot;green&quot;, &quot;red&quot;]);\n "
      },
      "setDataSourceUrl": {
        "!type": "fn(url: string) -> Charts.ColumnChartBuilder",
        "!doc": "Sets the data source URL that will be used to pull data in from an\n external source, such as Google Sheets.\n If a data source URL and a DataTable are provided, the data source URL is ignored.\n\n For more information about querying data sources, check out the \n Google Charts documentation."
      },
      "setDataTable": {
        "!type": "fn(tableBuilder: DataTableBuilder) -> Charts.ColumnChartBuilder",
        "!doc": "Sets the data table to use for the chart using a DataTableBuilder.  This is a convenience\n method for setting the data table without needing to call build()."
      },
      "setDataTable ": {
        "!type": "fn(table: DataTableSource) -> Charts.ColumnChartBuilder",
        "!doc": "Sets the data table which contains the lines for the chart, as well as the X-axis labels.\n The first column should be a string, and contain the horizontal axis labels. Any number of\n columns can follow, all must be numeric.  Each column is displayed as a separate line."
      },
      "setDataViewDefinition": {
        "!type": "fn(dataViewDefinition: Charts.DataViewDefinition) -> Charts.ColumnChartBuilder",
        "!doc": "Sets the data view definition to use for the chart."
      },
      "setDimensions": {
        "!type": "fn(width: number, height: number) -> Charts.ColumnChartBuilder",
        "!doc": "Sets the dimensions for the chart."
      },
      "setLegendPosition": {
        "!type": "fn(position: Charts.Position) -> Charts.ColumnChartBuilder",
        "!doc": "Sets the position of the legend with respect to the chart.  By default, there will be no\n legend.\n\n \n \n // Creates a line chart builder and sets the legend position to right.\n var builder = Charts.newLineChart();\n builder.setLegendPosition(Charts.Position.RIGHT);\n "
      },
      "setLegendTextStyle": {
        "!type": "fn(textStyle: Charts.TextStyle) -> Charts.ColumnChartBuilder",
        "!doc": "Sets the text style of the chart legend.\n\n \n \n // Creates a line chart builder and sets it up for a  blue, 26-point legend.\n var textStyleBuilder = Charts.newTextStyle().setColor(&#39;#0000FF&#39;).setFontSize(26);\n var style = textStyleBuilder.build();\n var builder = Charts.newLineChart();\n builder.setLegendTextStyle(style);\n "
      },
      "setOption": {
        "!type": "fn(option: string, value: object) -> Charts.ColumnChartBuilder",
        "!doc": "Sets advanced options for this chart. See\n the available options for this chart.\n This method has no effect if the given option is invalid.\n\n \n\n \n \n // Build a column chart with a 1-second animation duration.\n var builder = Charts.newColumnChart();\n builder.setOption(&#39;animation.duration&#39;, 1000); \n var chart = builder.build();\n "
      },
      "setRange": {
        "!type": "fn(start: number, end: number) -> Charts.ColumnChartBuilder",
        "!doc": "Sets the range for the chart.\n \n If any data points fall outside the range, the range will be expanded to include those data\n points."
      },
      "setStacked": {
        "!type": "fn() -> Charts.ColumnChartBuilder",
        "!doc": "Uses stacked lines, meaning that line and bar values are stacked (accumulated).  By default,\n there is no stacking."
      },
      "setTitle": {
        "!type": "fn(chartTitle: string) -> Charts.ColumnChartBuilder",
        "!doc": "Sets the title of the chart.  The title will be displayed centered above the chart.\n\n \n \n // Creates a line chart builder and title to &#39;My Line Chart&#39;.\n var builder = Charts.newLineChart();\n builder.setTitle(&#39;My Line Chart&#39;)\n "
      },
      "setTitleTextStyle": {
        "!type": "fn(textStyle: Charts.TextStyle) -> Charts.ColumnChartBuilder",
        "!doc": "Sets the text style of the chart title.\n\n \n \n // Creates a line chart builder and sets it up for a  blue, 26-point title.\n var textStyleBuilder = Charts.newTextStyle().setColor(&#39;#0000FF&#39;).setFontSize(26);\n var style = textStyleBuilder.build();\n var builder = Charts.newLineChart();\n builder.setTitleTextStyle(style);\n "
      },
      "setXAxisTextStyle": {
        "!type": "fn(textStyle: Charts.TextStyle) -> Charts.ColumnChartBuilder",
        "!doc": "Sets the horizontal axis text style.\n\n \n \n // Creates a line chart builder and sets the X-axis text style to blue, 18-point font.\n var textStyle = Charts.newTextStyle().setColor(&#39;blue&#39;).setFontSize(18).build();\n var builder = Charts.newLineChart();\n builder.setXAxisTextStyle(textStyle);\n "
      },
      "setXAxisTitle": {
        "!type": "fn(title: string) -> Charts.ColumnChartBuilder",
        "!doc": "Adds a title to the horizontal axis.  The title will be centered and will appear below\n the axis value labels.\n\n \n \n // Creates a line chart builder and sets the X-axis title.\n var builder = Charts.newLineChart();\n builder.setTitle(&#39;X-axis Title&#39;)\n "
      },
      "setXAxisTitleTextStyle": {
        "!type": "fn(textStyle: Charts.TextStyle) -> Charts.ColumnChartBuilder",
        "!doc": "Sets the horizontal axis title text style.\n\n \n \n // Creates a line chart builder and sets the X-axis title text style to blue, 18-point font.\n var textStyle = Charts.newTextStyle().setColor(&#39;blue&#39;).setFontSize(18).build();\n var builder = Charts.newLineChart();\n builder.setXAxisTitleTextStyle(textStyle);\n "
      },
      "setYAxisTextStyle": {
        "!type": "fn(textStyle: Charts.TextStyle) -> Charts.ColumnChartBuilder",
        "!doc": "Sets the vertical axis text style.\n\n \n \n // Creates a line chart builder and sets the Y-axis text style to blue, 18-point font.\n var textStyle = Charts.newTextStyle().setColor(&#39;blue&#39;).setFontSize(18).build();\n var builder = Charts.newLineChart();\n builder.setYAxisTextStyle(textStyle);\n "
      },
      "setYAxisTitle": {
        "!type": "fn(title: string) -> Charts.ColumnChartBuilder",
        "!doc": "Adds a title to the vertical axis.  The title will be centered and will appear to the\n left of the value labels.\n\n \n \n // Creates a line chart builder and sets the Y-axis title.\n var builder = Charts.newLineChart();\n builder.setYAxisTitle(&#39;Y-axis Title&#39;)\n "
      },
      "setYAxisTitleTextStyle": {
        "!type": "fn(textStyle: Charts.TextStyle) -> Charts.ColumnChartBuilder",
        "!doc": "Sets the vertical axis title text style.\n\n \n \n // Creates a line chart builder and sets the Y-axis title text style to blue, 18-point font.\n var textStyle = Charts.newTextStyle().setColor(&#39;blue&#39;).setFontSize(18).build();\n var builder = Charts.newLineChart();\n builder.setYAxisTitleTextStyle(textStyle);\n "
      },
      "useLogScale": {
        "!type": "fn() -> Charts.ColumnChartBuilder",
        "!doc": "Makes the range axis into a logarithmic scale (requires all values to be positive).  The range\n axis will be the vertical axis for vertical charts (line, area, column, etc.) and the\n horizontal axis for horizontal charts (bar, etc.)"
      }
    },
    "Charts.Control": {
      "getId": {
        "!type": "fn() -> string",
        "!doc": "Returns the id that has been assigned to this object.\n \n This can be used in conjunction with app.getElementById() to retrieve a reference to this\n object."
      },
      "getType": {
        "!type": "fn() -> string",
        "!doc": "Gets the type of this object."
      },
      "setId": {
        "!type": "fn(id: string) -> Charts.Control",
        "!doc": "Sets the id of this Control to be used with UiApp."
      }
    },
    "Charts.CurveStyle": {
      "NORMAL": {
        "!type": "Charts.CurveStyle",
        "!doc": "Straight lines without curve"
      },
      "SMOOTH": {
        "!type": "Charts.CurveStyle",
        "!doc": "The angles of the line will be smoothed"
      }
    },
    "Charts.DashboardPanel": {
      "add": {
        "!type": "fn(widget: UiApp.Widget) -> Charts.DashboardPanel",
        "!doc": "Add a widget to the DashboardPanel.\n \n The DashboardPanel is a simple panel which contains a single widget in it. A good practice\n for building a dashboard to place all of its components (the charts and controls that are\n bound in it) in a complex panel (vertical or horizontal panel for example), and to add\n that panel to it."
      },
      "getId": {
        "!type": "fn() -> string",
        "!doc": "Returns the id that has been assigned to this object.\n \n This can be used in conjunction with app.getElementById() to retrieve a reference to this\n object."
      },
      "getType": {
        "!type": "fn() -> string",
        "!doc": "Gets the type of this object."
      },
      "setId": {
        "!type": "fn(id: string) -> Charts.DashboardPanel",
        "!doc": "Sets the id of this DashboardPanel to be used with UiApp."
      }
    },
    "Charts.DashboardPanelBuilder": {
      "bind": {
        "!type": "fn(control: Charts.Control, chart: Charts.Chart) -> Charts.DashboardPanelBuilder",
        "!doc": "Binds a control to a chart, so that the chart is redrawn whenever the control collects\n a user interaction that affects the data managed by the dashboard.\n \n For example, when binding a range selector to a chart, a user interaction will be sliding the\n the range selector to the desired range. The effect on the data will be keeping only the\n data that's in the chosen range."
      },
      "bind ": {
        "!type": "fn(controls: [Charts.Control], charts: [Charts.Chart]) -> Charts.DashboardPanelBuilder",
        "!doc": "Binds multiple controls to multiple charts, so that the charts are redrawn whenever the\n controls collect a user interaction that affects the data managed by the dashboard. When\n binding multiple controls to a chart (or multiple charts), the data that's displayed in\n the chart is that which passes the filters of all of the controls (of this specific binding).\n \n For more information about object binding see the Gviz\n \n documentation.\n \n Here is an example that shows how multiple controls can be bound to a chart using a dashboard\n panel:\n \n \n function doGet() {\n   // Create a data table with some sample data.\n   var data = Charts.newDataTable()\n       .addColumn(Charts.ColumnType.STRING, &quot;Name&quot;)\n       .addColumn(Charts.ColumnType.NUMBER, &quot;Age&quot;)\n       .addRow([&quot;Michael&quot;, 18])\n       .addRow([&quot;Elisa&quot;, 12])\n       .addRow([&quot;John&quot;, 20])\n       .addRow([&quot;Jessica&quot;, 25])\n       .addRow([&quot;Aaron&quot;, 14])\n       .addRow([&quot;Margareth&quot;, 19])\n       .addRow([&quot;Miranda&quot;, 22])\n       .addRow([&quot;May&quot;, 20])\n       .build();\n\n   var chart = Charts.newBarChart()\n       .setTitle(&quot;Ages&quot;)\n       .build();\n\n   var stringFilter = Charts.newStringFilter()\n       .setFilterColumnLabel(&quot;Name&quot;)\n       .build();\n\n   var numberRangeFilter = Charts.newNumberRangeFilter()\n       .setFilterColumnLabel(&quot;Age&quot;)\n       .build();\n\n   // Create a dashboard panel binding both controls to the chart.\n   var dashboard = Charts.newDashboardPanel()\n       .setDataTable(data)\n       .bind([stringFilter, numberRangeFilter], [chart])\n       .build();\n\n   var uiApp = UiApp.createApplication().setTitle(&quot;My Dashboard&quot;);\n\n   var panel = uiApp.createVerticalPanel()\n       .setSpacing(50);\n\n   panel.add(stringFilter);\n   panel.add(numberRangeFilter);\n   panel.add(chart);\n   dashboard.add(panel);\n   uiApp.add(dashboard);\n   return uiApp;\n }\n "
      },
      "build": {
        "!type": "fn() -> Charts.DashboardPanel",
        "!doc": "Builds a dashboard."
      },
      "setDataTable": {
        "!type": "fn(tableBuilder: DataTableBuilder) -> Charts.DashboardPanelBuilder",
        "!doc": "Sets the data table to use for the dashboard using a DataTableBuilder.  This is a convenience\n method for setting the data table without needing to call build()."
      },
      "setDataTable ": {
        "!type": "fn(source: DataTableSource) -> Charts.DashboardPanelBuilder",
        "!doc": "Sets the dashboard's data table, which will be the control's underlying data model."
      }
    },
    "Charts.DataViewDefinition": {},
    "Charts.DataViewDefinitionBuilder": {
      "build": {
        "!type": "fn() -> Charts.DataViewDefinition",
        "!doc": "Builds and returns the data view definition object that was built using this builder."
      },
      "setColumns": {
        "!type": "fn(columns: [object]) -> Charts.DataViewDefinitionBuilder",
        "!doc": "Sets the indexes of the columns to include in the data view as well as specifying\n role-column information. This subset of column indexes refer to the columns of the\n data source that the data view will be derived from.\n \n A column role describes the purpose of the data in that column: for example,\n a column might hold data describing tooltip text, data point annotations, or\n uncertainty indicators. For more details, see \n DataTable Roles in the Google Charts\n documentation.\n \n Assuming a spreadsheet with the following data in A1:C3:\n \n   \"abc\", 20, \"blue\"\n   \"def\", 30, \"red\"\n   \"ghi\", 40, \"orange\"\n \n The following code creates a bar chart where each bar is a different color.\n The colors are assigned via a style \"role column\".\n\n \n var COLUMN_SPEC = [\n   0, // categories\n   1, // counts\n   {sourceColumn: 2, role: &#39;style&#39;}\n ];\n\n function roleColumnChart() {\n   var spreadsheet = SpreadsheetApp.getActiveSpreadsheet();\n   var sheet = spreadsheet.getActiveSheet();\n   var viewSpec = Charts.newDataViewDefinition()\n       .setColumns(COLUMN_SPEC)\n       .build();\n   var chartBuilder = sheet.newChart()\n       .setChartType(Charts.ChartType.BAR)\n       .setDataViewDefinition(viewSpec)\n       .setOption(&#39;useFirstColumnAsDomain&#39;, true)\n       .setPosition(5, 1, 0, 0)\n       .setOption(&#39;hAxis&#39;, { title: &#39;Counts&#39; })\n       .setOption(&#39;vAxis&#39;, { title: &#39;Categories&#39; })\n       .addRange(sheet.getRange(&#39;A1:C3&#39;));\n   sheet.insertChart(chartBuilder.build());\n };\n "
      }
    },
    "Charts.LineChartBuilder": {
      "build": {
        "!type": "fn() -> Charts.Chart",
        "!doc": "Builds the chart."
      },
      "reverseCategories": {
        "!type": "fn() -> Charts.LineChartBuilder",
        "!doc": "Reverses the drawing of series in the domain axis.  For vertical-range charts (such as line,\n area or column charts), this means the horizontal axis is drawn from right to left.  For\n horizontal-range charts (such as bar charts), this means the vertical axis is drawn from top\n to bottom.  For pie charts, this means the slices are drawn counterclockwise.\n\n \n \n // Creates a pie chart builder and sets drawing of the slices in a counter-clockwise manner.\n var builder = Charts.newPieChart();\n builder.reverseCategories();\n "
      },
      "setBackgroundColor": {
        "!type": "fn(cssValue: string) -> Charts.LineChartBuilder",
        "!doc": "Sets the background color for the chart.\n\n \n \n // Creates a line chart builder and sets the background color to gray\n var builder = Charts.newLineChart();\n builder.setBackgroundColor(&quot;gray&quot;);\n "
      },
      "setColors": {
        "!type": "fn(cssValues: [string]) -> Charts.LineChartBuilder",
        "!doc": "Sets the colors for the lines in the chart.\n\n \n \n // Creates a line chart builder and sets the first two lines to be drawn in green and red,\n // respectively.\n var builder = Charts.newLineChart();\n builder.setColors([&quot;green&quot;, &quot;red&quot;]);\n "
      },
      "setCurveStyle": {
        "!type": "fn(style: Charts.CurveStyle) -> Charts.LineChartBuilder",
        "!doc": "Sets the style to use for curves in the chart.  See CurveStyle for allowed curve\n styles.\n\n \n \n // Creates a line chart builder and curves the lines in the chart.\n var builder = Charts.newLineChart();\n builder.setCurveStyle(Charts.CurveStyle.SMOOTH)\n "
      },
      "setDataSourceUrl": {
        "!type": "fn(url: string) -> Charts.LineChartBuilder",
        "!doc": "Sets the data source URL that will be used to pull data in from an\n external source, such as Google Sheets.\n If a data source URL and a DataTable are provided, the data source URL is ignored.\n\n For more information about querying data sources, check out the \n Google Charts documentation."
      },
      "setDataTable": {
        "!type": "fn(tableBuilder: DataTableBuilder) -> Charts.LineChartBuilder",
        "!doc": "Sets the data table to use for the chart using a DataTableBuilder.  This is a convenience\n method for setting the data table without needing to call build()."
      },
      "setDataTable ": {
        "!type": "fn(table: DataTableSource) -> Charts.LineChartBuilder",
        "!doc": "Sets the data table which contains the lines for the chart, as well as the X-axis labels.\n The first column should be a string, and contain the horizontal axis labels. Any number of\n columns can follow, all must be numeric.  Each column is displayed as a separate line."
      },
      "setDataViewDefinition": {
        "!type": "fn(dataViewDefinition: Charts.DataViewDefinition) -> Charts.LineChartBuilder",
        "!doc": "Sets the data view definition to use for the chart."
      },
      "setDimensions": {
        "!type": "fn(width: number, height: number) -> Charts.LineChartBuilder",
        "!doc": "Sets the dimensions for the chart."
      },
      "setLegendPosition": {
        "!type": "fn(position: Charts.Position) -> Charts.LineChartBuilder",
        "!doc": "Sets the position of the legend with respect to the chart.  By default, there will be no\n legend.\n\n \n \n // Creates a line chart builder and sets the legend position to right.\n var builder = Charts.newLineChart();\n builder.setLegendPosition(Charts.Position.RIGHT);\n "
      },
      "setLegendTextStyle": {
        "!type": "fn(textStyle: Charts.TextStyle) -> Charts.LineChartBuilder",
        "!doc": "Sets the text style of the chart legend.\n\n \n \n // Creates a line chart builder and sets it up for a  blue, 26-point legend.\n var textStyleBuilder = Charts.newTextStyle().setColor(&#39;#0000FF&#39;).setFontSize(26);\n var style = textStyleBuilder.build();\n var builder = Charts.newLineChart();\n builder.setLegendTextStyle(style);\n "
      },
      "setOption": {
        "!type": "fn(option: string, value: object) -> Charts.LineChartBuilder",
        "!doc": "Sets advanced options for this chart. See\n the available options for this chart.\n This method has no effect if the given option is invalid.\n\n \n\n \n \n // Build a line chart with a 1-second animation duration.\n var builder = Charts.newLineChart();\n builder.setOption(&#39;animation.duration&#39;, 1000); \n var chart = builder.build();\n "
      },
      "setPointStyle": {
        "!type": "fn(style: Charts.PointStyle) -> Charts.LineChartBuilder",
        "!doc": "Sets the style for points in the line.  By default, points will have no particular styles,\n and only the line will be visible.\n\n \n \n // Creates a line chart builder and sets large point style.\n var builder = Charts.newLineChart();\n builder.setPointStyle(Charts.PointStyle.LARGE);\n "
      },
      "setRange": {
        "!type": "fn(start: number, end: number) -> Charts.LineChartBuilder",
        "!doc": "Sets the range for the chart.\n \n If any data points fall outside the range, the range will be expanded to include those data\n points."
      },
      "setTitle": {
        "!type": "fn(chartTitle: string) -> Charts.LineChartBuilder",
        "!doc": "Sets the title of the chart.  The title will be displayed centered above the chart.\n\n \n \n // Creates a line chart builder and title to &#39;My Line Chart&#39;.\n var builder = Charts.newLineChart();\n builder.setTitle(&#39;My Line Chart&#39;)\n "
      },
      "setTitleTextStyle": {
        "!type": "fn(textStyle: Charts.TextStyle) -> Charts.LineChartBuilder",
        "!doc": "Sets the text style of the chart title.\n\n \n \n // Creates a line chart builder and sets it up for a  blue, 26-point title.\n var textStyleBuilder = Charts.newTextStyle().setColor(&#39;#0000FF&#39;).setFontSize(26);\n var style = textStyleBuilder.build();\n var builder = Charts.newLineChart();\n builder.setTitleTextStyle(style);\n "
      },
      "setXAxisTextStyle": {
        "!type": "fn(textStyle: Charts.TextStyle) -> Charts.LineChartBuilder",
        "!doc": "Sets the horizontal axis text style.\n\n \n \n // Creates a line chart builder and sets the X-axis text style to blue, 18-point font.\n var textStyle = Charts.newTextStyle().setColor(&#39;blue&#39;).setFontSize(18).build();\n var builder = Charts.newLineChart();\n builder.setXAxisTextStyle(textStyle);\n "
      },
      "setXAxisTitle": {
        "!type": "fn(title: string) -> Charts.LineChartBuilder",
        "!doc": "Adds a title to the horizontal axis.  The title will be centered and will appear below\n the axis value labels.\n\n \n \n // Creates a line chart builder and sets the X-axis title.\n var builder = Charts.newLineChart();\n builder.setTitle(&#39;X-axis Title&#39;)\n "
      },
      "setXAxisTitleTextStyle": {
        "!type": "fn(textStyle: Charts.TextStyle) -> Charts.LineChartBuilder",
        "!doc": "Sets the horizontal axis title text style.\n\n \n \n // Creates a line chart builder and sets the X-axis title text style to blue, 18-point font.\n var textStyle = Charts.newTextStyle().setColor(&#39;blue&#39;).setFontSize(18).build();\n var builder = Charts.newLineChart();\n builder.setXAxisTitleTextStyle(textStyle);\n "
      },
      "setYAxisTextStyle": {
        "!type": "fn(textStyle: Charts.TextStyle) -> Charts.LineChartBuilder",
        "!doc": "Sets the vertical axis text style.\n\n \n \n // Creates a line chart builder and sets the Y-axis text style to blue, 18-point font.\n var textStyle = Charts.newTextStyle().setColor(&#39;blue&#39;).setFontSize(18).build();\n var builder = Charts.newLineChart();\n builder.setYAxisTextStyle(textStyle);\n "
      },
      "setYAxisTitle": {
        "!type": "fn(title: string) -> Charts.LineChartBuilder",
        "!doc": "Adds a title to the vertical axis.  The title will be centered and will appear to the\n left of the value labels.\n\n \n \n // Creates a line chart builder and sets the Y-axis title.\n var builder = Charts.newLineChart();\n builder.setYAxisTitle(&#39;Y-axis Title&#39;)\n "
      },
      "setYAxisTitleTextStyle": {
        "!type": "fn(textStyle: Charts.TextStyle) -> Charts.LineChartBuilder",
        "!doc": "Sets the vertical axis title text style.\n\n \n \n // Creates a line chart builder and sets the Y-axis title text style to blue, 18-point font.\n var textStyle = Charts.newTextStyle().setColor(&#39;blue&#39;).setFontSize(18).build();\n var builder = Charts.newLineChart();\n builder.setYAxisTitleTextStyle(textStyle);\n "
      },
      "useLogScale": {
        "!type": "fn() -> Charts.LineChartBuilder",
        "!doc": "Makes the range axis into a logarithmic scale (requires all values to be positive).  The range\n axis will be the vertical axis for vertical charts (line, area, column, etc.) and the\n horizontal axis for horizontal charts (bar, etc.)"
      }
    },
    "Charts.MatchType": {
      "ANY": {
        "!type": "Charts.MatchType",
        "!doc": "Match any substring"
      },
      "EXACT": {
        "!type": "Charts.MatchType",
        "!doc": "Match exact values only"
      },
      "PREFIX": {
        "!type": "Charts.MatchType",
        "!doc": "Match prefixes starting from the beginning of the value"
      },
      "getName": {
        "!type": "fn() -> string",
        "!doc": "Returns the name of the MatchType to be used in the options JSON."
      }
    },
    "Charts.NumberRangeFilterBuilder": {
      "build": {
        "!type": "fn() -> Charts.Control",
        "!doc": "Builds a control."
      },
      "setDataTable": {
        "!type": "fn(tableBuilder: DataTableBuilder) -> Charts.NumberRangeFilterBuilder",
        "!doc": "Sets the data table to use for the control using a DataTableBuilder.\n\n This is a convenience method for setting the data table without needing to call\n build()."
      },
      "setDataTable ": {
        "!type": "fn(table: DataTableSource) -> Charts.NumberRangeFilterBuilder",
        "!doc": "Sets the control data table, which will be the control's underlying data model."
      },
      "setFilterColumnIndex": {
        "!type": "fn(columnIndex: number) -> Charts.NumberRangeFilterBuilder",
        "!doc": "Sets the index of the data table column to filter on.\n\n The values of that column will determine whether or not each row should be filtered.\n It is mandatory to set either this or the column label using\n setFilterColumnLabel(columnLabel)."
      },
      "setFilterColumnLabel": {
        "!type": "fn(columnLabel: string) -> Charts.NumberRangeFilterBuilder",
        "!doc": "Sets the label of the data table column to filter on.\n\n The values of that column will determine whether or not each row should be filtered.\n It is mandatory to set either this or a column index using setFilterColumnIndex(columnIndex)."
      },
      "setLabel": {
        "!type": "fn(label: string) -> Charts.NumberRangeFilterBuilder",
        "!doc": "Sets the label to display next to the slider.\n\n If unspecified, the label of the column the control operates on will be used."
      },
      "setLabelSeparator": {
        "!type": "fn(labelSeparator: string) -> Charts.NumberRangeFilterBuilder",
        "!doc": "Sets a separator string appended to the label, to visually separate the\n label from the category picker."
      },
      "setLabelStacking": {
        "!type": "fn(orientation: Charts.Orientation) -> Charts.NumberRangeFilterBuilder",
        "!doc": "Sets whether the label should display above (vertical stacking) or beside (horizontal stacking)\n the input field."
      },
      "setMaxValue": {
        "!type": "fn(maxValue: number) -> Charts.NumberRangeFilterBuilder",
        "!doc": "Sets the maximum allowed value for the range lower extent. If undefined, the value\n will be inferred from the contents of the DataTable managed by the control.\n\n \n \n // Builds a number range filter and sets the maximum value to 100.\n var numberRangeFilter = Charts.newNumberRangeFilter()\n   .setFilterColumnLabel(&quot;Col2&quot;)\n   .setMaxValue(100)\n   .build();\n "
      },
      "setMinValue": {
        "!type": "fn(minValue: number) -> Charts.NumberRangeFilterBuilder",
        "!doc": "Sets the minimum allowed value for the range lower extent. If undefined, the value\n will be inferred from the contents of the DataTable managed by the control.\n\n \n \n // Builds a number range filter and sets the minimum value to 10.\n var numberRangeFilter = Charts.newNumberRangeFilter()\n   .setFilterColumnLabel(&quot;Col2&quot;)\n   .setMinValue(10)\n   .build();\n "
      },
      "setOrientation": {
        "!type": "fn(orientation: Charts.Orientation) -> Charts.NumberRangeFilterBuilder",
        "!doc": "Sets the slider orientation.\n\n \n \n // Builds a number range filter and sets it to have a horizontal orientation.\n var numberRangeFilter = Charts.newNumberRangeFilter()\n   .setFilterColumnLabel(&quot;Col2&quot;)\n   .setOrientation(Charts.Orientation.HORIZONTAL)\n   .build();\n "
      },
      "setShowRangeValues": {
        "!type": "fn(showRangeValues: bool) -> Charts.NumberRangeFilterBuilder",
        "!doc": "Sets whether to have labels next to the slider displaying extents of the selected range.\n\n \n \n // Builds a number range filter and enables showing of the number range values.\n var numberRangeFilter = Charts.newNumberRangeFilter()\n   .setFilterColumnLabel(&quot;Col2&quot;)\n   .setShowRangeValues(true)\n   .build();\n "
      },
      "setTicks": {
        "!type": "fn(ticks: number) -> Charts.NumberRangeFilterBuilder",
        "!doc": "Sets the number of ticks (fixed positions in a range bar) a number range filter slider thumbs\n can fall in.\n\n \n \n // Builds a number range filter and sets the number of ticks for the range to 10.\n var numberRangeFilter = Charts.newNumberRangeFilter()\n   .setFilterColumnLabel(&quot;Col2&quot;)\n   .setTicks(10)\n   .build();\n "
      }
    },
    "Charts.Orientation": {
      "HORIZONTAL": {
        "!type": "Charts.Orientation",
        "!doc": "Horizontal orientation"
      },
      "VERTICAL": {
        "!type": "Charts.Orientation",
        "!doc": "Vertical  orientation"
      }
    },
    "Charts.PickerValuesLayout": {
      "ASIDE": {
        "!type": "Charts.PickerValuesLayout",
        "!doc": "Selected values will display in a single text line next to the value picker widget"
      },
      "BELOW": {
        "!type": "Charts.PickerValuesLayout",
        "!doc": "Selected values will display in a single text line below the widget"
      },
      "BELOW_STACKED": {
        "!type": "Charts.PickerValuesLayout",
        "!doc": "Selected values will be displayed in a column below the widget"
      },
      "BELOW_WRAPPING": {
        "!type": "Charts.PickerValuesLayout",
        "!doc": "Similar to below, but entries that cannot fit in the picker will wrap to a new line"
      }
    },
    "Charts.PieChartBuilder": {
      "build": {
        "!type": "fn() -> Charts.Chart",
        "!doc": "Builds the chart."
      },
      "reverseCategories": {
        "!type": "fn() -> Charts.PieChartBuilder",
        "!doc": "Reverses the drawing of series in the domain axis.  For vertical-range charts (such as line,\n area or column charts), this means the horizontal axis is drawn from right to left.  For\n horizontal-range charts (such as bar charts), this means the vertical axis is drawn from top\n to bottom.  For pie charts, this means the slices are drawn counterclockwise.\n\n \n \n // Creates a pie chart builder and sets drawing of the slices in a counter-clockwise manner.\n var builder = Charts.newPieChart();\n builder.reverseCategories();\n "
      },
      "set3D": {
        "!type": "fn() -> Charts.PieChartBuilder",
        "!doc": "Sets the chart to be three-dimensional."
      },
      "setBackgroundColor": {
        "!type": "fn(cssValue: string) -> Charts.PieChartBuilder",
        "!doc": "Sets the background color for the chart.\n\n \n \n // Creates a line chart builder and sets the background color to gray\n var builder = Charts.newLineChart();\n builder.setBackgroundColor(&quot;gray&quot;);\n "
      },
      "setColors": {
        "!type": "fn(cssValues: [string]) -> Charts.PieChartBuilder",
        "!doc": "Sets the colors for the lines in the chart.\n\n \n \n // Creates a line chart builder and sets the first two lines to be drawn in green and red,\n // respectively.\n var builder = Charts.newLineChart();\n builder.setColors([&quot;green&quot;, &quot;red&quot;]);\n "
      },
      "setDataSourceUrl": {
        "!type": "fn(url: string) -> Charts.PieChartBuilder",
        "!doc": "Sets the data source URL that will be used to pull data in from an\n external source, such as Google Sheets.\n If a data source URL and a DataTable are provided, the data source URL is ignored.\n\n For more information about querying data sources, check out the \n Google Charts documentation."
      },
      "setDataTable": {
        "!type": "fn(tableBuilder: DataTableBuilder) -> Charts.PieChartBuilder",
        "!doc": "Sets the data table to use for the chart using a DataTableBuilder.  This is a convenience\n method for setting the data table without needing to call build()."
      },
      "setDataTable ": {
        "!type": "fn(table: DataTableSource) -> Charts.PieChartBuilder",
        "!doc": "Sets the data table which contains the lines for the chart, as well as the X-axis labels.\n The first column should be a string, and contain the horizontal axis labels. Any number of\n columns can follow, all must be numeric.  Each column is displayed as a separate line."
      },
      "setDataViewDefinition": {
        "!type": "fn(dataViewDefinition: Charts.DataViewDefinition) -> Charts.PieChartBuilder",
        "!doc": "Sets the data view definition to use for the chart."
      },
      "setDimensions": {
        "!type": "fn(width: number, height: number) -> Charts.PieChartBuilder",
        "!doc": "Sets the dimensions for the chart."
      },
      "setLegendPosition": {
        "!type": "fn(position: Charts.Position) -> Charts.PieChartBuilder",
        "!doc": "Sets the position of the legend with respect to the chart.  By default, there will be no\n legend.\n\n \n \n // Creates a line chart builder and sets the legend position to right.\n var builder = Charts.newLineChart();\n builder.setLegendPosition(Charts.Position.RIGHT);\n "
      },
      "setLegendTextStyle": {
        "!type": "fn(textStyle: Charts.TextStyle) -> Charts.PieChartBuilder",
        "!doc": "Sets the text style of the chart legend.\n\n \n \n // Creates a line chart builder and sets it up for a  blue, 26-point legend.\n var textStyleBuilder = Charts.newTextStyle().setColor(&#39;#0000FF&#39;).setFontSize(26);\n var style = textStyleBuilder.build();\n var builder = Charts.newLineChart();\n builder.setLegendTextStyle(style);\n "
      },
      "setOption": {
        "!type": "fn(option: string, value: object) -> Charts.PieChartBuilder",
        "!doc": "Sets advanced options for this chart. See\n the available options for this chart.\n This method has no effect if the given option is invalid.\n\n \n\n \n \n // Build a pie chart with a pretty legend.\n var builder = Charts.newPieChart();\n builder.setOption(&#39;legend&#39;, {textStyle: {color: &#39;blue&#39;, fontSize: 16}}); \n var chart = builder.build();\n "
      },
      "setTitle": {
        "!type": "fn(chartTitle: string) -> Charts.PieChartBuilder",
        "!doc": "Sets the title of the chart.  The title will be displayed centered above the chart.\n\n \n \n // Creates a line chart builder and title to &#39;My Line Chart&#39;.\n var builder = Charts.newLineChart();\n builder.setTitle(&#39;My Line Chart&#39;)\n "
      },
      "setTitleTextStyle": {
        "!type": "fn(textStyle: Charts.TextStyle) -> Charts.PieChartBuilder",
        "!doc": "Sets the text style of the chart title.\n\n \n \n // Creates a line chart builder and sets it up for a  blue, 26-point title.\n var textStyleBuilder = Charts.newTextStyle().setColor(&#39;#0000FF&#39;).setFontSize(26);\n var style = textStyleBuilder.build();\n var builder = Charts.newLineChart();\n builder.setTitleTextStyle(style);\n "
      }
    },
    "Charts.PointStyle": {
      "HUGE": {
        "!type": "Charts.PointStyle",
        "!doc": "Use largest sized line points"
      },
      "LARGE": {
        "!type": "Charts.PointStyle",
        "!doc": "Use large sized line points"
      },
      "MEDIUM": {
        "!type": "Charts.PointStyle",
        "!doc": "Use medium sized line points"
      },
      "NONE": {
        "!type": "Charts.PointStyle",
        "!doc": "Do not display line points"
      },
      "TINY": {
        "!type": "Charts.PointStyle",
        "!doc": "Use tiny line points"
      }
    },
    "Charts.Position": {
      "BOTTOM": {
        "!type": "Charts.Position",
        "!doc": "Below the chart."
      },
      "NONE": {
        "!type": "Charts.Position",
        "!doc": "No legend is displayed."
      },
      "RIGHT": {
        "!type": "Charts.Position",
        "!doc": "To the right of the chart."
      },
      "TOP": {
        "!type": "Charts.Position",
        "!doc": "Above the chart."
      }
    },
    "Charts.ScatterChartBuilder": {
      "build": {
        "!type": "fn() -> Charts.Chart",
        "!doc": "Builds the chart."
      },
      "setBackgroundColor": {
        "!type": "fn(cssValue: string) -> Charts.ScatterChartBuilder",
        "!doc": "Sets the background color for the chart.\n\n \n \n // Creates a line chart builder and sets the background color to gray\n var builder = Charts.newLineChart();\n builder.setBackgroundColor(&quot;gray&quot;);\n "
      },
      "setColors": {
        "!type": "fn(cssValues: [string]) -> Charts.ScatterChartBuilder",
        "!doc": "Sets the colors for the lines in the chart.\n\n \n \n // Creates a line chart builder and sets the first two lines to be drawn in green and red,\n // respectively.\n var builder = Charts.newLineChart();\n builder.setColors([&quot;green&quot;, &quot;red&quot;]);\n "
      },
      "setDataSourceUrl": {
        "!type": "fn(url: string) -> Charts.ScatterChartBuilder",
        "!doc": "Sets the data source URL that will be used to pull data in from an\n external source, such as Google Sheets.\n If a data source URL and a DataTable are provided, the data source URL is ignored.\n\n For more information about querying data sources, check out the \n Google Charts documentation."
      },
      "setDataTable": {
        "!type": "fn(tableBuilder: DataTableBuilder) -> Charts.ScatterChartBuilder",
        "!doc": "Sets the data table to use for the chart using a DataTableBuilder.  This is a convenience\n method for setting the data table without needing to call build()."
      },
      "setDataTable ": {
        "!type": "fn(table: DataTableSource) -> Charts.ScatterChartBuilder",
        "!doc": "Sets the data table which contains the lines for the chart, as well as the X-axis labels.\n The first column should be a string, and contain the horizontal axis labels. Any number of\n columns can follow, all must be numeric.  Each column is displayed as a separate line."
      },
      "setDataViewDefinition": {
        "!type": "fn(dataViewDefinition: Charts.DataViewDefinition) -> Charts.ScatterChartBuilder",
        "!doc": "Sets the data view definition to use for the chart."
      },
      "setDimensions": {
        "!type": "fn(width: number, height: number) -> Charts.ScatterChartBuilder",
        "!doc": "Sets the dimensions for the chart."
      },
      "setLegendPosition": {
        "!type": "fn(position: Charts.Position) -> Charts.ScatterChartBuilder",
        "!doc": "Sets the position of the legend with respect to the chart.  By default, there will be no\n legend.\n\n \n \n // Creates a line chart builder and sets the legend position to right.\n var builder = Charts.newLineChart();\n builder.setLegendPosition(Charts.Position.RIGHT);\n "
      },
      "setLegendTextStyle": {
        "!type": "fn(textStyle: Charts.TextStyle) -> Charts.ScatterChartBuilder",
        "!doc": "Sets the text style of the chart legend.\n\n \n \n // Creates a line chart builder and sets it up for a  blue, 26-point legend.\n var textStyleBuilder = Charts.newTextStyle().setColor(&#39;#0000FF&#39;).setFontSize(26);\n var style = textStyleBuilder.build();\n var builder = Charts.newLineChart();\n builder.setLegendTextStyle(style);\n "
      },
      "setOption": {
        "!type": "fn(option: string, value: object) -> Charts.ScatterChartBuilder",
        "!doc": "Sets advanced options for this chart. See\n the available options for this chart.\n This method has no effect if the given option is invalid.\n\n \n\n \n \n // Build a scatter chart with a 1-second animation duration.\n var builder = Charts.newScatterChart();\n builder.setOption(&#39;animation.duration&#39;, 1000); \n var chart = builder.build();\n "
      },
      "setPointStyle": {
        "!type": "fn(style: Charts.PointStyle) -> Charts.ScatterChartBuilder",
        "!doc": "Sets the style for points in the line.  By default, points will have no particular styles,\n and only the line will be visible.\n\n \n \n // Creates a line chart builder and sets large point style.\n var builder = Charts.newLineChart();\n builder.setPointStyle(Charts.PointStyle.LARGE);\n "
      },
      "setTitle": {
        "!type": "fn(chartTitle: string) -> Charts.ScatterChartBuilder",
        "!doc": "Sets the title of the chart.  The title will be displayed centered above the chart.\n\n \n \n // Creates a line chart builder and title to &#39;My Line Chart&#39;.\n var builder = Charts.newLineChart();\n builder.setTitle(&#39;My Line Chart&#39;)\n "
      },
      "setTitleTextStyle": {
        "!type": "fn(textStyle: Charts.TextStyle) -> Charts.ScatterChartBuilder",
        "!doc": "Sets the text style of the chart title.\n\n \n \n // Creates a line chart builder and sets it up for a  blue, 26-point title.\n var textStyleBuilder = Charts.newTextStyle().setColor(&#39;#0000FF&#39;).setFontSize(26);\n var style = textStyleBuilder.build();\n var builder = Charts.newLineChart();\n builder.setTitleTextStyle(style);\n "
      },
      "setXAxisLogScale": {
        "!type": "fn() -> Charts.ScatterChartBuilder",
        "!doc": "Makes the horizontal axis into a logarithmic scale (requires all values to be positive)."
      },
      "setXAxisRange": {
        "!type": "fn(start: number, end: number) -> Charts.ScatterChartBuilder",
        "!doc": "Sets the range for the horizontal axis of the chart.\n \n If any data points fall outside the range, the range will be expanded to include those data\n points.\n\n \n \n // Creates a scatter chart builder and sets the X-axis range to be 0 to 100.\n var builder = Charts.newTableChart();\n builder.setXAxisRange(0, 100);\n "
      },
      "setXAxisTextStyle": {
        "!type": "fn(textStyle: Charts.TextStyle) -> Charts.ScatterChartBuilder",
        "!doc": "Sets the horizontal axis text style.\n\n \n \n // Creates a line chart builder and sets the X-axis text style to blue, 18-point font.\n var textStyle = Charts.newTextStyle().setColor(&#39;blue&#39;).setFontSize(18).build();\n var builder = Charts.newLineChart();\n builder.setXAxisTextStyle(textStyle);\n "
      },
      "setXAxisTitle": {
        "!type": "fn(title: string) -> Charts.ScatterChartBuilder",
        "!doc": "Adds a title to the horizontal axis.  The title will be centered and will appear below\n the axis value labels.\n\n \n \n // Creates a line chart builder and sets the X-axis title.\n var builder = Charts.newLineChart();\n builder.setTitle(&#39;X-axis Title&#39;)\n "
      },
      "setXAxisTitleTextStyle": {
        "!type": "fn(textStyle: Charts.TextStyle) -> Charts.ScatterChartBuilder",
        "!doc": "Sets the horizontal axis title text style.\n\n \n \n // Creates a line chart builder and sets the X-axis title text style to blue, 18-point font.\n var textStyle = Charts.newTextStyle().setColor(&#39;blue&#39;).setFontSize(18).build();\n var builder = Charts.newLineChart();\n builder.setXAxisTitleTextStyle(textStyle);\n "
      },
      "setYAxisLogScale": {
        "!type": "fn() -> Charts.ScatterChartBuilder",
        "!doc": "Makes the vertical axis into a logarithmic scale (requires all values to be positive)."
      },
      "setYAxisRange": {
        "!type": "fn(start: number, end: number) -> Charts.ScatterChartBuilder",
        "!doc": "Sets the range for the vertical axis of the chart. If any data points fall outside the range,\n the range will be expanded to include those data points.\n\n \n \n // Creates a scatter chart builder and sets the Y-axis range to be 0 to 100.\n var builder = Charts.newTableChart();\n builder.setYAxisRange(0, 100);\n "
      },
      "setYAxisTextStyle": {
        "!type": "fn(textStyle: Charts.TextStyle) -> Charts.ScatterChartBuilder",
        "!doc": "Sets the vertical axis text style.\n\n \n \n // Creates a line chart builder and sets the Y-axis text style to blue, 18-point font.\n var textStyle = Charts.newTextStyle().setColor(&#39;blue&#39;).setFontSize(18).build();\n var builder = Charts.newLineChart();\n builder.setYAxisTextStyle(textStyle);\n "
      },
      "setYAxisTitle": {
        "!type": "fn(title: string) -> Charts.ScatterChartBuilder",
        "!doc": "Adds a title to the vertical axis.  The title will be centered and will appear to the\n left of the value labels.\n\n \n \n // Creates a line chart builder and sets the Y-axis title.\n var builder = Charts.newLineChart();\n builder.setYAxisTitle(&#39;Y-axis Title&#39;)\n "
      },
      "setYAxisTitleTextStyle": {
        "!type": "fn(textStyle: Charts.TextStyle) -> Charts.ScatterChartBuilder",
        "!doc": "Sets the vertical axis title text style.\n\n \n \n // Creates a line chart builder and sets the Y-axis title text style to blue, 18-point font.\n var textStyle = Charts.newTextStyle().setColor(&#39;blue&#39;).setFontSize(18).build();\n var builder = Charts.newLineChart();\n builder.setYAxisTitleTextStyle(textStyle);\n "
      }
    },
    "Charts.StringFilterBuilder": {
      "build": {
        "!type": "fn() -> Charts.Control",
        "!doc": "Builds a control."
      },
      "setCaseSensitive": {
        "!type": "fn(caseSensitive: bool) -> Charts.StringFilterBuilder",
        "!doc": "Sets whether matching should be case sensitive or not.\n\n \n \n // Builds a case insensitive string filter to filter column &quot;Col1&quot;.\n var stringFilter = Charts.newStringFilter()\n   .setFilterColumnLabel(&quot;Col1&quot;)\n   .setCaseSensitive(false)\n   .build();\n "
      },
      "setDataTable": {
        "!type": "fn(tableBuilder: DataTableBuilder) -> Charts.StringFilterBuilder",
        "!doc": "Sets the data table to use for the control using a DataTableBuilder.\n\n This is a convenience method for setting the data table without needing to call\n build()."
      },
      "setDataTable ": {
        "!type": "fn(table: DataTableSource) -> Charts.StringFilterBuilder",
        "!doc": "Sets the control data table, which will be the control's underlying data model."
      },
      "setFilterColumnIndex": {
        "!type": "fn(columnIndex: number) -> Charts.StringFilterBuilder",
        "!doc": "Sets the index of the data table column to filter on.\n\n The values of that column will determine whether or not each row should be filtered.\n It is mandatory to set either this or the column label using\n setFilterColumnLabel(columnLabel)."
      },
      "setFilterColumnLabel": {
        "!type": "fn(columnLabel: string) -> Charts.StringFilterBuilder",
        "!doc": "Sets the label of the data table column to filter on.\n\n The values of that column will determine whether or not each row should be filtered.\n It is mandatory to set either this or a column index using setFilterColumnIndex(columnIndex)."
      },
      "setLabel": {
        "!type": "fn(label: string) -> Charts.StringFilterBuilder",
        "!doc": "Sets the label to display next to the slider.\n\n If unspecified, the label of the column the control operates on will be used."
      },
      "setLabelSeparator": {
        "!type": "fn(labelSeparator: string) -> Charts.StringFilterBuilder",
        "!doc": "Sets a separator string appended to the label, to visually separate the\n label from the category picker."
      },
      "setLabelStacking": {
        "!type": "fn(orientation: Charts.Orientation) -> Charts.StringFilterBuilder",
        "!doc": "Sets whether the label should display above (vertical stacking) or beside (horizontal stacking)\n the input field."
      },
      "setMatchType": {
        "!type": "fn(matchType: Charts.MatchType) -> Charts.StringFilterBuilder",
        "!doc": "Sets whether the control should match exact values only (MatchType.EXACT), prefixes\n starting from the beginning of the value (MatchType.PREFIX), or any substring\n (MatchType.ANY).\n\n \n \n // Builds a string filter to filter column &quot;Col1&quot; matching the prefix.\n var stringFilter = Charts.newStringFilter()\n   .setFilterColumnLabel(&quot;Col1&quot;)\n   .setMatchType(Charts.MatchType.PREFIX)\n   .build();\n "
      },
      "setRealtimeTrigger": {
        "!type": "fn(realtimeTrigger: bool) -> Charts.StringFilterBuilder",
        "!doc": "Sets whether the control should match any time a key is pressed or only when the input field\n 'changes' (loss of focus or pressing the Enter key).\n\n \n \n // Builds a string filter to filter column &quot;Col1&quot; that checks the match any time a key is\n // pressed.\n var stringFilter = Charts.newStringFilter()\n   .setFilterColumnLabel(&quot;Col1&quot;)\n   .setRealtimeTrigger(true)\n   .build();\n "
      }
    },
    "Charts.TableChartBuilder": {
      "build": {
        "!type": "fn() -> Charts.Chart",
        "!doc": "Builds the chart."
      },
      "enablePaging": {
        "!type": "fn(enablePaging: bool) -> Charts.TableChartBuilder",
        "!doc": "Sets whether to enable paging through the data.\n \n The default behavior is paging disabled. If paging is enabled the default page size is 10."
      },
      "enablePaging ": {
        "!type": "fn(pageSize: number) -> Charts.TableChartBuilder",
        "!doc": "Enables paging and sets the number of rows in each page.\n \n The default page size is 10.\n\n \n \n // Creates a table chart builder and enables paging with page size of 5.\n var builder = Charts.newTableChart();\n builder.enablePaging(5);\n "
      },
      "enablePaging  ": {
        "!type": "fn(pageSize: number, startPage: number) -> Charts.TableChartBuilder",
        "!doc": "Enables paging, sets the number of rows in each page and the first table page to display\n (page numbers are zero based).\n \n The default page size is 10, and the default start page is 0.\n\n \n \n // Creates a table chart builder and enables paging with page size of 5 and displays page 2\n // first.\n var builder = Charts.newTableChart();\n builder.enablePaging(5, 2);\n "
      },
      "enableRtlTable": {
        "!type": "fn(rtlEnabled: bool) -> Charts.TableChartBuilder",
        "!doc": "Adds basic support for right-to-left languages (such as Arabic or Hebrew) by reversing\n the column order of the table, so that column zero is the right-most column, and the last\n column is the left-most column.\n \n This does not affect the column index in the underlying data, only the order of display.\n Full bi-directional (BiDi) language display is not supported by\n the table visualization even with this option. This option will be ignored if you enable\n paging (using the page option), or if the table has scroll bars because you have specified\n height and width options smaller than the required table size.\n The default behavior is RTL support disabled."
      },
      "enableSorting": {
        "!type": "fn(enableSorting: bool) -> Charts.TableChartBuilder",
        "!doc": "Sets whether to sort columns when the user clicks a column heading.\n \n If sorting is enabled, when users click on the column header the rows will be automatically\n sorted. The default behavior is sorting enabled."
      },
      "setDataSourceUrl": {
        "!type": "fn(url: string) -> Charts.TableChartBuilder",
        "!doc": "Sets the data source URL that will be used to pull data in from an\n external source, such as Google Sheets.\n If a data source URL and a DataTable are provided, the data source URL is ignored.\n\n For more information about querying data sources, check out the \n Google Charts documentation."
      },
      "setDataTable": {
        "!type": "fn(tableBuilder: DataTableBuilder) -> Charts.TableChartBuilder",
        "!doc": "Sets the data table to use for the chart using a DataTableBuilder.  This is a convenience\n method for setting the data table without needing to call build()."
      },
      "setDataTable ": {
        "!type": "fn(table: DataTableSource) -> Charts.TableChartBuilder",
        "!doc": "Sets the data table which contains the lines for the chart, as well as the X-axis labels.\n The first column should be a string, and contain the horizontal axis labels. Any number of\n columns can follow, all must be numeric.  Each column is displayed as a separate line."
      },
      "setDataViewDefinition": {
        "!type": "fn(dataViewDefinition: Charts.DataViewDefinition) -> Charts.TableChartBuilder",
        "!doc": "Sets the data view definition to use for the chart."
      },
      "setDimensions": {
        "!type": "fn(width: number, height: number) -> Charts.TableChartBuilder",
        "!doc": "Sets the dimensions for the chart."
      },
      "setFirstRowNumber": {
        "!type": "fn(number: number) -> Charts.TableChartBuilder",
        "!doc": "Sets the row number for the first row in the data table.\n \n The default row number of the first row is 1.\n\n \n \n // Creates a table chart builder and sets the first row to be 2.\n var builder = Charts.newTableChart();\n builder.setFirstRowNumber(2);\n "
      },
      "setInitialSortingAscending": {
        "!type": "fn(column: number) -> Charts.TableChartBuilder",
        "!doc": "Sets the index of the column according to which the table should be initially sorted\n (ascending).\n \n The column will be sorted in ascending order and will be marked with a small arrow\n indicating that.\n\n \n \n // Creates a table chart builder and sorts it by the second column (ascending).\n var builder = Charts.newTableChart();\n builder.setInitialSortingAscending(2);\n "
      },
      "setInitialSortingDescending": {
        "!type": "fn(column: number) -> Charts.TableChartBuilder",
        "!doc": "Sets the index of the column according to which the table should be initially sorted\n (descending).\n \n The column will be sorted in descending order and be marked with a a small arrow\n indicating that.\n\n \n \n // Creates a table chart builder and sorts it by the second column (descending).\n var builder = Charts.newTableChart();\n builder.setInitialSortingDescending(2);\n "
      },
      "setOption": {
        "!type": "fn(option: string, value: object) -> Charts.TableChartBuilder",
        "!doc": "Sets advanced options for this chart. See\n the available options for this chart.\n This method has no effect if the given option is invalid.\n\n \n\n \n \n // Build a table chart which renders HTML.\n var builder = Charts.newTableChart();\n builder.setOption(&#39;allowHtml&#39;, true); \n var chart = builder.build();\n "
      },
      "showRowNumberColumn": {
        "!type": "fn(showRowNumber: bool) -> Charts.TableChartBuilder",
        "!doc": "Sets whether to show the row number as the first column of the table.\n \n The default behavior is not showing row numbers."
      },
      "useAlternatingRowStyle": {
        "!type": "fn(alternate: bool) -> Charts.TableChartBuilder",
        "!doc": "Sets whether alternating color style will be assigned to odd and even rows of a table\n chart.\n \n The default behavior is the rows having alternating color style."
      }
    },
    "Charts.TextStyle": {
      "getColor": {
        "!type": "fn() -> string",
        "!doc": "Gets the color of the text style.\n\n \n \n // Creates a new text style that uses blue text and logs the color.\n var textStyle = Charts.newTextStyle().setColor(&#39;blue&#39;).build();\n Logger.log(textStyle.getColor());\n "
      },
      "getFontName": {
        "!type": "fn() -> string",
        "!doc": "Gets the font name of the text style.\n\n \n \n // Creates a new text style that uses Ariel font and logs the font name.\n var textStyle = Charts.newTextStyle().setFontName(&#39;Ariel&#39;).build();\n Logger.log(textStyle.getFontName());\n "
      },
      "getFontSize": {
        "!type": "fn() -> number",
        "!doc": "Gets the font size of the text style.\n\n \n \n // Creates a new text style that uses 18 pixel font size and logs the font size.\n var textStyle = Charts.newTextStyle().setFontSize(18).build();\n Logger.log(textStyle.getFontSize());\n "
      }
    },
    "Charts.TextStyleBuilder": {
      "build": {
        "!type": "fn() -> Charts.TextStyle",
        "!doc": "Builds and returns a text style configuration object that was built using this builder.\n\n \n \n // Creates a new text style that uses 26-point blue font.\n var textStyleBuilder = Charts.newTextStyle().setColor(&#39;#0000FF&#39;).setFontSize(26);\n var style = textStyleBuilder.build();\n "
      },
      "setColor": {
        "!type": "fn(cssValue: string) -> Charts.TextStyleBuilder",
        "!doc": "Sets the color of the text style.\n\n \n \n // Creates a new text style that uses blue font.\n var textStyleBuilder = Charts.newTextStyle().setColor(&#39;#0000FF&#39;);\n var style = textStyleBuilder.build();\n "
      },
      "setFontName": {
        "!type": "fn(fontName: string) -> Charts.TextStyleBuilder",
        "!doc": "Sets the font name of the text style\n\n \n \n // Creates a new text style that uses Ariel font.\n var textStyleBuilder = Charts.newTextStyle().setFontName(&#39;Ariel&#39;);\n var style = textStyleBuilder.build();\n "
      },
      "setFontSize": {
        "!type": "fn(fontSize: number) -> Charts.TextStyleBuilder",
        "!doc": "Sets the font size of the text style.\n\n \n \n // Creates a new text style that uses 26-point font.\n var textStyleBuilder = Charts.newTextStyle().setFontSize(26);\n var style = textStyleBuilder.build();\n "
      }
    },
    "UrlFetchApp.HTTPResponse": {
      "getAllHeaders": {
        "!type": "fn() -> object",
        "!doc": "Returns an attribute/value map of headers for the HTTP response, with headers that have\n multiple values returned as arrays.\n\n \n \n   // The code below logs the HTTP headers from the response\n   // received when fetching the Google home page.\n   var response = UrlFetchApp.fetch(&quot;http://www.google.com/&quot;);\n   Logger.log(response.getAllHeaders().toSource());\n "
      },
      "getAs": {
        "!type": "fn(contentType: string) -> Blob",
        "!doc": "Return the data inside this object as a blob converted to the specified content type. This\n method adds the appropriate extension to the filename ? for example, \"myfile.pdf\". However, it\n assumes that the part of the filename that follows the last period (if any) is an existing\n extension that should be replaced. Consequently, \"ChristmasList.12.25.2014\" will become\n \"ChristmasList.12.25.pdf\"."
      },
      "getBlob": {
        "!type": "fn() -> Blob",
        "!doc": "Return the data inside this object as a blob."
      },
      "getContent": {
        "!type": "fn() -> [number]",
        "!doc": "Gets the raw binary content of an HTTP response.\n\n \n \n   // The code below logs the value of the first byte of the Google home page.\n   var response = UrlFetchApp.fetch(&quot;http://www.google.com/&quot;);\n   Logger.log(response.getContent()[0]);\n "
      },
      "getContentText": {
        "!type": "fn() -> string",
        "!doc": "Gets the content of an HTTP response encoded as a string.\n\n \n \n   // The code below logs the HTML code of the Google home page.\n   var response = UrlFetchApp.fetch(&quot;http://www.google.com/&quot;);\n   Logger.log(response.getContentText());\n "
      },
      "getContentText ": {
        "!type": "fn(charset: string) -> string",
        "!doc": "Returns the content of an HTTP response encoded as a string of the given charset.\n\n \n \n   // The code below logs the HTML code of the Google home page with the UTF-8 charset.\n   var response = UrlFetchApp.fetch(&quot;http://www.google.com/&quot;);\n   Logger.log(response.getContentText(&quot;UTF-8&quot;));\n "
      },
      "getHeaders": {
        "!type": "fn() -> object",
        "!doc": "Returns an attribute/value map of headers for the HTTP response.\n\n \n \n   // The code below logs the HTTP headers from the response\n   // received when fetching the Google home page.\n   var response = UrlFetchApp.fetch(&quot;http://www.google.com/&quot;);\n   Logger.log(response.getHeaders().toSource());\n "
      },
      "getResponseCode": {
        "!type": "fn() -> number",
        "!doc": "Get the HTTP status code (200 for OK, etc.) of an HTTP response.\n\n \n \n   // The code below logs the HTTP status code from the response received\n   // when fetching the Google home page.\n   // It should be 200 if the request succeeded.\n   var response = UrlFetchApp.fetch(&quot;http://www.google.com/&quot;);\n   Logger.log(response.getResponseCode());\n "
      }
    },
    "Utilities.Charset": {
      "US_ASCII": {
        "!type": "Utilities.Charset"
      },
      "UTF_8": {
        "!type": "Utilities.Charset"
      }
    },
    "Utilities.MacAlgorithm": {
      "HMAC_MD5": {
        "!type": "Utilities.MacAlgorithm"
      },
      "HMAC_SHA_1": {
        "!type": "Utilities.MacAlgorithm"
      },
      "HMAC_SHA_256": {
        "!type": "Utilities.MacAlgorithm"
      },
      "HMAC_SHA_384": {
        "!type": "Utilities.MacAlgorithm"
      },
      "HMAC_SHA_512": {
        "!type": "Utilities.MacAlgorithm"
      }
    },
    "AdWordsApp.Account": {
      "addCallout": {
        "!type": "fn(calloutExtension: Callout) -> AdWordsApp.CalloutOperation"
      },
      "addMobileApp": {
        "!type": "fn(mobileAppExtension: MobileApp) -> AdWordsApp.MobileAppOperation"
      },
      "addReview": {
        "!type": "fn(reviewExtension: Review) -> AdWordsApp.ReviewOperation"
      },
      "extensions": {
        "!type": "fn() -> AdWordsApp.AccountExtensions"
      },
      "getCurrencyCode": {
        "!type": "fn() -> string"
      },
      "getCustomerId": {
        "!type": "fn() -> string"
      },
      "getEntityType": {
        "!type": "fn() -> string"
      },
      "getName": {
        "!type": "fn() -> string"
      },
      "getStatsFor": {
        "!type": "fn(dateFrom: object, dateTo: object) -> AdWordsApp.Stats"
      },
      "getStatsFor ": {
        "!type": "fn(dateRange: string) -> AdWordsApp.Stats"
      },
      "getTimeZone": {
        "!type": "fn() -> string"
      },
      "removeCallout": {
        "!type": "fn(calloutExtension: Callout)"
      },
      "removeMobileApp": {
        "!type": "fn(mobileAppExtension: MobileApp)"
      },
      "removeReview": {
        "!type": "fn(reviewExtension: Review)"
      }
    },
    "AdWordsApp.AccountCallout": {
      "getEndDate": {
        "!type": "fn() -> AdWordsApp.AdWordsDate"
      },
      "getEntityType": {
        "!type": "fn() -> string"
      },
      "getId": {
        "!type": "fn() -> number"
      },
      "getSchedules": {
        "!type": "fn() -> [AdWordsApp.ExtensionSchedule]"
      },
      "getStartDate": {
        "!type": "fn() -> AdWordsApp.AdWordsDate"
      },
      "getStatsFor": {
        "!type": "fn(dateFrom: object, dateTo: object) -> AdWordsApp.Stats"
      },
      "getStatsFor ": {
        "!type": "fn(dateRange: string) -> AdWordsApp.Stats"
      },
      "getText": {
        "!type": "fn() -> string"
      },
      "isMobilePreferred": {
        "!type": "fn() -> bool"
      },
      "setEndDate": {
        "!type": "fn(date: object)"
      },
      "setMobilePreferred": {
        "!type": "fn(isMobilePreferred: bool)"
      },
      "setSchedules": {
        "!type": "fn(schedules: [AdWordsApp.ExtensionSchedule])"
      },
      "setStartDate": {
        "!type": "fn(date: object)"
      },
      "setText": {
        "!type": "fn(text: string)"
      }
    },
    "AdWordsApp.AccountCalloutIterator": {
      "hasNext": {
        "!type": "fn() -> bool"
      },
      "next": {
        "!type": "fn() -> AdWordsApp.AccountCallout"
      },
      "totalNumEntities": {
        "!type": "fn() -> number"
      }
    },
    "AdWordsApp.AccountCalloutSelector": {
      "forDateRange": {
        "!type": "fn(dateFrom: object, dateTo: object) -> AdWordsApp.AccountCalloutSelector"
      },
      "forDateRange ": {
        "!type": "fn(dateRange: string) -> AdWordsApp.AccountCalloutSelector"
      },
      "get": {
        "!type": "fn() -> AdWordsApp.AccountCalloutIterator"
      },
      "orderBy": {
        "!type": "fn(orderBy: string) -> AdWordsApp.AccountCalloutSelector"
      },
      "withCondition": {
        "!type": "fn(condition: string) -> AdWordsApp.AccountCalloutSelector"
      },
      "withIds": {
        "!type": "fn(ids: [number]) -> AdWordsApp.AccountCalloutSelector"
      },
      "withLimit": {
        "!type": "fn(limit: number) -> AdWordsApp.AccountCalloutSelector"
      }
    },
    "AdWordsApp.AccountExtensions": {
      "callouts": {
        "!type": "fn() -> AdWordsApp.AccountCalloutSelector"
      },
      "mobileApps": {
        "!type": "fn() -> AdWordsApp.AccountMobileAppSelector"
      },
      "reviews": {
        "!type": "fn() -> AdWordsApp.AccountReviewSelector"
      }
    },
    "AdWordsApp.AccountMobileApp": {
      "clearLinkUrl": {
        "!type": "fn()"
      },
      "getAppId": {
        "!type": "fn() -> string"
      },
      "getEndDate": {
        "!type": "fn() -> AdWordsApp.AdWordsDate"
      },
      "getEntityType": {
        "!type": "fn() -> string"
      },
      "getId": {
        "!type": "fn() -> number"
      },
      "getLinkText": {
        "!type": "fn() -> string"
      },
      "getLinkUrl": {
        "!type": "fn() -> string"
      },
      "getSchedules": {
        "!type": "fn() -> [AdWordsApp.ExtensionSchedule]"
      },
      "getStartDate": {
        "!type": "fn() -> AdWordsApp.AdWordsDate"
      },
      "getStatsFor": {
        "!type": "fn(dateFrom: object, dateTo: object) -> AdWordsApp.Stats"
      },
      "getStatsFor ": {
        "!type": "fn(dateRange: string) -> AdWordsApp.Stats"
      },
      "getStore": {
        "!type": "fn() -> string"
      },
      "isMobilePreferred": {
        "!type": "fn() -> bool"
      },
      "setAppId": {
        "!type": "fn(appId: string)"
      },
      "setEndDate": {
        "!type": "fn(date: object)"
      },
      "setLinkText": {
        "!type": "fn(linkText: string)"
      },
      "setLinkUrl": {
        "!type": "fn(linkUrl: string)"
      },
      "setMobilePreferred": {
        "!type": "fn(isMobilePreferred: bool)"
      },
      "setSchedules": {
        "!type": "fn(schedules: [AdWordsApp.ExtensionSchedule])"
      },
      "setStartDate": {
        "!type": "fn(date: object)"
      },
      "setStore": {
        "!type": "fn(store: string)"
      },
      "urls": {
        "!type": "fn() -> AdWordsApp.MobileAppUrls"
      }
    },
    "AdWordsApp.AccountMobileAppIterator": {
      "hasNext": {
        "!type": "fn() -> bool"
      },
      "next": {
        "!type": "fn() -> AdWordsApp.AccountMobileApp"
      },
      "totalNumEntities": {
        "!type": "fn() -> number"
      }
    },
    "AdWordsApp.AccountMobileAppSelector": {
      "forDateRange": {
        "!type": "fn(dateFrom: object, dateTo: object) -> AdWordsApp.AccountMobileAppSelector"
      },
      "forDateRange ": {
        "!type": "fn(dateRange: string) -> AdWordsApp.AccountMobileAppSelector"
      },
      "get": {
        "!type": "fn() -> AdWordsApp.AccountMobileAppIterator"
      },
      "orderBy": {
        "!type": "fn(orderBy: string) -> AdWordsApp.AccountMobileAppSelector"
      },
      "withCondition": {
        "!type": "fn(condition: string) -> AdWordsApp.AccountMobileAppSelector"
      },
      "withIds": {
        "!type": "fn(ids: [number]) -> AdWordsApp.AccountMobileAppSelector"
      },
      "withLimit": {
        "!type": "fn(limit: number) -> AdWordsApp.AccountMobileAppSelector"
      }
    },
    "AdWordsApp.AccountReview": {
      "getEndDate": {
        "!type": "fn() -> AdWordsApp.AdWordsDate"
      },
      "getEntityType": {
        "!type": "fn() -> string"
      },
      "getId": {
        "!type": "fn() -> number"
      },
      "getSchedules": {
        "!type": "fn() -> [AdWordsApp.ExtensionSchedule]"
      },
      "getSourceName": {
        "!type": "fn() -> string"
      },
      "getSourceUrl": {
        "!type": "fn() -> string"
      },
      "getStartDate": {
        "!type": "fn() -> AdWordsApp.AdWordsDate"
      },
      "getStatsFor": {
        "!type": "fn(dateFrom: object, dateTo: object) -> AdWordsApp.Stats"
      },
      "getStatsFor ": {
        "!type": "fn(dateRange: string) -> AdWordsApp.Stats"
      },
      "getText": {
        "!type": "fn() -> string"
      },
      "isExactlyQuoted": {
        "!type": "fn() -> bool"
      },
      "isMobilePreferred": {
        "!type": "fn() -> bool"
      },
      "setEndDate": {
        "!type": "fn(date: object)"
      },
      "setExactlyQuoted": {
        "!type": "fn(isExactlyQuoted: bool)"
      },
      "setMobilePreferred": {
        "!type": "fn(isMobilePreferred: bool)"
      },
      "setSchedules": {
        "!type": "fn(schedules: [AdWordsApp.ExtensionSchedule])"
      },
      "setSourceName": {
        "!type": "fn(sourceName: string)"
      },
      "setSourceUrl": {
        "!type": "fn(sourceUrl: string)"
      },
      "setStartDate": {
        "!type": "fn(date: object)"
      },
      "setText": {
        "!type": "fn(text: string)"
      }
    },
    "AdWordsApp.AccountReviewIterator": {
      "hasNext": {
        "!type": "fn() -> bool"
      },
      "next": {
        "!type": "fn() -> AdWordsApp.AccountReview"
      },
      "totalNumEntities": {
        "!type": "fn() -> number"
      }
    },
    "AdWordsApp.AccountReviewSelector": {
      "forDateRange": {
        "!type": "fn(dateFrom: object, dateTo: object) -> AdWordsApp.AccountReviewSelector"
      },
      "forDateRange ": {
        "!type": "fn(dateRange: string) -> AdWordsApp.AccountReviewSelector"
      },
      "get": {
        "!type": "fn() -> AdWordsApp.AccountReviewIterator"
      },
      "orderBy": {
        "!type": "fn(orderBy: string) -> AdWordsApp.AccountReviewSelector"
      },
      "withCondition": {
        "!type": "fn(condition: string) -> AdWordsApp.AccountReviewSelector"
      },
      "withIds": {
        "!type": "fn(ids: [number]) -> AdWordsApp.AccountReviewSelector"
      },
      "withLimit": {
        "!type": "fn(limit: number) -> AdWordsApp.AccountReviewSelector"
      }
    },
    "AdWordsApp.Ad": {
      "applyLabel": {
        "!type": "fn(name: string)"
      },
      "enable": {
        "!type": "fn()"
      },
      "getAdGroup": {
        "!type": "fn() -> AdWordsApp.AdGroup"
      },
      "getApprovalStatus": {
        "!type": "fn() -> string"
      },
      "getCampaign": {
        "!type": "fn() -> AdWordsApp.Campaign"
      },
      "getDescription1": {
        "!type": "fn() -> string"
      },
      "getDescription2": {
        "!type": "fn() -> string"
      },
      "getDestinationUrl": {
        "!type": "fn() -> string"
      },
      "getDisapprovalReasons": {
        "!type": "fn() -> [string]"
      },
      "getDisplayUrl": {
        "!type": "fn() -> string"
      },
      "getEntityType": {
        "!type": "fn() -> string"
      },
      "getHeadline": {
        "!type": "fn() -> string"
      },
      "getId": {
        "!type": "fn() -> number"
      },
      "getStatsFor": {
        "!type": "fn(dateFrom: object, dateTo: object) -> AdWordsApp.Stats"
      },
      "getStatsFor ": {
        "!type": "fn(dateRange: string) -> AdWordsApp.Stats"
      },
      "getType": {
        "!type": "fn() -> string"
      },
      "isEnabled": {
        "!type": "fn() -> bool"
      },
      "isMobilePreferred": {
        "!type": "fn() -> bool"
      },
      "isPaused": {
        "!type": "fn() -> bool"
      },
      "labels": {
        "!type": "fn() -> AdWordsApp.LabelSelector"
      },
      "pause": {
        "!type": "fn()"
      },
      "remove": {
        "!type": "fn()"
      },
      "removeLabel": {
        "!type": "fn(name: string)"
      },
      "urls": {
        "!type": "fn() -> AdWordsApp.AdUrls"
      }
    },
    "AdWordsApp.AdBuilder": {
      "build": {
        "!type": "fn() -> AdWordsApp.AdOperation"
      },
      "withCustomParameters": {
        "!type": "fn(customParameters: object) -> AdWordsApp.AdBuilder"
      },
      "withDescription1": {
        "!type": "fn(description1: string) -> AdWordsApp.AdBuilder"
      },
      "withDescription2": {
        "!type": "fn(description2: string) -> AdWordsApp.AdBuilder"
      },
      "withDestinationUrl": {
        "!type": "fn(destinationUrl: string) -> AdWordsApp.AdBuilder"
      },
      "withDisplayUrl": {
        "!type": "fn(displayUrl: string) -> AdWordsApp.AdBuilder"
      },
      "withFinalUrl": {
        "!type": "fn(finalUrl: string) -> AdWordsApp.AdBuilder"
      },
      "withHeadline": {
        "!type": "fn(headline: string) -> AdWordsApp.AdBuilder"
      },
      "withMobileFinalUrl": {
        "!type": "fn(mobileFinalUrl: string) -> AdWordsApp.AdBuilder"
      },
      "withMobilePreferred": {
        "!type": "fn(isMobilePreferred: bool) -> AdWordsApp.AdBuilder"
      },
      "withTrackingTemplate": {
        "!type": "fn(trackingTemplate: string) -> AdWordsApp.AdBuilder"
      }
    },
    "AdWordsApp.AdCustomizerItem": {
      "clearTargetAdGroup": {
        "!type": "fn()"
      },
      "clearTargetCampaign": {
        "!type": "fn()"
      },
      "clearTargetKeyword": {
        "!type": "fn()"
      },
      "getAttributeValue": {
        "!type": "fn(name: string) -> object"
      },
      "getAttributeValues": {
        "!type": "fn() -> object"
      },
      "getEndDate": {
        "!type": "fn() -> AdWordsApp.AdWordsDate"
      },
      "getEntityType": {
        "!type": "fn() -> string"
      },
      "getId": {
        "!type": "fn() -> number"
      },
      "getSchedules": {
        "!type": "fn() -> [AdWordsApp.ExtensionSchedule]"
      },
      "getStartDate": {
        "!type": "fn() -> AdWordsApp.AdWordsDate"
      },
      "getTargetAdGroupName": {
        "!type": "fn() -> string"
      },
      "getTargetCampaignName": {
        "!type": "fn() -> string"
      },
      "getTargetKeywordText": {
        "!type": "fn() -> string"
      },
      "isMobilePreferred": {
        "!type": "fn() -> bool"
      },
      "remove": {
        "!type": "fn()"
      },
      "setAttributeValue": {
        "!type": "fn(name: string, value: object)"
      },
      "setAttributeValues": {
        "!type": "fn(attributeValues: object)"
      },
      "setEndDate": {
        "!type": "fn(date: object)"
      },
      "setMobilePreferred": {
        "!type": "fn(isMobilePreferred: bool)"
      },
      "setSchedules": {
        "!type": "fn(schedules: [AdWordsApp.ExtensionSchedule])"
      },
      "setStartDate": {
        "!type": "fn(date: object)"
      },
      "setTargetAdGroup": {
        "!type": "fn(campaignName: string, adGroupName: string)"
      },
      "setTargetCampaign": {
        "!type": "fn(campaignName: string)"
      },
      "setTargetKeyword": {
        "!type": "fn(keyword: string)"
      }
    },
    "AdWordsApp.AdCustomizerItemBuilder": {
      "build": {
        "!type": "fn() -> AdWordsApp.AdCustomizerItemOperation"
      },
      "withAttributeValue": {
        "!type": "fn(name: string, value: object) -> AdWordsApp.AdCustomizerItemBuilder"
      },
      "withAttributeValues": {
        "!type": "fn(attributeValues: object) -> AdWordsApp.AdCustomizerItemBuilder"
      },
      "withEndDate": {
        "!type": "fn(date: object) -> AdWordsApp.AdCustomizerItemBuilder"
      },
      "withMobilePreferred": {
        "!type": "fn(isMobilePreferred: bool) -> AdWordsApp.AdCustomizerItemBuilder"
      },
      "withSchedules": {
        "!type": "fn(schedules: [AdWordsApp.ExtensionSchedule]) -> AdWordsApp.AdCustomizerItemBuilder"
      },
      "withStartDate": {
        "!type": "fn(date: object) -> AdWordsApp.AdCustomizerItemBuilder"
      },
      "withTargetAdGroup": {
        "!type": "fn(campaignName: string, adGroupName: string) -> AdWordsApp.AdCustomizerItemBuilder"
      },
      "withTargetCampaign": {
        "!type": "fn(campaignName: string) -> AdWordsApp.AdCustomizerItemBuilder"
      },
      "withTargetKeyword": {
        "!type": "fn(keyword: string) -> AdWordsApp.AdCustomizerItemBuilder"
      }
    },
    "AdWordsApp.AdCustomizerItemIterator": {
      "hasNext": {
        "!type": "fn() -> bool"
      },
      "next": {
        "!type": "fn() -> AdWordsApp.AdCustomizerItem"
      },
      "totalNumEntities": {
        "!type": "fn() -> number"
      }
    },
    "AdWordsApp.AdCustomizerItemOperation": {
      "getErrors": {
        "!type": "fn() -> [string]"
      },
      "getResult": {
        "!type": "fn() -> AdWordsApp.AdCustomizerItem"
      },
      "isSuccessful": {
        "!type": "fn() -> bool"
      }
    },
    "AdWordsApp.AdCustomizerItemSelector": {
      "forDateRange": {
        "!type": "fn(dateFrom: object, dateTo: object) -> AdWordsApp.AdCustomizerItemSelector"
      },
      "forDateRange ": {
        "!type": "fn(dateRange: string) -> AdWordsApp.AdCustomizerItemSelector"
      },
      "get": {
        "!type": "fn() -> AdWordsApp.AdCustomizerItemIterator"
      },
      "orderBy": {
        "!type": "fn(orderBy: string) -> AdWordsApp.AdCustomizerItemSelector"
      },
      "withCondition": {
        "!type": "fn(condition: string) -> AdWordsApp.AdCustomizerItemSelector"
      },
      "withIds": {
        "!type": "fn(ids: [number]) -> AdWordsApp.AdCustomizerItemSelector"
      },
      "withLimit": {
        "!type": "fn(limit: number) -> AdWordsApp.AdCustomizerItemSelector"
      }
    },
    "AdWordsApp.AdCustomizerSource": {
      "adCustomizerItemBuilder": {
        "!type": "fn() -> AdWordsApp.AdCustomizerItemBuilder"
      },
      "getAttributes": {
        "!type": "fn() -> object"
      },
      "getEntityType": {
        "!type": "fn() -> string"
      },
      "getName": {
        "!type": "fn() -> string"
      },
      "items": {
        "!type": "fn() -> AdWordsApp.AdCustomizerItemSelector"
      }
    },
    "AdWordsApp.AdCustomizerSourceBuilder": {
      "addAttribute": {
        "!type": "fn(name: string, type: string) -> AdWordsApp.AdCustomizerSourceBuilder"
      },
      "addAttributes": {
        "!type": "fn(attributes: object) -> AdWordsApp.AdCustomizerSourceBuilder"
      },
      "build": {
        "!type": "fn() -> AdWordsApp.AdCustomizerSourceOperation"
      },
      "withName": {
        "!type": "fn(name: string) -> AdWordsApp.AdCustomizerSourceBuilder"
      }
    },
    "AdWordsApp.AdCustomizerSourceIterator": {
      "hasNext": {
        "!type": "fn() -> bool"
      },
      "next": {
        "!type": "fn() -> AdWordsApp.AdCustomizerSource"
      },
      "totalNumEntities": {
        "!type": "fn() -> number"
      }
    },
    "AdWordsApp.AdCustomizerSourceOperation": {
      "getErrors": {
        "!type": "fn() -> [string]"
      },
      "getResult": {
        "!type": "fn() -> AdWordsApp.AdCustomizerSource"
      },
      "isSuccessful": {
        "!type": "fn() -> bool"
      }
    },
    "AdWordsApp.AdCustomizerSourceSelector": {
      "get": {
        "!type": "fn() -> AdWordsApp.AdCustomizerSourceIterator"
      },
      "withLimit": {
        "!type": "fn(limit: number) -> AdWordsApp.AdCustomizerSourceSelector"
      }
    },
    "AdWordsApp.AdGroup": {
      "adParams": {
        "!type": "fn() -> AdWordsApp.AdParamSelector"
      },
      "addCallout": {
        "!type": "fn(calloutExtension: Callout) -> AdWordsApp.CalloutOperation"
      },
      "addMobileApp": {
        "!type": "fn(mobileAppExtension: MobileApp) -> AdWordsApp.MobileAppOperation"
      },
      "addPhoneNumber": {
        "!type": "fn(phoneNumberExtension: PhoneNumber) -> AdWordsApp.PhoneNumberOperation"
      },
      "addReview": {
        "!type": "fn(reviewExtension: Review) -> AdWordsApp.ReviewOperation"
      },
      "addSitelink": {
        "!type": "fn(sitelinkExtension: Sitelink) -> AdWordsApp.SitelinkOperation"
      },
      "ads": {
        "!type": "fn() -> AdWordsApp.AdSelector"
      },
      "applyLabel": {
        "!type": "fn(name: string)"
      },
      "bidding": {
        "!type": "fn() -> AdWordsApp.AdGroupBidding"
      },
      "clearMobileBidModifier": {
        "!type": "fn()"
      },
      "createNegativeKeyword": {
        "!type": "fn(keywordText: string)"
      },
      "display": {
        "!type": "fn() -> AdWordsApp.AdGroupDisplay"
      },
      "enable": {
        "!type": "fn()"
      },
      "extensions": {
        "!type": "fn() -> AdWordsApp.AdGroupExtensions"
      },
      "getCampaign": {
        "!type": "fn() -> AdWordsApp.Campaign"
      },
      "getEntityType": {
        "!type": "fn() -> string"
      },
      "getId": {
        "!type": "fn() -> number"
      },
      "getMobileBidModifier": {
        "!type": "fn() -> number"
      },
      "getName": {
        "!type": "fn() -> string"
      },
      "getStatsFor": {
        "!type": "fn(dateFrom: object, dateTo: object) -> AdWordsApp.Stats"
      },
      "getStatsFor ": {
        "!type": "fn(dateRange: string) -> AdWordsApp.Stats"
      },
      "isEnabled": {
        "!type": "fn() -> bool"
      },
      "isPaused": {
        "!type": "fn() -> bool"
      },
      "isRemoved": {
        "!type": "fn() -> bool"
      },
      "keywords": {
        "!type": "fn() -> AdWordsApp.KeywordSelector"
      },
      "labels": {
        "!type": "fn() -> AdWordsApp.LabelSelector"
      },
      "negativeKeywords": {
        "!type": "fn() -> AdWordsApp.NegativeKeywordSelector"
      },
      "newKeywordBuilder": {
        "!type": "fn() -> AdWordsApp.KeywordBuilder"
      },
      "newTextAdBuilder": {
        "!type": "fn() -> AdWordsApp.AdBuilder"
      },
      "pause": {
        "!type": "fn()"
      },
      "removeCallout": {
        "!type": "fn(calloutExtension: Callout)"
      },
      "removeLabel": {
        "!type": "fn(name: string)"
      },
      "removeMobileApp": {
        "!type": "fn(mobileAppExtension: MobileApp)"
      },
      "removePhoneNumber": {
        "!type": "fn(phoneNumberExtension: PhoneNumber)"
      },
      "removeReview": {
        "!type": "fn(reviewExtension: Review)"
      },
      "removeSitelink": {
        "!type": "fn(sitelinkExtension: Sitelink)"
      },
      "setMobileBidModifier": {
        "!type": "fn(modifier: number)"
      },
      "setName": {
        "!type": "fn(name: string)"
      },
      "urls": {
        "!type": "fn() -> AdWordsApp.AdGroupUrls"
      }
    },
    "AdWordsApp.AdGroupBidding": {
      "clearStrategy": {
        "!type": "fn()"
      },
      "getCpa": {
        "!type": "fn() -> number"
      },
      "getCpc": {
        "!type": "fn() -> number"
      },
      "getCpm": {
        "!type": "fn() -> number"
      },
      "getStrategy": {
        "!type": "fn() -> AdWordsApp.BiddingStrategy"
      },
      "getStrategySource": {
        "!type": "fn() -> string"
      },
      "getStrategyType": {
        "!type": "fn() -> string"
      },
      "setCpa": {
        "!type": "fn(cpa: number)"
      },
      "setCpc": {
        "!type": "fn(cpc: number)"
      },
      "setCpm": {
        "!type": "fn(cpm: number)"
      },
      "setStrategy": {
        "!type": "fn(biddingStrategy: BiddingStrategy)"
      },
      "setStrategy ": {
        "!type": "fn(biddingStrategy: string)"
      }
    },
    "AdWordsApp.AdGroupBuilder": {
      "build": {
        "!type": "fn() -> AdWordsApp.AdGroupOperation"
      },
      "withBiddingStrategy": {
        "!type": "fn(biddingStrategy: BiddingStrategy) -> AdWordsApp.AdGroupBuilder"
      },
      "withBiddingStrategy ": {
        "!type": "fn(biddingStrategy: string) -> AdWordsApp.AdGroupBuilder"
      },
      "withCpa": {
        "!type": "fn(cpa: number) -> AdWordsApp.AdGroupBuilder"
      },
      "withCpc": {
        "!type": "fn(cpc: number) -> AdWordsApp.AdGroupBuilder"
      },
      "withCpm": {
        "!type": "fn(cpm: number) -> AdWordsApp.AdGroupBuilder"
      },
      "withCustomParameters": {
        "!type": "fn(customParameters: object) -> AdWordsApp.AdGroupBuilder"
      },
      "withName": {
        "!type": "fn(name: string) -> AdWordsApp.AdGroupBuilder"
      },
      "withStatus": {
        "!type": "fn(status: string) -> AdWordsApp.AdGroupBuilder"
      },
      "withTrackingTemplate": {
        "!type": "fn(trackingTemplate: string) -> AdWordsApp.AdGroupBuilder"
      }
    },
    "AdWordsApp.AdGroupCallout": {
      "getAdGroup": {
        "!type": "fn() -> AdWordsApp.AdGroup"
      },
      "getCampaign": {
        "!type": "fn() -> AdWordsApp.Campaign"
      },
      "getEndDate": {
        "!type": "fn() -> AdWordsApp.AdWordsDate"
      },
      "getEntityType": {
        "!type": "fn() -> string"
      },
      "getId": {
        "!type": "fn() -> number"
      },
      "getSchedules": {
        "!type": "fn() -> [AdWordsApp.ExtensionSchedule]"
      },
      "getStartDate": {
        "!type": "fn() -> AdWordsApp.AdWordsDate"
      },
      "getStatsFor": {
        "!type": "fn(dateFrom: object, dateTo: object) -> AdWordsApp.Stats"
      },
      "getStatsFor ": {
        "!type": "fn(dateRange: string) -> AdWordsApp.Stats"
      },
      "getText": {
        "!type": "fn() -> string"
      },
      "isMobilePreferred": {
        "!type": "fn() -> bool"
      },
      "setEndDate": {
        "!type": "fn(date: object)"
      },
      "setMobilePreferred": {
        "!type": "fn(isMobilePreferred: bool)"
      },
      "setSchedules": {
        "!type": "fn(schedules: [AdWordsApp.ExtensionSchedule])"
      },
      "setStartDate": {
        "!type": "fn(date: object)"
      },
      "setText": {
        "!type": "fn(text: string)"
      }
    },
    "AdWordsApp.AdGroupCalloutIterator": {
      "hasNext": {
        "!type": "fn() -> bool"
      },
      "next": {
        "!type": "fn() -> AdWordsApp.AdGroupCallout"
      },
      "totalNumEntities": {
        "!type": "fn() -> number"
      }
    },
    "AdWordsApp.AdGroupCalloutSelector": {
      "forDateRange": {
        "!type": "fn(dateFrom: object, dateTo: object) -> AdWordsApp.AdGroupCalloutSelector"
      },
      "forDateRange ": {
        "!type": "fn(dateRange: string) -> AdWordsApp.AdGroupCalloutSelector"
      },
      "get": {
        "!type": "fn() -> AdWordsApp.AdGroupCalloutIterator"
      },
      "orderBy": {
        "!type": "fn(orderBy: string) -> AdWordsApp.AdGroupCalloutSelector"
      },
      "withCondition": {
        "!type": "fn(condition: string) -> AdWordsApp.AdGroupCalloutSelector"
      },
      "withIds": {
        "!type": "fn(ids: [number]) -> AdWordsApp.AdGroupCalloutSelector"
      },
      "withLimit": {
        "!type": "fn(limit: number) -> AdWordsApp.AdGroupCalloutSelector"
      }
    },
    "AdWordsApp.AdGroupDisplay": {
      "audiences": {
        "!type": "fn() -> AdWordsApp.AudienceSelector"
      },
      "excludedAudiences": {
        "!type": "fn() -> AdWordsApp.ExcludedAudienceSelector"
      },
      "excludedKeywords": {
        "!type": "fn() -> AdWordsApp.ExcludedDisplayKeywordSelector"
      },
      "excludedPlacements": {
        "!type": "fn() -> AdWordsApp.ExcludedPlacementSelector"
      },
      "excludedTopics": {
        "!type": "fn() -> AdWordsApp.ExcludedTopicSelector"
      },
      "keywords": {
        "!type": "fn() -> AdWordsApp.DisplayKeywordSelector"
      },
      "newAudienceBuilder": {
        "!type": "fn() -> AdWordsApp.AudienceBuilder"
      },
      "newKeywordBuilder": {
        "!type": "fn() -> AdWordsApp.DisplayKeywordBuilder"
      },
      "newPlacementBuilder": {
        "!type": "fn() -> AdWordsApp.PlacementBuilder"
      },
      "newTopicBuilder": {
        "!type": "fn() -> AdWordsApp.TopicBuilder"
      },
      "placements": {
        "!type": "fn() -> AdWordsApp.PlacementSelector"
      },
      "topics": {
        "!type": "fn() -> AdWordsApp.TopicSelector"
      }
    },
    "AdWordsApp.AdGroupExtensions": {
      "callouts": {
        "!type": "fn() -> AdWordsApp.AdGroupCalloutSelector"
      },
      "mobileApps": {
        "!type": "fn() -> AdWordsApp.AdGroupMobileAppSelector"
      },
      "phoneNumbers": {
        "!type": "fn() -> AdWordsApp.AdGroupPhoneNumberSelector"
      },
      "reviews": {
        "!type": "fn() -> AdWordsApp.AdGroupReviewSelector"
      },
      "sitelinks": {
        "!type": "fn() -> AdWordsApp.AdGroupSitelinkSelector"
      }
    },
    "AdWordsApp.AdGroupIterator": {
      "hasNext": {
        "!type": "fn() -> bool"
      },
      "next": {
        "!type": "fn() -> AdWordsApp.AdGroup"
      },
      "totalNumEntities": {
        "!type": "fn() -> number"
      }
    },
    "AdWordsApp.AdGroupMobileApp": {
      "clearLinkUrl": {
        "!type": "fn()"
      },
      "getAdGroup": {
        "!type": "fn() -> AdWordsApp.AdGroup"
      },
      "getAppId": {
        "!type": "fn() -> string"
      },
      "getCampaign": {
        "!type": "fn() -> AdWordsApp.Campaign"
      },
      "getEndDate": {
        "!type": "fn() -> AdWordsApp.AdWordsDate"
      },
      "getEntityType": {
        "!type": "fn() -> string"
      },
      "getId": {
        "!type": "fn() -> number"
      },
      "getLinkText": {
        "!type": "fn() -> string"
      },
      "getLinkUrl": {
        "!type": "fn() -> string"
      },
      "getSchedules": {
        "!type": "fn() -> [AdWordsApp.ExtensionSchedule]"
      },
      "getStartDate": {
        "!type": "fn() -> AdWordsApp.AdWordsDate"
      },
      "getStatsFor": {
        "!type": "fn(dateFrom: object, dateTo: object) -> AdWordsApp.Stats"
      },
      "getStatsFor ": {
        "!type": "fn(dateRange: string) -> AdWordsApp.Stats"
      },
      "getStore": {
        "!type": "fn() -> string"
      },
      "isMobilePreferred": {
        "!type": "fn() -> bool"
      },
      "setAppId": {
        "!type": "fn(appId: string)"
      },
      "setEndDate": {
        "!type": "fn(date: object)"
      },
      "setLinkText": {
        "!type": "fn(linkText: string)"
      },
      "setLinkUrl": {
        "!type": "fn(linkUrl: string)"
      },
      "setMobilePreferred": {
        "!type": "fn(isMobilePreferred: bool)"
      },
      "setSchedules": {
        "!type": "fn(schedules: [AdWordsApp.ExtensionSchedule])"
      },
      "setStartDate": {
        "!type": "fn(date: object)"
      },
      "setStore": {
        "!type": "fn(store: string)"
      },
      "urls": {
        "!type": "fn() -> AdWordsApp.MobileAppUrls"
      }
    },
    "AdWordsApp.AdGroupMobileAppIterator": {
      "hasNext": {
        "!type": "fn() -> bool"
      },
      "next": {
        "!type": "fn() -> AdWordsApp.AdGroupMobileApp"
      },
      "totalNumEntities": {
        "!type": "fn() -> number"
      }
    },
    "AdWordsApp.AdGroupMobileAppSelector": {
      "forDateRange": {
        "!type": "fn(dateFrom: object, dateTo: object) -> AdWordsApp.AdGroupMobileAppSelector"
      },
      "forDateRange ": {
        "!type": "fn(dateRange: string) -> AdWordsApp.AdGroupMobileAppSelector"
      },
      "get": {
        "!type": "fn() -> AdWordsApp.AdGroupMobileAppIterator"
      },
      "orderBy": {
        "!type": "fn(orderBy: string) -> AdWordsApp.AdGroupMobileAppSelector"
      },
      "withCondition": {
        "!type": "fn(condition: string) -> AdWordsApp.AdGroupMobileAppSelector"
      },
      "withIds": {
        "!type": "fn(ids: [number]) -> AdWordsApp.AdGroupMobileAppSelector"
      },
      "withLimit": {
        "!type": "fn(limit: number) -> AdWordsApp.AdGroupMobileAppSelector"
      }
    },
    "AdWordsApp.AdGroupOperation": {
      "getErrors": {
        "!type": "fn() -> [string]"
      },
      "getResult": {
        "!type": "fn() -> AdWordsApp.AdGroup"
      },
      "isSuccessful": {
        "!type": "fn() -> bool"
      }
    },
    "AdWordsApp.AdGroupPhoneNumber": {
      "getAdGroup": {
        "!type": "fn() -> AdWordsApp.AdGroup"
      },
      "getCampaign": {
        "!type": "fn() -> AdWordsApp.Campaign"
      },
      "getCountry": {
        "!type": "fn() -> string"
      },
      "getEndDate": {
        "!type": "fn() -> AdWordsApp.AdWordsDate"
      },
      "getEntityType": {
        "!type": "fn() -> string"
      },
      "getId": {
        "!type": "fn() -> number"
      },
      "getPhoneNumber": {
        "!type": "fn() -> string"
      },
      "getSchedules": {
        "!type": "fn() -> [AdWordsApp.ExtensionSchedule]"
      },
      "getStartDate": {
        "!type": "fn() -> AdWordsApp.AdWordsDate"
      },
      "getStatsFor": {
        "!type": "fn(dateFrom: object, dateTo: object) -> AdWordsApp.Stats"
      },
      "getStatsFor ": {
        "!type": "fn(dateRange: string) -> AdWordsApp.Stats"
      },
      "isCallOnly": {
        "!type": "fn() -> bool"
      },
      "isMobilePreferred": {
        "!type": "fn() -> bool"
      },
      "setCallOnly": {
        "!type": "fn(callOnly: bool)"
      },
      "setCountry": {
        "!type": "fn(country: string)"
      },
      "setEndDate": {
        "!type": "fn(date: object)"
      },
      "setMobilePreferred": {
        "!type": "fn(isMobilePreferred: bool)"
      },
      "setPhoneNumber": {
        "!type": "fn(phoneNumber: string)"
      },
      "setSchedules": {
        "!type": "fn(schedules: [AdWordsApp.ExtensionSchedule])"
      },
      "setStartDate": {
        "!type": "fn(date: object)"
      }
    },
    "AdWordsApp.AdGroupPhoneNumberIterator": {
      "hasNext": {
        "!type": "fn() -> bool"
      },
      "next": {
        "!type": "fn() -> AdWordsApp.AdGroupPhoneNumber"
      },
      "totalNumEntities": {
        "!type": "fn() -> number"
      }
    },
    "AdWordsApp.AdGroupPhoneNumberSelector": {
      "forDateRange": {
        "!type": "fn(dateFrom: object, dateTo: object) -> AdWordsApp.AdGroupPhoneNumberSelector"
      },
      "forDateRange ": {
        "!type": "fn(dateRange: string) -> AdWordsApp.AdGroupPhoneNumberSelector"
      },
      "get": {
        "!type": "fn() -> AdWordsApp.AdGroupPhoneNumberIterator"
      },
      "orderBy": {
        "!type": "fn(orderBy: string) -> AdWordsApp.AdGroupPhoneNumberSelector"
      },
      "withCondition": {
        "!type": "fn(condition: string) -> AdWordsApp.AdGroupPhoneNumberSelector"
      },
      "withIds": {
        "!type": "fn(ids: [number]) -> AdWordsApp.AdGroupPhoneNumberSelector"
      },
      "withLimit": {
        "!type": "fn(limit: number) -> AdWordsApp.AdGroupPhoneNumberSelector"
      }
    },
    "AdWordsApp.AdGroupReview": {
      "getAdGroup": {
        "!type": "fn() -> AdWordsApp.AdGroup"
      },
      "getCampaign": {
        "!type": "fn() -> AdWordsApp.Campaign"
      },
      "getEndDate": {
        "!type": "fn() -> AdWordsApp.AdWordsDate"
      },
      "getEntityType": {
        "!type": "fn() -> string"
      },
      "getId": {
        "!type": "fn() -> number"
      },
      "getSchedules": {
        "!type": "fn() -> [AdWordsApp.ExtensionSchedule]"
      },
      "getSourceName": {
        "!type": "fn() -> string"
      },
      "getSourceUrl": {
        "!type": "fn() -> string"
      },
      "getStartDate": {
        "!type": "fn() -> AdWordsApp.AdWordsDate"
      },
      "getStatsFor": {
        "!type": "fn(dateFrom: object, dateTo: object) -> AdWordsApp.Stats"
      },
      "getStatsFor ": {
        "!type": "fn(dateRange: string) -> AdWordsApp.Stats"
      },
      "getText": {
        "!type": "fn() -> string"
      },
      "isExactlyQuoted": {
        "!type": "fn() -> bool"
      },
      "isMobilePreferred": {
        "!type": "fn() -> bool"
      },
      "setEndDate": {
        "!type": "fn(date: object)"
      },
      "setExactlyQuoted": {
        "!type": "fn(isExactlyQuoted: bool)"
      },
      "setMobilePreferred": {
        "!type": "fn(isMobilePreferred: bool)"
      },
      "setSchedules": {
        "!type": "fn(schedules: [AdWordsApp.ExtensionSchedule])"
      },
      "setSourceName": {
        "!type": "fn(sourceName: string)"
      },
      "setSourceUrl": {
        "!type": "fn(sourceUrl: string)"
      },
      "setStartDate": {
        "!type": "fn(date: object)"
      },
      "setText": {
        "!type": "fn(text: string)"
      }
    },
    "AdWordsApp.AdGroupReviewIterator": {
      "hasNext": {
        "!type": "fn() -> bool"
      },
      "next": {
        "!type": "fn() -> AdWordsApp.AdGroupReview"
      },
      "totalNumEntities": {
        "!type": "fn() -> number"
      }
    },
    "AdWordsApp.AdGroupReviewSelector": {
      "forDateRange": {
        "!type": "fn(dateFrom: object, dateTo: object) -> AdWordsApp.AdGroupReviewSelector"
      },
      "forDateRange ": {
        "!type": "fn(dateRange: string) -> AdWordsApp.AdGroupReviewSelector"
      },
      "get": {
        "!type": "fn() -> AdWordsApp.AdGroupReviewIterator"
      },
      "orderBy": {
        "!type": "fn(orderBy: string) -> AdWordsApp.AdGroupReviewSelector"
      },
      "withCondition": {
        "!type": "fn(condition: string) -> AdWordsApp.AdGroupReviewSelector"
      },
      "withIds": {
        "!type": "fn(ids: [number]) -> AdWordsApp.AdGroupReviewSelector"
      },
      "withLimit": {
        "!type": "fn(limit: number) -> AdWordsApp.AdGroupReviewSelector"
      }
    },
    "AdWordsApp.AdGroupSelector": {
      "forDateRange": {
        "!type": "fn(dateFrom: object, dateTo: object) -> AdWordsApp.AdGroupSelector"
      },
      "forDateRange ": {
        "!type": "fn(dateRange: string) -> AdWordsApp.AdGroupSelector"
      },
      "get": {
        "!type": "fn() -> AdWordsApp.AdGroupIterator"
      },
      "orderBy": {
        "!type": "fn(orderBy: string) -> AdWordsApp.AdGroupSelector"
      },
      "withCondition": {
        "!type": "fn(condition: string) -> AdWordsApp.AdGroupSelector"
      },
      "withIds": {
        "!type": "fn(ids: [number]) -> AdWordsApp.AdGroupSelector"
      },
      "withLimit": {
        "!type": "fn(limit: number) -> AdWordsApp.AdGroupSelector"
      }
    },
    "AdWordsApp.AdGroupSitelink": {
      "clearDescription1": {
        "!type": "fn()"
      },
      "clearDescription2": {
        "!type": "fn()"
      },
      "clearLinkUrl": {
        "!type": "fn()"
      },
      "getAdGroup": {
        "!type": "fn() -> AdWordsApp.AdGroup"
      },
      "getCampaign": {
        "!type": "fn() -> AdWordsApp.Campaign"
      },
      "getDescription1": {
        "!type": "fn() -> string"
      },
      "getDescription2": {
        "!type": "fn() -> string"
      },
      "getEndDate": {
        "!type": "fn() -> AdWordsApp.AdWordsDate"
      },
      "getEntityType": {
        "!type": "fn() -> string"
      },
      "getId": {
        "!type": "fn() -> number"
      },
      "getLinkText": {
        "!type": "fn() -> string"
      },
      "getLinkUrl": {
        "!type": "fn() -> string"
      },
      "getSchedules": {
        "!type": "fn() -> [AdWordsApp.ExtensionSchedule]"
      },
      "getStartDate": {
        "!type": "fn() -> AdWordsApp.AdWordsDate"
      },
      "getStatsFor": {
        "!type": "fn(dateFrom: object, dateTo: object) -> AdWordsApp.Stats"
      },
      "getStatsFor ": {
        "!type": "fn(dateRange: string) -> AdWordsApp.Stats"
      },
      "isMobilePreferred": {
        "!type": "fn() -> bool"
      },
      "setDescription1": {
        "!type": "fn(description1: string)"
      },
      "setDescription2": {
        "!type": "fn(description2: string)"
      },
      "setEndDate": {
        "!type": "fn(date: object)"
      },
      "setLinkText": {
        "!type": "fn(linkText: string)"
      },
      "setLinkUrl": {
        "!type": "fn(linkUrl: string)"
      },
      "setMobilePreferred": {
        "!type": "fn(isMobilePreferred: bool)"
      },
      "setSchedules": {
        "!type": "fn(schedules: [AdWordsApp.ExtensionSchedule])"
      },
      "setStartDate": {
        "!type": "fn(date: object)"
      },
      "urls": {
        "!type": "fn() -> AdWordsApp.SitelinkUrls"
      }
    },
    "AdWordsApp.AdGroupSitelinkIterator": {
      "hasNext": {
        "!type": "fn() -> bool"
      },
      "next": {
        "!type": "fn() -> AdWordsApp.AdGroupSitelink"
      },
      "totalNumEntities": {
        "!type": "fn() -> number"
      }
    },
    "AdWordsApp.AdGroupSitelinkSelector": {
      "forDateRange": {
        "!type": "fn(dateFrom: object, dateTo: object) -> AdWordsApp.AdGroupSitelinkSelector"
      },
      "forDateRange ": {
        "!type": "fn(dateRange: string) -> AdWordsApp.AdGroupSitelinkSelector"
      },
      "get": {
        "!type": "fn() -> AdWordsApp.AdGroupSitelinkIterator"
      },
      "orderBy": {
        "!type": "fn(orderBy: string) -> AdWordsApp.AdGroupSitelinkSelector"
      },
      "withCondition": {
        "!type": "fn(condition: string) -> AdWordsApp.AdGroupSitelinkSelector"
      },
      "withIds": {
        "!type": "fn(ids: [number]) -> AdWordsApp.AdGroupSitelinkSelector"
      },
      "withLimit": {
        "!type": "fn(limit: number) -> AdWordsApp.AdGroupSitelinkSelector"
      }
    },
    "AdWordsApp.AdGroupUrls": {
      "clearTrackingTemplate": {
        "!type": "fn()"
      },
      "getCustomParameters": {
        "!type": "fn() -> object"
      },
      "getTrackingTemplate": {
        "!type": "fn() -> string"
      },
      "setCustomParameters": {
        "!type": "fn(customParameters: object)"
      },
      "setTrackingTemplate": {
        "!type": "fn(trackingTemplate: string)"
      }
    },
    "AdWordsApp.AdIterator": {
      "hasNext": {
        "!type": "fn() -> bool"
      },
      "next": {
        "!type": "fn() -> AdWordsApp.Ad"
      },
      "totalNumEntities": {
        "!type": "fn() -> number"
      }
    },
    "AdWordsApp.AdOperation": {
      "getErrors": {
        "!type": "fn() -> [string]"
      },
      "getResult": {
        "!type": "fn() -> AdWordsApp.Ad"
      },
      "isSuccessful": {
        "!type": "fn() -> bool"
      }
    },
    "AdWordsApp.AdParam": {
      "getAdGroup": {
        "!type": "fn() -> AdWordsApp.AdGroup"
      },
      "getEntityType": {
        "!type": "fn() -> string"
      },
      "getIndex": {
        "!type": "fn() -> number"
      },
      "getInsertionText": {
        "!type": "fn() -> string"
      },
      "getKeyword": {
        "!type": "fn() -> AdWordsApp.Keyword"
      },
      "remove": {
        "!type": "fn()"
      },
      "setInsertionText": {
        "!type": "fn(insertionText: string)"
      }
    },
    "AdWordsApp.AdParamIterator": {
      "hasNext": {
        "!type": "fn() -> bool"
      },
      "next": {
        "!type": "fn() -> AdWordsApp.AdParam"
      },
      "totalNumEntities": {
        "!type": "fn() -> number"
      }
    },
    "AdWordsApp.AdParamSelector": {
      "get": {
        "!type": "fn() -> AdWordsApp.AdParamIterator"
      }
    },
    "AdWordsApp.AdSchedule": {
      "getBidModifier": {
        "!type": "fn() -> number"
      },
      "getCampaign": {
        "!type": "fn() -> AdWordsApp.Campaign"
      },
      "getDayOfWeek": {
        "!type": "fn() -> string"
      },
      "getEndHour": {
        "!type": "fn() -> number"
      },
      "getEndMinute": {
        "!type": "fn() -> number"
      },
      "getEntityType": {
        "!type": "fn() -> string"
      },
      "getId": {
        "!type": "fn() -> number"
      },
      "getStartHour": {
        "!type": "fn() -> number"
      },
      "getStartMinute": {
        "!type": "fn() -> number"
      },
      "getStatsFor": {
        "!type": "fn(dateFrom: object, dateTo: object) -> AdWordsApp.Stats"
      },
      "getStatsFor ": {
        "!type": "fn(dateRange: string) -> AdWordsApp.Stats"
      },
      "remove": {
        "!type": "fn()"
      },
      "setBidModifier": {
        "!type": "fn(modifier: number)"
      }
    },
    "AdWordsApp.AdScheduleIterator": {
      "hasNext": {
        "!type": "fn() -> bool"
      },
      "next": {
        "!type": "fn() -> AdWordsApp.AdSchedule"
      },
      "totalNumEntities": {
        "!type": "fn() -> number"
      }
    },
    "AdWordsApp.AdScheduleSelector": {
      "forDateRange": {
        "!type": "fn(dateFrom: object, dateTo: object) -> AdWordsApp.AdScheduleSelector"
      },
      "forDateRange ": {
        "!type": "fn(dateRange: string) -> AdWordsApp.AdScheduleSelector"
      },
      "get": {
        "!type": "fn() -> AdWordsApp.AdScheduleIterator"
      },
      "orderBy": {
        "!type": "fn(orderBy: string) -> AdWordsApp.AdScheduleSelector"
      },
      "withCondition": {
        "!type": "fn(condition: string) -> AdWordsApp.AdScheduleSelector"
      },
      "withIds": {
        "!type": "fn(ids: [number]) -> AdWordsApp.AdScheduleSelector"
      },
      "withLimit": {
        "!type": "fn(limit: number) -> AdWordsApp.AdScheduleSelector"
      }
    },
    "AdWordsApp.AdSelector": {
      "forDateRange": {
        "!type": "fn(dateFrom: object, dateTo: object) -> AdWordsApp.AdSelector"
      },
      "forDateRange ": {
        "!type": "fn(dateRange: string) -> AdWordsApp.AdSelector"
      },
      "get": {
        "!type": "fn() -> AdWordsApp.AdIterator"
      },
      "orderBy": {
        "!type": "fn(orderBy: string) -> AdWordsApp.AdSelector"
      },
      "withCondition": {
        "!type": "fn(condition: string) -> AdWordsApp.AdSelector"
      },
      "withIds": {
        "!type": "fn(ids: [number]) -> AdWordsApp.AdSelector"
      },
      "withLimit": {
        "!type": "fn(limit: number) -> AdWordsApp.AdSelector"
      }
    },
    "AdWordsApp.AdUrls": {
      "getCustomParameters": {
        "!type": "fn() -> object"
      },
      "getFinalUrl": {
        "!type": "fn() -> string"
      },
      "getMobileFinalUrl": {
        "!type": "fn() -> string"
      },
      "getTrackingTemplate": {
        "!type": "fn() -> string"
      }
    },
    "AdWordsApp.AdWordsDate": {
      "day": {
        "!type": "number"
      },
      "month": {
        "!type": "number"
      },
      "year": {
        "!type": "number"
      }
    },
    "AdWordsApp.Address": {
      "getCityName": {
        "!type": "fn() -> string"
      },
      "getCountryCode": {
        "!type": "fn() -> string"
      },
      "getPostalCode": {
        "!type": "fn() -> string"
      },
      "getProvinceCode": {
        "!type": "fn() -> string"
      },
      "getProvinceName": {
        "!type": "fn() -> string"
      },
      "getStreetAddress": {
        "!type": "fn() -> string"
      },
      "getStreetAddress2": {
        "!type": "fn() -> string"
      }
    },
    "AdWordsApp.Array": {
      "concat": {
        "!type": "fn(array2: Array) -> AdWordsApp.Array"
      },
      "join": {
        "!type": "fn(separator: string) -> string"
      },
      "pop": {
        "!type": "fn() -> number"
      },
      "push": {
        "!type": "fn(element1: object) -> number"
      },
      "reverse": {
        "!type": "fn() -> AdWordsApp.Array"
      },
      "shift": {
        "!type": "fn() -> object"
      },
      "slice": {
        "!type": "fn(start: number) -> AdWordsApp.Array"
      },
      "slice ": {
        "!type": "fn(start: number, end: number) -> AdWordsApp.Array"
      },
      "sort": {
        "!type": "fn() -> AdWordsApp.Array"
      },
      "sort ": {
        "!type": "fn(sortfunc: object) -> AdWordsApp.Array"
      },
      "splice": {
        "!type": "fn(index: number, howmany: number, element1: object) -> AdWordsApp.Array"
      },
      "toString ": {
        "!type": "fn() -> string"
      },
      "unshift": {
        "!type": "fn(element1: object) -> AdWordsApp.Array"
      }
    },
    "AdWordsApp.Audience": {
      "bidding": {
        "!type": "fn() -> AdWordsApp.AudienceBidding"
      },
      "getAdGroup": {
        "!type": "fn() -> AdWordsApp.AdGroup"
      },
      "getAudienceId": {
        "!type": "fn() -> number"
      },
      "getAudienceType": {
        "!type": "fn() -> string"
      },
      "getCampaign": {
        "!type": "fn() -> AdWordsApp.Campaign"
      },
      "getId": {
        "!type": "fn() -> number"
      },
      "getStatsFor": {
        "!type": "fn(dateFrom: object, dateTo: object) -> AdWordsApp.Stats"
      },
      "getStatsFor ": {
        "!type": "fn(dateRange: string) -> AdWordsApp.Stats"
      },
      "isEnabled": {
        "!type": "fn() -> bool"
      },
      "isPaused": {
        "!type": "fn() -> bool"
      },
      "remove": {
        "!type": "fn()"
      }
    },
    "AdWordsApp.AudienceBidding": {
      "clearCpc": {
        "!type": "fn()"
      },
      "clearCpm": {
        "!type": "fn()"
      },
      "getCpc": {
        "!type": "fn() -> number"
      },
      "getCpm": {
        "!type": "fn() -> number"
      },
      "getStrategy": {
        "!type": "fn() -> AdWordsApp.BiddingStrategy"
      },
      "getStrategySource": {
        "!type": "fn() -> string"
      },
      "getStrategyType": {
        "!type": "fn() -> string"
      },
      "setCpc": {
        "!type": "fn(cpc: number)"
      },
      "setCpm": {
        "!type": "fn(cpm: number)"
      }
    },
    "AdWordsApp.AudienceBuilder": {
      "build": {
        "!type": "fn() -> AdWordsApp.AudienceOperation"
      },
      "exclude": {
        "!type": "fn() -> AdWordsApp.ExcludedAudienceOperation"
      },
      "withAudienceId": {
        "!type": "fn(audienceId: number) -> AdWordsApp.AudienceBuilder"
      },
      "withAudienceType": {
        "!type": "fn(audienceType: string) -> AdWordsApp.AudienceBuilder"
      },
      "withCpc": {
        "!type": "fn(cpc: number) -> AdWordsApp.AudienceBuilder"
      },
      "withCpm": {
        "!type": "fn(cpm: number) -> AdWordsApp.AudienceBuilder"
      }
    },
    "AdWordsApp.AudienceIterator": {
      "hasNext": {
        "!type": "fn() -> bool"
      },
      "next": {
        "!type": "fn() -> AdWordsApp.Audience"
      },
      "totalNumEntities": {
        "!type": "fn() -> number"
      }
    },
    "AdWordsApp.AudienceOperation": {
      "getErrors": {
        "!type": "fn() -> [string]"
      },
      "getResult": {
        "!type": "fn() -> AdWordsApp.Audience"
      },
      "isSuccessful": {
        "!type": "fn() -> bool"
      }
    },
    "AdWordsApp.AudienceSelector": {
      "forDateRange": {
        "!type": "fn(dateFrom: object, dateTo: object) -> AdWordsApp.AudienceSelector"
      },
      "forDateRange ": {
        "!type": "fn(dateRange: string) -> AdWordsApp.AudienceSelector"
      },
      "get": {
        "!type": "fn() -> AdWordsApp.AudienceIterator"
      },
      "orderBy": {
        "!type": "fn(orderBy: string) -> AdWordsApp.AudienceSelector"
      },
      "withCondition": {
        "!type": "fn(condition: string) -> AdWordsApp.AudienceSelector"
      },
      "withIds": {
        "!type": "fn(ids: [number]) -> AdWordsApp.AudienceSelector"
      },
      "withLimit": {
        "!type": "fn(limit: number) -> AdWordsApp.AudienceSelector"
      }
    },
    "AdWordsApp.BiddingStrategy": {
      "adGroups": {
        "!type": "fn() -> AdWordsApp.AdGroupSelector"
      },
      "campaigns": {
        "!type": "fn() -> AdWordsApp.CampaignSelector"
      },
      "getId": {
        "!type": "fn() -> number"
      },
      "getName": {
        "!type": "fn() -> string"
      },
      "getStatsFor": {
        "!type": "fn(dateFrom: object, dateTo: object) -> AdWordsApp.Stats"
      },
      "getStatsFor ": {
        "!type": "fn(dateRange: string) -> AdWordsApp.Stats"
      },
      "getType": {
        "!type": "fn() -> string"
      },
      "keywords": {
        "!type": "fn() -> AdWordsApp.KeywordSelector"
      },
      "shoppingAdGroups": {
        "!type": "fn() -> AdWordsApp.ShoppingAdGroupSelector"
      },
      "shoppingCampaigns": {
        "!type": "fn() -> AdWordsApp.ShoppingCampaignSelector"
      }
    },
    "AdWordsApp.BiddingStrategyIterator": {
      "hasNext": {
        "!type": "fn() -> bool"
      },
      "next": {
        "!type": "fn() -> AdWordsApp.BiddingStrategy"
      },
      "totalNumEntities": {
        "!type": "fn() -> number"
      }
    },
    "AdWordsApp.BiddingStrategySelector": {
      "forDateRange": {
        "!type": "fn(dateFrom: object, dateTo: object) -> AdWordsApp.BiddingStrategySelector"
      },
      "forDateRange ": {
        "!type": "fn(dateRange: string) -> AdWordsApp.BiddingStrategySelector"
      },
      "get": {
        "!type": "fn() -> AdWordsApp.BiddingStrategyIterator"
      },
      "orderBy": {
        "!type": "fn(orderBy: string) -> AdWordsApp.BiddingStrategySelector"
      },
      "withCondition": {
        "!type": "fn(condition: string) -> AdWordsApp.BiddingStrategySelector"
      },
      "withIds": {
        "!type": "fn(ids: [number]) -> AdWordsApp.BiddingStrategySelector"
      },
      "withLimit": {
        "!type": "fn(limit: number) -> AdWordsApp.BiddingStrategySelector"
      }
    },
    "AdWordsApp.Budget": {
      "campaigns": {
        "!type": "fn() -> AdWordsApp.CampaignSelector"
      },
      "getAmount": {
        "!type": "fn() -> number"
      },
      "getDeliveryMethod": {
        "!type": "fn() -> string"
      },
      "getEntityType": {
        "!type": "fn() -> string"
      },
      "getId": {
        "!type": "fn() -> number"
      },
      "getName": {
        "!type": "fn() -> string"
      },
      "getStatsFor": {
        "!type": "fn(dateFrom: object, dateTo: object) -> AdWordsApp.Stats"
      },
      "getStatsFor ": {
        "!type": "fn(dateRange: string) -> AdWordsApp.Stats"
      },
      "isExplicitlyShared": {
        "!type": "fn() -> bool"
      },
      "setAmount": {
        "!type": "fn(amount: number)"
      }
    },
    "AdWordsApp.BudgetIterator": {
      "hasNext": {
        "!type": "fn() -> bool"
      },
      "next": {
        "!type": "fn() -> AdWordsApp.Budget"
      },
      "totalNumEntities": {
        "!type": "fn() -> number"
      }
    },
    "AdWordsApp.BudgetSelector": {
      "forDateRange": {
        "!type": "fn(dateFrom: object, dateTo: object) -> AdWordsApp.BudgetSelector"
      },
      "forDateRange ": {
        "!type": "fn(dateRange: string) -> AdWordsApp.BudgetSelector"
      },
      "get": {
        "!type": "fn() -> AdWordsApp.BudgetIterator"
      },
      "orderBy": {
        "!type": "fn(orderBy: string) -> AdWordsApp.BudgetSelector"
      },
      "withCondition": {
        "!type": "fn(condition: string) -> AdWordsApp.BudgetSelector"
      },
      "withIds": {
        "!type": "fn(ids: [number]) -> AdWordsApp.BudgetSelector"
      },
      "withLimit": {
        "!type": "fn(limit: number) -> AdWordsApp.BudgetSelector"
      }
    },
    "AdWordsApp.BulkUploads": {
      "newCsvUpload": {
        "!type": "fn(columnNames: [lang.String], optArgs: object) -> AdWordsApp.CsvUpload"
      },
      "newFileUpload": {
        "!type": "fn(blob: Blob, optArgs: object) -> AdWordsApp.FileUpload"
      },
      "newFileUpload ": {
        "!type": "fn(file: File, optArgs: object) -> AdWordsApp.FileUpload"
      },
      "newFileUpload  ": {
        "!type": "fn(sheet: Sheet, optArgs: object) -> AdWordsApp.FileUpload"
      }
    },
    "AdWordsApp.Callout": {
      "getEndDate": {
        "!type": "fn() -> AdWordsApp.AdWordsDate"
      },
      "getEntityType": {
        "!type": "fn() -> string"
      },
      "getId": {
        "!type": "fn() -> number"
      },
      "getSchedules": {
        "!type": "fn() -> [AdWordsApp.ExtensionSchedule]"
      },
      "getStartDate": {
        "!type": "fn() -> AdWordsApp.AdWordsDate"
      },
      "getStatsFor": {
        "!type": "fn(dateFrom: object, dateTo: object) -> AdWordsApp.Stats"
      },
      "getStatsFor ": {
        "!type": "fn(dateRange: string) -> AdWordsApp.Stats"
      },
      "getText": {
        "!type": "fn() -> string"
      },
      "isMobilePreferred": {
        "!type": "fn() -> bool"
      },
      "setEndDate": {
        "!type": "fn(date: object)"
      },
      "setMobilePreferred": {
        "!type": "fn(isMobilePreferred: bool)"
      },
      "setSchedules": {
        "!type": "fn(schedules: [AdWordsApp.ExtensionSchedule])"
      },
      "setStartDate": {
        "!type": "fn(date: object)"
      },
      "setText": {
        "!type": "fn(text: string)"
      }
    },
    "AdWordsApp.CalloutBuilder": {
      "build": {
        "!type": "fn() -> AdWordsApp.CalloutOperation"
      },
      "withEndDate": {
        "!type": "fn(date: object) -> AdWordsApp.CalloutBuilder"
      },
      "withMobilePreferred": {
        "!type": "fn(isMobilePreferred: bool) -> AdWordsApp.CalloutBuilder"
      },
      "withSchedules": {
        "!type": "fn(schedules: [AdWordsApp.ExtensionSchedule]) -> AdWordsApp.CalloutBuilder"
      },
      "withStartDate": {
        "!type": "fn(date: object) -> AdWordsApp.CalloutBuilder"
      },
      "withText": {
        "!type": "fn(text: string) -> AdWordsApp.CalloutBuilder"
      }
    },
    "AdWordsApp.CalloutIterator": {
      "hasNext": {
        "!type": "fn() -> bool"
      },
      "next": {
        "!type": "fn() -> AdWordsApp.Callout"
      },
      "totalNumEntities": {
        "!type": "fn() -> number"
      }
    },
    "AdWordsApp.CalloutOperation": {
      "getErrors": {
        "!type": "fn() -> [string]"
      },
      "getResult": {
        "!type": "fn() -> AdWordsApp.Callout"
      },
      "isSuccessful": {
        "!type": "fn() -> bool"
      }
    },
    "AdWordsApp.CalloutSelector": {
      "forDateRange": {
        "!type": "fn(dateFrom: object, dateTo: object) -> AdWordsApp.CalloutSelector"
      },
      "forDateRange ": {
        "!type": "fn(dateRange: string) -> AdWordsApp.CalloutSelector"
      },
      "get": {
        "!type": "fn() -> AdWordsApp.CalloutIterator"
      },
      "orderBy": {
        "!type": "fn(orderBy: string) -> AdWordsApp.CalloutSelector"
      },
      "withCondition": {
        "!type": "fn(condition: string) -> AdWordsApp.CalloutSelector"
      },
      "withIds": {
        "!type": "fn(ids: [number]) -> AdWordsApp.CalloutSelector"
      },
      "withLimit": {
        "!type": "fn(limit: number) -> AdWordsApp.CalloutSelector"
      }
    },
    "AdWordsApp.Campaign": {
      "adGroups": {
        "!type": "fn() -> AdWordsApp.AdGroupSelector"
      },
      "addAdSchedule": {
        "!type": "fn(adSchedule: object)"
      },
      "addAdSchedule ": {
        "!type": "fn(dayOfWeek: string, startHour: number, startMinute: number, endHour: number, endMinute: number, bidModifier: number)"
      },
      "addCallout": {
        "!type": "fn(calloutExtension: Callout) -> AdWordsApp.CalloutOperation"
      },
      "addExcludedPlacementList": {
        "!type": "fn(excludedPlacementList: ExcludedPlacementList)"
      },
      "addLocation": {
        "!type": "fn(locationId: number, bidModifier: number)"
      },
      "addLocation ": {
        "!type": "fn(location: object)"
      },
      "addMobileApp": {
        "!type": "fn(mobileAppExtension: MobileApp) -> AdWordsApp.MobileAppOperation"
      },
      "addNegativeKeywordList": {
        "!type": "fn(negativeKeywordList: NegativeKeywordList)"
      },
      "addPhoneNumber": {
        "!type": "fn(phoneNumberExtension: PhoneNumber) -> AdWordsApp.PhoneNumberOperation"
      },
      "addProximity": {
        "!type": "fn(latitude: number, longitude: number, radius: number, radiusUnits: string, optArgs: object)"
      },
      "addProximity ": {
        "!type": "fn(proximity: object)"
      },
      "addReview": {
        "!type": "fn(reviewExtension: Review) -> AdWordsApp.ReviewOperation"
      },
      "addSitelink": {
        "!type": "fn(sitelinkExtension: Sitelink) -> AdWordsApp.SitelinkOperation"
      },
      "ads": {
        "!type": "fn() -> AdWordsApp.AdSelector"
      },
      "applyLabel": {
        "!type": "fn(name: string)"
      },
      "bidding": {
        "!type": "fn() -> AdWordsApp.CampaignBidding"
      },
      "createNegativeKeyword": {
        "!type": "fn(keywordText: string)"
      },
      "display": {
        "!type": "fn() -> AdWordsApp.CampaignDisplay"
      },
      "enable": {
        "!type": "fn()"
      },
      "excludeLocation": {
        "!type": "fn(locationOrId: object)"
      },
      "excludedPlacementLists": {
        "!type": "fn() -> AdWordsApp.ExcludedPlacementListSelector"
      },
      "extensions": {
        "!type": "fn() -> AdWordsApp.CampaignExtensions"
      },
      "getAdRotationType": {
        "!type": "fn() -> string"
      },
      "getBiddingStrategyType": {
        "!type": "fn() -> string"
      },
      "getBudget": {
        "!type": "fn() -> AdWordsApp.Budget"
      },
      "getEndDate": {
        "!type": "fn() -> AdWordsApp.AdWordsDate"
      },
      "getEntityType": {
        "!type": "fn() -> string"
      },
      "getId": {
        "!type": "fn() -> number"
      },
      "getName": {
        "!type": "fn() -> string"
      },
      "getStartDate": {
        "!type": "fn() -> AdWordsApp.AdWordsDate"
      },
      "getStatsFor": {
        "!type": "fn(dateFrom: object, dateTo: object) -> AdWordsApp.Stats"
      },
      "getStatsFor ": {
        "!type": "fn(dateRange: string) -> AdWordsApp.Stats"
      },
      "isEnabled": {
        "!type": "fn() -> bool"
      },
      "isPaused": {
        "!type": "fn() -> bool"
      },
      "isRemoved": {
        "!type": "fn() -> bool"
      },
      "keywords": {
        "!type": "fn() -> AdWordsApp.KeywordSelector"
      },
      "labels": {
        "!type": "fn() -> AdWordsApp.LabelSelector"
      },
      "negativeKeywordLists": {
        "!type": "fn() -> AdWordsApp.NegativeKeywordListSelector"
      },
      "negativeKeywords": {
        "!type": "fn() -> AdWordsApp.NegativeKeywordSelector"
      },
      "newAdGroupBuilder": {
        "!type": "fn() -> AdWordsApp.AdGroupBuilder"
      },
      "pause": {
        "!type": "fn()"
      },
      "removeCallout": {
        "!type": "fn(calloutExtension: Callout)"
      },
      "removeExcludedPlacementList": {
        "!type": "fn(excludedPlacementList: ExcludedPlacementList)"
      },
      "removeLabel": {
        "!type": "fn(name: string)"
      },
      "removeMobileApp": {
        "!type": "fn(mobileAppExtension: MobileApp)"
      },
      "removeNegativeKeywordList": {
        "!type": "fn(negativeKeywordList: NegativeKeywordList)"
      },
      "removePhoneNumber": {
        "!type": "fn(phoneNumberExtension: PhoneNumber)"
      },
      "removeReview": {
        "!type": "fn(reviewExtension: Review)"
      },
      "removeSitelink": {
        "!type": "fn(sitelinkExtension: Sitelink)"
      },
      "setAdRotationType": {
        "!type": "fn(adRotationType: string)"
      },
      "setEndDate": {
        "!type": "fn(date: object)"
      },
      "setName": {
        "!type": "fn(name: string)"
      },
      "setStartDate": {
        "!type": "fn(date: object)"
      },
      "targeting": {
        "!type": "fn() -> AdWordsApp.Targeting"
      },
      "urls": {
        "!type": "fn() -> AdWordsApp.CampaignUrls"
      }
    },
    "AdWordsApp.CampaignBidding": {
      "getStrategy": {
        "!type": "fn() -> AdWordsApp.BiddingStrategy"
      },
      "getStrategySource": {
        "!type": "fn() -> string"
      },
      "getStrategyType": {
        "!type": "fn() -> string"
      },
      "setStrategy": {
        "!type": "fn(biddingStrategy: BiddingStrategy)"
      },
      "setStrategy ": {
        "!type": "fn(biddingStrategy: string)"
      }
    },
    "AdWordsApp.CampaignCallout": {
      "getCampaign": {
        "!type": "fn() -> AdWordsApp.Campaign"
      },
      "getEndDate": {
        "!type": "fn() -> AdWordsApp.AdWordsDate"
      },
      "getEntityType": {
        "!type": "fn() -> string"
      },
      "getId": {
        "!type": "fn() -> number"
      },
      "getSchedules": {
        "!type": "fn() -> [AdWordsApp.ExtensionSchedule]"
      },
      "getStartDate": {
        "!type": "fn() -> AdWordsApp.AdWordsDate"
      },
      "getStatsFor": {
        "!type": "fn(dateFrom: object, dateTo: object) -> AdWordsApp.Stats"
      },
      "getStatsFor ": {
        "!type": "fn(dateRange: string) -> AdWordsApp.Stats"
      },
      "getText": {
        "!type": "fn() -> string"
      },
      "isMobilePreferred": {
        "!type": "fn() -> bool"
      },
      "setEndDate": {
        "!type": "fn(date: object)"
      },
      "setMobilePreferred": {
        "!type": "fn(isMobilePreferred: bool)"
      },
      "setSchedules": {
        "!type": "fn(schedules: [AdWordsApp.ExtensionSchedule])"
      },
      "setStartDate": {
        "!type": "fn(date: object)"
      },
      "setText": {
        "!type": "fn(text: string)"
      }
    },
    "AdWordsApp.CampaignCalloutIterator": {
      "hasNext": {
        "!type": "fn() -> bool"
      },
      "next": {
        "!type": "fn() -> AdWordsApp.CampaignCallout"
      },
      "totalNumEntities": {
        "!type": "fn() -> number"
      }
    },
    "AdWordsApp.CampaignCalloutSelector": {
      "forDateRange": {
        "!type": "fn(dateFrom: object, dateTo: object) -> AdWordsApp.CampaignCalloutSelector"
      },
      "forDateRange ": {
        "!type": "fn(dateRange: string) -> AdWordsApp.CampaignCalloutSelector"
      },
      "get": {
        "!type": "fn() -> AdWordsApp.CampaignCalloutIterator"
      },
      "orderBy": {
        "!type": "fn(orderBy: string) -> AdWordsApp.CampaignCalloutSelector"
      },
      "withCondition": {
        "!type": "fn(condition: string) -> AdWordsApp.CampaignCalloutSelector"
      },
      "withIds": {
        "!type": "fn(ids: [number]) -> AdWordsApp.CampaignCalloutSelector"
      },
      "withLimit": {
        "!type": "fn(limit: number) -> AdWordsApp.CampaignCalloutSelector"
      }
    },
    "AdWordsApp.CampaignDisplay": {
      "audiences": {
        "!type": "fn() -> AdWordsApp.AudienceSelector"
      },
      "excludedAudiences": {
        "!type": "fn() -> AdWordsApp.ExcludedAudienceSelector"
      },
      "excludedKeywords": {
        "!type": "fn() -> AdWordsApp.ExcludedDisplayKeywordSelector"
      },
      "excludedPlacements": {
        "!type": "fn() -> AdWordsApp.ExcludedPlacementSelector"
      },
      "excludedTopics": {
        "!type": "fn() -> AdWordsApp.ExcludedTopicSelector"
      },
      "keywords": {
        "!type": "fn() -> AdWordsApp.DisplayKeywordSelector"
      },
      "newAudienceBuilder": {
        "!type": "fn() -> AdWordsApp.AudienceBuilder"
      },
      "newKeywordBuilder": {
        "!type": "fn() -> AdWordsApp.DisplayKeywordBuilder"
      },
      "newPlacementBuilder": {
        "!type": "fn() -> AdWordsApp.PlacementBuilder"
      },
      "newTopicBuilder": {
        "!type": "fn() -> AdWordsApp.TopicBuilder"
      },
      "placements": {
        "!type": "fn() -> AdWordsApp.PlacementSelector"
      },
      "topics": {
        "!type": "fn() -> AdWordsApp.TopicSelector"
      }
    },
    "AdWordsApp.CampaignExtensions": {
      "callouts": {
        "!type": "fn() -> AdWordsApp.CampaignCalloutSelector"
      },
      "mobileApps": {
        "!type": "fn() -> AdWordsApp.CampaignMobileAppSelector"
      },
      "phoneNumbers": {
        "!type": "fn() -> AdWordsApp.CampaignPhoneNumberSelector"
      },
      "reviews": {
        "!type": "fn() -> AdWordsApp.CampaignReviewSelector"
      },
      "sitelinks": {
        "!type": "fn() -> AdWordsApp.CampaignSitelinkSelector"
      }
    },
    "AdWordsApp.CampaignIterator": {
      "hasNext": {
        "!type": "fn() -> bool"
      },
      "next": {
        "!type": "fn() -> AdWordsApp.Campaign"
      },
      "totalNumEntities": {
        "!type": "fn() -> number"
      }
    },
    "AdWordsApp.CampaignMobileApp": {
      "clearLinkUrl": {
        "!type": "fn()"
      },
      "getAppId": {
        "!type": "fn() -> string"
      },
      "getCampaign": {
        "!type": "fn() -> AdWordsApp.Campaign"
      },
      "getEndDate": {
        "!type": "fn() -> AdWordsApp.AdWordsDate"
      },
      "getEntityType": {
        "!type": "fn() -> string"
      },
      "getId": {
        "!type": "fn() -> number"
      },
      "getLinkText": {
        "!type": "fn() -> string"
      },
      "getLinkUrl": {
        "!type": "fn() -> string"
      },
      "getSchedules": {
        "!type": "fn() -> [AdWordsApp.ExtensionSchedule]"
      },
      "getStartDate": {
        "!type": "fn() -> AdWordsApp.AdWordsDate"
      },
      "getStatsFor": {
        "!type": "fn(dateFrom: object, dateTo: object) -> AdWordsApp.Stats"
      },
      "getStatsFor ": {
        "!type": "fn(dateRange: string) -> AdWordsApp.Stats"
      },
      "getStore": {
        "!type": "fn() -> string"
      },
      "isMobilePreferred": {
        "!type": "fn() -> bool"
      },
      "setAppId": {
        "!type": "fn(appId: string)"
      },
      "setEndDate": {
        "!type": "fn(date: object)"
      },
      "setLinkText": {
        "!type": "fn(linkText: string)"
      },
      "setLinkUrl": {
        "!type": "fn(linkUrl: string)"
      },
      "setMobilePreferred": {
        "!type": "fn(isMobilePreferred: bool)"
      },
      "setSchedules": {
        "!type": "fn(schedules: [AdWordsApp.ExtensionSchedule])"
      },
      "setStartDate": {
        "!type": "fn(date: object)"
      },
      "setStore": {
        "!type": "fn(store: string)"
      },
      "urls": {
        "!type": "fn() -> AdWordsApp.MobileAppUrls"
      }
    },
    "AdWordsApp.CampaignMobileAppIterator": {
      "hasNext": {
        "!type": "fn() -> bool"
      },
      "next": {
        "!type": "fn() -> AdWordsApp.CampaignMobileApp"
      },
      "totalNumEntities": {
        "!type": "fn() -> number"
      }
    },
    "AdWordsApp.CampaignMobileAppSelector": {
      "forDateRange": {
        "!type": "fn(dateFrom: object, dateTo: object) -> AdWordsApp.CampaignMobileAppSelector"
      },
      "forDateRange ": {
        "!type": "fn(dateRange: string) -> AdWordsApp.CampaignMobileAppSelector"
      },
      "get": {
        "!type": "fn() -> AdWordsApp.CampaignMobileAppIterator"
      },
      "orderBy": {
        "!type": "fn(orderBy: string) -> AdWordsApp.CampaignMobileAppSelector"
      },
      "withCondition": {
        "!type": "fn(condition: string) -> AdWordsApp.CampaignMobileAppSelector"
      },
      "withIds": {
        "!type": "fn(ids: [number]) -> AdWordsApp.CampaignMobileAppSelector"
      },
      "withLimit": {
        "!type": "fn(limit: number) -> AdWordsApp.CampaignMobileAppSelector"
      }
    },
    "AdWordsApp.CampaignPhoneNumber": {
      "getCampaign": {
        "!type": "fn() -> AdWordsApp.Campaign"
      },
      "getCountry": {
        "!type": "fn() -> string"
      },
      "getEndDate": {
        "!type": "fn() -> AdWordsApp.AdWordsDate"
      },
      "getEntityType": {
        "!type": "fn() -> string"
      },
      "getId": {
        "!type": "fn() -> number"
      },
      "getPhoneNumber": {
        "!type": "fn() -> string"
      },
      "getSchedules": {
        "!type": "fn() -> [AdWordsApp.ExtensionSchedule]"
      },
      "getStartDate": {
        "!type": "fn() -> AdWordsApp.AdWordsDate"
      },
      "getStatsFor": {
        "!type": "fn(dateFrom: object, dateTo: object) -> AdWordsApp.Stats"
      },
      "getStatsFor ": {
        "!type": "fn(dateRange: string) -> AdWordsApp.Stats"
      },
      "isCallOnly": {
        "!type": "fn() -> bool"
      },
      "isMobilePreferred": {
        "!type": "fn() -> bool"
      },
      "setCallOnly": {
        "!type": "fn(callOnly: bool)"
      },
      "setCountry": {
        "!type": "fn(country: string)"
      },
      "setEndDate": {
        "!type": "fn(date: object)"
      },
      "setMobilePreferred": {
        "!type": "fn(isMobilePreferred: bool)"
      },
      "setPhoneNumber": {
        "!type": "fn(phoneNumber: string)"
      },
      "setSchedules": {
        "!type": "fn(schedules: [AdWordsApp.ExtensionSchedule])"
      },
      "setStartDate": {
        "!type": "fn(date: object)"
      }
    },
    "AdWordsApp.CampaignPhoneNumberIterator": {
      "hasNext": {
        "!type": "fn() -> bool"
      },
      "next": {
        "!type": "fn() -> AdWordsApp.CampaignPhoneNumber"
      },
      "totalNumEntities": {
        "!type": "fn() -> number"
      }
    },
    "AdWordsApp.CampaignPhoneNumberSelector": {
      "forDateRange": {
        "!type": "fn(dateFrom: object, dateTo: object) -> AdWordsApp.CampaignPhoneNumberSelector"
      },
      "forDateRange ": {
        "!type": "fn(dateRange: string) -> AdWordsApp.CampaignPhoneNumberSelector"
      },
      "get": {
        "!type": "fn() -> AdWordsApp.CampaignPhoneNumberIterator"
      },
      "orderBy": {
        "!type": "fn(orderBy: string) -> AdWordsApp.CampaignPhoneNumberSelector"
      },
      "withCondition": {
        "!type": "fn(condition: string) -> AdWordsApp.CampaignPhoneNumberSelector"
      },
      "withIds": {
        "!type": "fn(ids: [number]) -> AdWordsApp.CampaignPhoneNumberSelector"
      },
      "withLimit": {
        "!type": "fn(limit: number) -> AdWordsApp.CampaignPhoneNumberSelector"
      }
    },
    "AdWordsApp.CampaignReview": {
      "getCampaign": {
        "!type": "fn() -> AdWordsApp.Campaign"
      },
      "getEndDate": {
        "!type": "fn() -> AdWordsApp.AdWordsDate"
      },
      "getEntityType": {
        "!type": "fn() -> string"
      },
      "getId": {
        "!type": "fn() -> number"
      },
      "getSchedules": {
        "!type": "fn() -> [AdWordsApp.ExtensionSchedule]"
      },
      "getSourceName": {
        "!type": "fn() -> string"
      },
      "getSourceUrl": {
        "!type": "fn() -> string"
      },
      "getStartDate": {
        "!type": "fn() -> AdWordsApp.AdWordsDate"
      },
      "getStatsFor": {
        "!type": "fn(dateFrom: object, dateTo: object) -> AdWordsApp.Stats"
      },
      "getStatsFor ": {
        "!type": "fn(dateRange: string) -> AdWordsApp.Stats"
      },
      "getText": {
        "!type": "fn() -> string"
      },
      "isExactlyQuoted": {
        "!type": "fn() -> bool"
      },
      "isMobilePreferred": {
        "!type": "fn() -> bool"
      },
      "setEndDate": {
        "!type": "fn(date: object)"
      },
      "setExactlyQuoted": {
        "!type": "fn(isExactlyQuoted: bool)"
      },
      "setMobilePreferred": {
        "!type": "fn(isMobilePreferred: bool)"
      },
      "setSchedules": {
        "!type": "fn(schedules: [AdWordsApp.ExtensionSchedule])"
      },
      "setSourceName": {
        "!type": "fn(sourceName: string)"
      },
      "setSourceUrl": {
        "!type": "fn(sourceUrl: string)"
      },
      "setStartDate": {
        "!type": "fn(date: object)"
      },
      "setText": {
        "!type": "fn(text: string)"
      }
    },
    "AdWordsApp.CampaignReviewIterator": {
      "hasNext": {
        "!type": "fn() -> bool"
      },
      "next": {
        "!type": "fn() -> AdWordsApp.CampaignReview"
      },
      "totalNumEntities": {
        "!type": "fn() -> number"
      }
    },
    "AdWordsApp.CampaignReviewSelector": {
      "forDateRange": {
        "!type": "fn(dateFrom: object, dateTo: object) -> AdWordsApp.CampaignReviewSelector"
      },
      "forDateRange ": {
        "!type": "fn(dateRange: string) -> AdWordsApp.CampaignReviewSelector"
      },
      "get": {
        "!type": "fn() -> AdWordsApp.CampaignReviewIterator"
      },
      "orderBy": {
        "!type": "fn(orderBy: string) -> AdWordsApp.CampaignReviewSelector"
      },
      "withCondition": {
        "!type": "fn(condition: string) -> AdWordsApp.CampaignReviewSelector"
      },
      "withIds": {
        "!type": "fn(ids: [number]) -> AdWordsApp.CampaignReviewSelector"
      },
      "withLimit": {
        "!type": "fn(limit: number) -> AdWordsApp.CampaignReviewSelector"
      }
    },
    "AdWordsApp.CampaignSelector": {
      "forDateRange": {
        "!type": "fn(dateFrom: object, dateTo: object) -> AdWordsApp.CampaignSelector"
      },
      "forDateRange ": {
        "!type": "fn(dateRange: string) -> AdWordsApp.CampaignSelector"
      },
      "get": {
        "!type": "fn() -> AdWordsApp.CampaignIterator"
      },
      "orderBy": {
        "!type": "fn(orderBy: string) -> AdWordsApp.CampaignSelector"
      },
      "withCondition": {
        "!type": "fn(condition: string) -> AdWordsApp.CampaignSelector"
      },
      "withIds": {
        "!type": "fn(ids: [number]) -> AdWordsApp.CampaignSelector"
      },
      "withLimit": {
        "!type": "fn(limit: number) -> AdWordsApp.CampaignSelector"
      }
    },
    "AdWordsApp.CampaignSitelink": {
      "clearDescription1": {
        "!type": "fn()"
      },
      "clearDescription2": {
        "!type": "fn()"
      },
      "clearLinkUrl": {
        "!type": "fn()"
      },
      "getCampaign": {
        "!type": "fn() -> AdWordsApp.Campaign"
      },
      "getDescription1": {
        "!type": "fn() -> string"
      },
      "getDescription2": {
        "!type": "fn() -> string"
      },
      "getEndDate": {
        "!type": "fn() -> AdWordsApp.AdWordsDate"
      },
      "getEntityType": {
        "!type": "fn() -> string"
      },
      "getId": {
        "!type": "fn() -> number"
      },
      "getLinkText": {
        "!type": "fn() -> string"
      },
      "getLinkUrl": {
        "!type": "fn() -> string"
      },
      "getSchedules": {
        "!type": "fn() -> [AdWordsApp.ExtensionSchedule]"
      },
      "getStartDate": {
        "!type": "fn() -> AdWordsApp.AdWordsDate"
      },
      "getStatsFor": {
        "!type": "fn(dateFrom: object, dateTo: object) -> AdWordsApp.Stats"
      },
      "getStatsFor ": {
        "!type": "fn(dateRange: string) -> AdWordsApp.Stats"
      },
      "isMobilePreferred": {
        "!type": "fn() -> bool"
      },
      "setDescription1": {
        "!type": "fn(description1: string)"
      },
      "setDescription2": {
        "!type": "fn(description2: string)"
      },
      "setEndDate": {
        "!type": "fn(date: object)"
      },
      "setLinkText": {
        "!type": "fn(linkText: string)"
      },
      "setLinkUrl": {
        "!type": "fn(linkUrl: string)"
      },
      "setMobilePreferred": {
        "!type": "fn(isMobilePreferred: bool)"
      },
      "setSchedules": {
        "!type": "fn(schedules: [AdWordsApp.ExtensionSchedule])"
      },
      "setStartDate": {
        "!type": "fn(date: object)"
      },
      "urls": {
        "!type": "fn() -> AdWordsApp.SitelinkUrls"
      }
    },
    "AdWordsApp.CampaignSitelinkIterator": {
      "hasNext": {
        "!type": "fn() -> bool"
      },
      "next": {
        "!type": "fn() -> AdWordsApp.CampaignSitelink"
      },
      "totalNumEntities": {
        "!type": "fn() -> number"
      }
    },
    "AdWordsApp.CampaignSitelinkSelector": {
      "forDateRange": {
        "!type": "fn(dateFrom: object, dateTo: object) -> AdWordsApp.CampaignSitelinkSelector"
      },
      "forDateRange ": {
        "!type": "fn(dateRange: string) -> AdWordsApp.CampaignSitelinkSelector"
      },
      "get": {
        "!type": "fn() -> AdWordsApp.CampaignSitelinkIterator"
      },
      "orderBy": {
        "!type": "fn(orderBy: string) -> AdWordsApp.CampaignSitelinkSelector"
      },
      "withCondition": {
        "!type": "fn(condition: string) -> AdWordsApp.CampaignSitelinkSelector"
      },
      "withIds": {
        "!type": "fn(ids: [number]) -> AdWordsApp.CampaignSitelinkSelector"
      },
      "withLimit": {
        "!type": "fn(limit: number) -> AdWordsApp.CampaignSitelinkSelector"
      }
    },
    "AdWordsApp.CampaignUrls": {
      "clearTrackingTemplate": {
        "!type": "fn()"
      },
      "getCustomParameters": {
        "!type": "fn() -> object"
      },
      "getTrackingTemplate": {
        "!type": "fn() -> string"
      },
      "setCustomParameters": {
        "!type": "fn(customParameters: object)"
      },
      "setTrackingTemplate": {
        "!type": "fn(trackingTemplate: string)"
      }
    },
    "AdWordsApp.CsvUpload": {
      "append": {
        "!type": "fn(row: object) -> AdWordsApp.CsvUpload"
      },
      "apply": {
        "!type": "fn()"
      },
      "forCampaignManagement": {
        "!type": "fn() -> AdWordsApp.CsvUpload"
      },
      "forOfflineConversions": {
        "!type": "fn() -> AdWordsApp.CsvUpload"
      },
      "preview": {
        "!type": "fn()"
      },
      "setFileName": {
        "!type": "fn(fileName: string) -> AdWordsApp.CsvUpload"
      }
    },
    "AdWordsApp.Display": {
      "audiences": {
        "!type": "fn() -> AdWordsApp.AudienceSelector"
      },
      "keywords": {
        "!type": "fn() -> AdWordsApp.DisplayKeywordSelector"
      },
      "placements": {
        "!type": "fn() -> AdWordsApp.PlacementSelector"
      },
      "topics": {
        "!type": "fn() -> AdWordsApp.TopicSelector"
      }
    },
    "AdWordsApp.DisplayKeyword": {
      "bidding": {
        "!type": "fn() -> AdWordsApp.DisplayKeywordBidding"
      },
      "getAdGroup": {
        "!type": "fn() -> AdWordsApp.AdGroup"
      },
      "getCampaign": {
        "!type": "fn() -> AdWordsApp.Campaign"
      },
      "getId": {
        "!type": "fn() -> number"
      },
      "getStatsFor": {
        "!type": "fn(dateFrom: object, dateTo: object) -> AdWordsApp.Stats"
      },
      "getStatsFor ": {
        "!type": "fn(dateRange: string) -> AdWordsApp.Stats"
      },
      "getText": {
        "!type": "fn() -> string"
      },
      "isEnabled": {
        "!type": "fn() -> bool"
      },
      "isPaused": {
        "!type": "fn() -> bool"
      },
      "remove": {
        "!type": "fn()"
      }
    },
    "AdWordsApp.DisplayKeywordBidding": {
      "clearCpc": {
        "!type": "fn()"
      },
      "clearCpm": {
        "!type": "fn()"
      },
      "clearStrategy": {
        "!type": "fn()"
      },
      "getCpc": {
        "!type": "fn() -> number"
      },
      "getCpm": {
        "!type": "fn() -> number"
      },
      "getStrategy": {
        "!type": "fn() -> AdWordsApp.BiddingStrategy"
      },
      "getStrategySource": {
        "!type": "fn() -> string"
      },
      "getStrategyType": {
        "!type": "fn() -> string"
      },
      "setCpc": {
        "!type": "fn(cpc: number)"
      },
      "setCpm": {
        "!type": "fn(cpm: number)"
      },
      "setStrategy": {
        "!type": "fn(biddingStrategy: BiddingStrategy)"
      },
      "setStrategy ": {
        "!type": "fn(biddingStrategy: string)"
      }
    },
    "AdWordsApp.DisplayKeywordBuilder": {
      "build": {
        "!type": "fn() -> AdWordsApp.DisplayKeywordOperation"
      },
      "exclude": {
        "!type": "fn() -> AdWordsApp.ExcludedDisplayKeywordOperation"
      },
      "withCpc": {
        "!type": "fn(cpc: number) -> AdWordsApp.DisplayKeywordBuilder"
      },
      "withCpm": {
        "!type": "fn(cpm: number) -> AdWordsApp.DisplayKeywordBuilder"
      },
      "withText": {
        "!type": "fn(text: string) -> AdWordsApp.DisplayKeywordBuilder"
      }
    },
    "AdWordsApp.DisplayKeywordIterator": {
      "hasNext": {
        "!type": "fn() -> bool"
      },
      "next": {
        "!type": "fn() -> AdWordsApp.DisplayKeyword"
      },
      "totalNumEntities": {
        "!type": "fn() -> number"
      }
    },
    "AdWordsApp.DisplayKeywordOperation": {
      "getErrors": {
        "!type": "fn() -> [string]"
      },
      "getResult": {
        "!type": "fn() -> AdWordsApp.DisplayKeyword"
      },
      "isSuccessful": {
        "!type": "fn() -> bool"
      }
    },
    "AdWordsApp.DisplayKeywordSelector": {
      "forDateRange": {
        "!type": "fn(dateFrom: object, dateTo: object) -> AdWordsApp.DisplayKeywordSelector"
      },
      "forDateRange ": {
        "!type": "fn(dateRange: string) -> AdWordsApp.DisplayKeywordSelector"
      },
      "get": {
        "!type": "fn() -> AdWordsApp.DisplayKeywordIterator"
      },
      "orderBy": {
        "!type": "fn(orderBy: string) -> AdWordsApp.DisplayKeywordSelector"
      },
      "withCondition": {
        "!type": "fn(condition: string) -> AdWordsApp.DisplayKeywordSelector"
      },
      "withIds": {
        "!type": "fn(ids: [number]) -> AdWordsApp.DisplayKeywordSelector"
      },
      "withLimit": {
        "!type": "fn(limit: number) -> AdWordsApp.DisplayKeywordSelector"
      }
    },
    "AdWordsApp.ExcludedAudience": {
      "getAdGroup": {
        "!type": "fn() -> AdWordsApp.AdGroup"
      },
      "getAudienceId": {
        "!type": "fn() -> number"
      },
      "getAudienceType": {
        "!type": "fn() -> string"
      },
      "getCampaign": {
        "!type": "fn() -> AdWordsApp.Campaign"
      },
      "getId": {
        "!type": "fn() -> number"
      },
      "remove": {
        "!type": "fn()"
      }
    },
    "AdWordsApp.ExcludedAudienceIterator": {
      "hasNext": {
        "!type": "fn() -> bool"
      },
      "next": {
        "!type": "fn() -> AdWordsApp.ExcludedAudience"
      },
      "totalNumEntities": {
        "!type": "fn() -> number"
      }
    },
    "AdWordsApp.ExcludedAudienceOperation": {
      "getErrors": {
        "!type": "fn() -> [string]"
      },
      "getResult": {
        "!type": "fn() -> AdWordsApp.ExcludedAudience"
      },
      "isSuccessful": {
        "!type": "fn() -> bool"
      }
    },
    "AdWordsApp.ExcludedAudienceSelector": {
      "get": {
        "!type": "fn() -> AdWordsApp.ExcludedAudienceIterator"
      },
      "orderBy": {
        "!type": "fn(orderBy: string) -> AdWordsApp.ExcludedAudienceSelector"
      },
      "withCondition": {
        "!type": "fn(condition: string) -> AdWordsApp.ExcludedAudienceSelector"
      },
      "withLimit": {
        "!type": "fn(limit: number) -> AdWordsApp.ExcludedAudienceSelector"
      }
    },
    "AdWordsApp.ExcludedDisplayKeyword": {
      "getAdGroup": {
        "!type": "fn() -> AdWordsApp.AdGroup"
      },
      "getCampaign": {
        "!type": "fn() -> AdWordsApp.Campaign"
      },
      "getId": {
        "!type": "fn() -> number"
      },
      "getText": {
        "!type": "fn() -> string"
      },
      "remove": {
        "!type": "fn()"
      }
    },
    "AdWordsApp.ExcludedDisplayKeywordIterator": {
      "hasNext": {
        "!type": "fn() -> bool"
      },
      "next": {
        "!type": "fn() -> AdWordsApp.ExcludedDisplayKeyword"
      },
      "totalNumEntities": {
        "!type": "fn() -> number"
      }
    },
    "AdWordsApp.ExcludedDisplayKeywordOperation": {
      "getErrors": {
        "!type": "fn() -> [string]"
      },
      "getResult": {
        "!type": "fn() -> AdWordsApp.ExcludedDisplayKeyword"
      },
      "isSuccessful": {
        "!type": "fn() -> bool"
      }
    },
    "AdWordsApp.ExcludedDisplayKeywordSelector": {
      "get": {
        "!type": "fn() -> AdWordsApp.ExcludedDisplayKeywordIterator"
      },
      "orderBy": {
        "!type": "fn(orderBy: string) -> AdWordsApp.ExcludedDisplayKeywordSelector"
      },
      "withCondition": {
        "!type": "fn(condition: string) -> AdWordsApp.ExcludedDisplayKeywordSelector"
      },
      "withLimit": {
        "!type": "fn(limit: number) -> AdWordsApp.ExcludedDisplayKeywordSelector"
      }
    },
    "AdWordsApp.ExcludedLocation": {
      "getCampaign": {
        "!type": "fn() -> AdWordsApp.Campaign"
      },
      "getCountryCode": {
        "!type": "fn() -> string"
      },
      "getEntityType": {
        "!type": "fn() -> string"
      },
      "getId": {
        "!type": "fn() -> number"
      },
      "getName": {
        "!type": "fn() -> string"
      },
      "getTargetType": {
        "!type": "fn() -> string"
      },
      "getTargetingStatus": {
        "!type": "fn() -> string"
      },
      "remove": {
        "!type": "fn()"
      }
    },
    "AdWordsApp.ExcludedLocationIterator": {
      "hasNext": {
        "!type": "fn() -> bool"
      },
      "next": {
        "!type": "fn() -> AdWordsApp.ExcludedLocation"
      },
      "totalNumEntities": {
        "!type": "fn() -> number"
      }
    },
    "AdWordsApp.ExcludedLocationSelector": {
      "get": {
        "!type": "fn() -> AdWordsApp.ExcludedLocationIterator"
      },
      "withLimit": {
        "!type": "fn(limit: number) -> AdWordsApp.ExcludedLocationSelector"
      }
    },
    "AdWordsApp.ExcludedPlacement": {
      "getAdGroup": {
        "!type": "fn() -> AdWordsApp.AdGroup"
      },
      "getCampaign": {
        "!type": "fn() -> AdWordsApp.Campaign"
      },
      "getId": {
        "!type": "fn() -> number"
      },
      "getUrl": {
        "!type": "fn() -> string"
      },
      "remove": {
        "!type": "fn()"
      }
    },
    "AdWordsApp.ExcludedPlacementIterator": {
      "hasNext": {
        "!type": "fn() -> bool"
      },
      "next": {
        "!type": "fn() -> AdWordsApp.ExcludedPlacement"
      },
      "totalNumEntities": {
        "!type": "fn() -> number"
      }
    },
    "AdWordsApp.ExcludedPlacementList": {
      "addExcludedPlacement": {
        "!type": "fn(url: string)"
      },
      "addExcludedPlacements": {
        "!type": "fn(urls: [lang.String])"
      },
      "campaigns": {
        "!type": "fn() -> AdWordsApp.CampaignSelector"
      },
      "excludedPlacements": {
        "!type": "fn() -> AdWordsApp.SharedExcludedPlacementSelector"
      },
      "getEntityType": {
        "!type": "fn() -> string"
      },
      "getId": {
        "!type": "fn() -> number"
      },
      "getName": {
        "!type": "fn() -> string"
      },
      "setName": {
        "!type": "fn(name: string)"
      }
    },
    "AdWordsApp.ExcludedPlacementListBuilder": {
      "build": {
        "!type": "fn() -> AdWordsApp.ExcludedPlacementListOperation"
      },
      "withName": {
        "!type": "fn(name: string) -> AdWordsApp.ExcludedPlacementListBuilder"
      }
    },
    "AdWordsApp.ExcludedPlacementListIterator": {
      "hasNext": {
        "!type": "fn() -> bool"
      },
      "next": {
        "!type": "fn() -> AdWordsApp.ExcludedPlacementList"
      },
      "totalNumEntities": {
        "!type": "fn() -> number"
      }
    },
    "AdWordsApp.ExcludedPlacementListOperation": {
      "getErrors": {
        "!type": "fn() -> [string]"
      },
      "getResult": {
        "!type": "fn() -> AdWordsApp.ExcludedPlacementList"
      },
      "isSuccessful": {
        "!type": "fn() -> bool"
      }
    },
    "AdWordsApp.ExcludedPlacementListSelector": {
      "get": {
        "!type": "fn() -> AdWordsApp.ExcludedPlacementListIterator"
      },
      "orderBy": {
        "!type": "fn(orderBy: string) -> AdWordsApp.ExcludedPlacementListSelector"
      },
      "withCondition": {
        "!type": "fn(condition: string) -> AdWordsApp.ExcludedPlacementListSelector"
      },
      "withIds": {
        "!type": "fn(ids: [number]) -> AdWordsApp.ExcludedPlacementListSelector"
      },
      "withLimit": {
        "!type": "fn(limit: number) -> AdWordsApp.ExcludedPlacementListSelector"
      }
    },
    "AdWordsApp.ExcludedPlacementOperation": {
      "getErrors": {
        "!type": "fn() -> [string]"
      },
      "getResult": {
        "!type": "fn() -> AdWordsApp.ExcludedPlacement"
      },
      "isSuccessful": {
        "!type": "fn() -> bool"
      }
    },
    "AdWordsApp.ExcludedPlacementSelector": {
      "get": {
        "!type": "fn() -> AdWordsApp.ExcludedPlacementIterator"
      },
      "orderBy": {
        "!type": "fn(orderBy: string) -> AdWordsApp.ExcludedPlacementSelector"
      },
      "withCondition": {
        "!type": "fn(condition: string) -> AdWordsApp.ExcludedPlacementSelector"
      },
      "withLimit": {
        "!type": "fn(limit: number) -> AdWordsApp.ExcludedPlacementSelector"
      }
    },
    "AdWordsApp.ExcludedTopic": {
      "getAdGroup": {
        "!type": "fn() -> AdWordsApp.AdGroup"
      },
      "getCampaign": {
        "!type": "fn() -> AdWordsApp.Campaign"
      },
      "getId": {
        "!type": "fn() -> number"
      },
      "getTopicId": {
        "!type": "fn() -> number"
      },
      "remove": {
        "!type": "fn()"
      }
    },
    "AdWordsApp.ExcludedTopicIterator": {
      "hasNext": {
        "!type": "fn() -> bool"
      },
      "next": {
        "!type": "fn() -> AdWordsApp.ExcludedTopic"
      },
      "totalNumEntities": {
        "!type": "fn() -> number"
      }
    },
    "AdWordsApp.ExcludedTopicOperation": {
      "getErrors": {
        "!type": "fn() -> [string]"
      },
      "getResult": {
        "!type": "fn() -> AdWordsApp.ExcludedTopic"
      },
      "isSuccessful": {
        "!type": "fn() -> bool"
      }
    },
    "AdWordsApp.ExcludedTopicSelector": {
      "get": {
        "!type": "fn() -> AdWordsApp.ExcludedTopicIterator"
      },
      "orderBy": {
        "!type": "fn(orderBy: string) -> AdWordsApp.ExcludedTopicSelector"
      },
      "withCondition": {
        "!type": "fn(condition: string) -> AdWordsApp.ExcludedTopicSelector"
      },
      "withLimit": {
        "!type": "fn(limit: number) -> AdWordsApp.ExcludedTopicSelector"
      }
    },
    "AdWordsApp.ExecutionInfo": {
      "getRemainingCreateQuota": {
        "!type": "fn() -> number"
      },
      "getRemainingGetQuota": {
        "!type": "fn() -> number"
      },
      "getRemainingTime": {
        "!type": "fn() -> number"
      },
      "isPreview": {
        "!type": "fn() -> bool"
      }
    },
    "AdWordsApp.ExtensionSchedule": {
      "getDayOfWeek": {
        "!type": "fn() -> string"
      },
      "getEndHour": {
        "!type": "fn() -> number"
      },
      "getEndMinute": {
        "!type": "fn() -> number"
      },
      "getStartHour": {
        "!type": "fn() -> number"
      },
      "getStartMinute": {
        "!type": "fn() -> number"
      }
    },
    "AdWordsApp.Extensions": {
      "callouts": {
        "!type": "fn() -> AdWordsApp.CalloutSelector"
      },
      "mobileApps": {
        "!type": "fn() -> AdWordsApp.MobileAppSelector"
      },
      "newCalloutBuilder": {
        "!type": "fn() -> AdWordsApp.CalloutBuilder"
      },
      "newMobileAppBuilder": {
        "!type": "fn() -> AdWordsApp.MobileAppBuilder"
      },
      "newPhoneNumberBuilder": {
        "!type": "fn() -> AdWordsApp.PhoneNumberBuilder"
      },
      "newReviewBuilder": {
        "!type": "fn() -> AdWordsApp.ReviewBuilder"
      },
      "newSitelinkBuilder": {
        "!type": "fn() -> AdWordsApp.SitelinkBuilder"
      },
      "phoneNumbers": {
        "!type": "fn() -> AdWordsApp.PhoneNumberSelector"
      },
      "reviews": {
        "!type": "fn() -> AdWordsApp.ReviewSelector"
      },
      "sitelinks": {
        "!type": "fn() -> AdWordsApp.SitelinkSelector"
      }
    },
    "AdWordsApp.FileUpload": {
      "apply": {
        "!type": "fn()"
      },
      "forCampaignManagement": {
        "!type": "fn() -> AdWordsApp.FileUpload"
      },
      "forOfflineConversions": {
        "!type": "fn() -> AdWordsApp.FileUpload"
      },
      "preview": {
        "!type": "fn()"
      },
      "setFileName": {
        "!type": "fn(fileName: string) -> AdWordsApp.FileUpload"
      }
    },
    "AdWordsApp.Keyword": {
      "adParams": {
        "!type": "fn() -> AdWordsApp.AdParamSelector"
      },
      "applyLabel": {
        "!type": "fn(name: string)"
      },
      "bidding": {
        "!type": "fn() -> AdWordsApp.KeywordBidding"
      },
      "clearDestinationUrl": {
        "!type": "fn()"
      },
      "enable": {
        "!type": "fn()"
      },
      "getAdGroup": {
        "!type": "fn() -> AdWordsApp.AdGroup"
      },
      "getApprovalStatus": {
        "!type": "fn() -> string"
      },
      "getCampaign": {
        "!type": "fn() -> AdWordsApp.Campaign"
      },
      "getDestinationUrl": {
        "!type": "fn() -> string"
      },
      "getEntityType": {
        "!type": "fn() -> string"
      },
      "getFirstPageCpc": {
        "!type": "fn() -> number"
      },
      "getId": {
        "!type": "fn() -> number"
      },
      "getMatchType": {
        "!type": "fn() -> string"
      },
      "getQualityScore": {
        "!type": "fn() -> number"
      },
      "getStatsFor": {
        "!type": "fn(dateFrom: object, dateTo: object) -> AdWordsApp.Stats"
      },
      "getStatsFor ": {
        "!type": "fn(dateRange: string) -> AdWordsApp.Stats"
      },
      "getText": {
        "!type": "fn() -> string"
      },
      "getTopOfPageCpc": {
        "!type": "fn() -> number"
      },
      "isEnabled": {
        "!type": "fn() -> bool"
      },
      "isPaused": {
        "!type": "fn() -> bool"
      },
      "labels": {
        "!type": "fn() -> AdWordsApp.LabelSelector"
      },
      "pause": {
        "!type": "fn()"
      },
      "remove": {
        "!type": "fn()"
      },
      "removeLabel": {
        "!type": "fn(name: string)"
      },
      "setAdParam": {
        "!type": "fn(index: number, insertionText: string)"
      },
      "setDestinationUrl": {
        "!type": "fn(destinationUrl: string)"
      },
      "urls": {
        "!type": "fn() -> AdWordsApp.KeywordUrls"
      }
    },
    "AdWordsApp.KeywordBidding": {
      "clearCpc": {
        "!type": "fn()"
      },
      "clearCpm": {
        "!type": "fn()"
      },
      "clearStrategy": {
        "!type": "fn()"
      },
      "getCpc": {
        "!type": "fn() -> number"
      },
      "getCpm": {
        "!type": "fn() -> number"
      },
      "getStrategy": {
        "!type": "fn() -> AdWordsApp.BiddingStrategy"
      },
      "getStrategySource": {
        "!type": "fn() -> string"
      },
      "getStrategyType": {
        "!type": "fn() -> string"
      },
      "setCpc": {
        "!type": "fn(cpc: number)"
      },
      "setCpm": {
        "!type": "fn(cpm: number)"
      },
      "setStrategy": {
        "!type": "fn(biddingStrategy: BiddingStrategy)"
      },
      "setStrategy ": {
        "!type": "fn(biddingStrategy: string)"
      }
    },
    "AdWordsApp.KeywordBuilder": {
      "build": {
        "!type": "fn() -> AdWordsApp.KeywordOperation"
      },
      "withBiddingStrategy": {
        "!type": "fn(biddingStrategy: BiddingStrategy) -> AdWordsApp.KeywordBuilder"
      },
      "withBiddingStrategy ": {
        "!type": "fn(biddingStrategy: string) -> AdWordsApp.KeywordBuilder"
      },
      "withCpc": {
        "!type": "fn(cpc: number) -> AdWordsApp.KeywordBuilder"
      },
      "withCpm": {
        "!type": "fn(cpm: number) -> AdWordsApp.KeywordBuilder"
      },
      "withCustomParameters": {
        "!type": "fn(customParameters: object) -> AdWordsApp.KeywordBuilder"
      },
      "withDestinationUrl": {
        "!type": "fn(destinationUrl: string) -> AdWordsApp.KeywordBuilder"
      },
      "withFinalUrl": {
        "!type": "fn(finalUrl: string) -> AdWordsApp.KeywordBuilder"
      },
      "withMobileFinalUrl": {
        "!type": "fn(mobileFinalUrl: string) -> AdWordsApp.KeywordBuilder"
      },
      "withText": {
        "!type": "fn(text: string) -> AdWordsApp.KeywordBuilder"
      },
      "withTrackingTemplate": {
        "!type": "fn(trackingTemplate: string) -> AdWordsApp.KeywordBuilder"
      }
    },
    "AdWordsApp.KeywordIterator": {
      "hasNext": {
        "!type": "fn() -> bool"
      },
      "next": {
        "!type": "fn() -> AdWordsApp.Keyword"
      },
      "totalNumEntities": {
        "!type": "fn() -> number"
      }
    },
    "AdWordsApp.KeywordOperation": {
      "getErrors": {
        "!type": "fn() -> [string]"
      },
      "getResult": {
        "!type": "fn() -> AdWordsApp.Keyword"
      },
      "isSuccessful": {
        "!type": "fn() -> bool"
      }
    },
    "AdWordsApp.KeywordSelector": {
      "forDateRange": {
        "!type": "fn(dateFrom: object, dateTo: object) -> AdWordsApp.KeywordSelector"
      },
      "forDateRange ": {
        "!type": "fn(dateRange: string) -> AdWordsApp.KeywordSelector"
      },
      "get": {
        "!type": "fn() -> AdWordsApp.KeywordIterator"
      },
      "orderBy": {
        "!type": "fn(orderBy: string) -> AdWordsApp.KeywordSelector"
      },
      "withCondition": {
        "!type": "fn(condition: string) -> AdWordsApp.KeywordSelector"
      },
      "withIds": {
        "!type": "fn(ids: [number]) -> AdWordsApp.KeywordSelector"
      },
      "withLimit": {
        "!type": "fn(limit: number) -> AdWordsApp.KeywordSelector"
      }
    },
    "AdWordsApp.KeywordUrls": {
      "clearFinalUrl": {
        "!type": "fn()"
      },
      "clearMobileFinalUrl": {
        "!type": "fn()"
      },
      "clearTrackingTemplate": {
        "!type": "fn()"
      },
      "getCustomParameters": {
        "!type": "fn() -> object"
      },
      "getFinalUrl": {
        "!type": "fn() -> string"
      },
      "getMobileFinalUrl": {
        "!type": "fn() -> string"
      },
      "getTrackingTemplate": {
        "!type": "fn() -> string"
      },
      "setCustomParameters": {
        "!type": "fn(customParameters: object)"
      },
      "setFinalUrl": {
        "!type": "fn(finalUrl: string)"
      },
      "setMobileFinalUrl": {
        "!type": "fn(mobileFinalUrl: string)"
      },
      "setTrackingTemplate": {
        "!type": "fn(trackingTemplate: string)"
      }
    },
    "AdWordsApp.Label": {
      "adGroups": {
        "!type": "fn() -> AdWordsApp.AdGroupSelector"
      },
      "ads": {
        "!type": "fn() -> AdWordsApp.AdSelector"
      },
      "campaigns": {
        "!type": "fn() -> AdWordsApp.CampaignSelector"
      },
      "getColor": {
        "!type": "fn() -> string"
      },
      "getDescription": {
        "!type": "fn() -> string"
      },
      "getEntityType": {
        "!type": "fn() -> string"
      },
      "getId": {
        "!type": "fn() -> string"
      },
      "getName": {
        "!type": "fn() -> string"
      },
      "keywords": {
        "!type": "fn() -> AdWordsApp.KeywordSelector"
      },
      "remove": {
        "!type": "fn()"
      },
      "setColor": {
        "!type": "fn(color: string)"
      },
      "setDescription": {
        "!type": "fn(description: string)"
      },
      "setName": {
        "!type": "fn(name: string)"
      }
    },
    "AdWordsApp.LabelIterator": {
      "hasNext": {
        "!type": "fn() -> bool"
      },
      "next": {
        "!type": "fn() -> AdWordsApp.Label"
      },
      "totalNumEntities": {
        "!type": "fn() -> number"
      }
    },
    "AdWordsApp.LabelSelector": {
      "get": {
        "!type": "fn() -> AdWordsApp.LabelIterator"
      },
      "orderBy": {
        "!type": "fn(orderBy: string) -> AdWordsApp.LabelSelector"
      },
      "withCondition": {
        "!type": "fn(condition: string) -> AdWordsApp.LabelSelector"
      },
      "withLimit": {
        "!type": "fn(limit: number) -> AdWordsApp.LabelSelector"
      }
    },
    "AdWordsApp.MobileApp": {
      "clearLinkUrl": {
        "!type": "fn()"
      },
      "getAppId": {
        "!type": "fn() -> string"
      },
      "getEndDate": {
        "!type": "fn() -> AdWordsApp.AdWordsDate"
      },
      "getEntityType": {
        "!type": "fn() -> string"
      },
      "getId": {
        "!type": "fn() -> number"
      },
      "getLinkText": {
        "!type": "fn() -> string"
      },
      "getLinkUrl": {
        "!type": "fn() -> string"
      },
      "getSchedules": {
        "!type": "fn() -> [AdWordsApp.ExtensionSchedule]"
      },
      "getStartDate": {
        "!type": "fn() -> AdWordsApp.AdWordsDate"
      },
      "getStatsFor": {
        "!type": "fn(dateFrom: object, dateTo: object) -> AdWordsApp.Stats"
      },
      "getStatsFor ": {
        "!type": "fn(dateRange: string) -> AdWordsApp.Stats"
      },
      "getStore": {
        "!type": "fn() -> string"
      },
      "isMobilePreferred": {
        "!type": "fn() -> bool"
      },
      "setAppId": {
        "!type": "fn(appId: string)"
      },
      "setEndDate": {
        "!type": "fn(date: object)"
      },
      "setLinkText": {
        "!type": "fn(linkText: string)"
      },
      "setLinkUrl": {
        "!type": "fn(linkUrl: string)"
      },
      "setMobilePreferred": {
        "!type": "fn(isMobilePreferred: bool)"
      },
      "setSchedules": {
        "!type": "fn(schedules: [AdWordsApp.ExtensionSchedule])"
      },
      "setStartDate": {
        "!type": "fn(date: object)"
      },
      "setStore": {
        "!type": "fn(store: string)"
      },
      "urls": {
        "!type": "fn() -> AdWordsApp.MobileAppUrls"
      }
    },
    "AdWordsApp.MobileAppBuilder": {
      "build": {
        "!type": "fn() -> AdWordsApp.MobileAppOperation"
      },
      "withAppId": {
        "!type": "fn(appId: string) -> AdWordsApp.MobileAppBuilder"
      },
      "withCustomParameters": {
        "!type": "fn(customParameters: object) -> AdWordsApp.MobileAppBuilder"
      },
      "withEndDate": {
        "!type": "fn(date: object) -> AdWordsApp.MobileAppBuilder"
      },
      "withFinalUrl": {
        "!type": "fn(finalUrl: string) -> AdWordsApp.MobileAppBuilder"
      },
      "withLinkText": {
        "!type": "fn(linkText: string) -> AdWordsApp.MobileAppBuilder"
      },
      "withLinkUrl": {
        "!type": "fn(linkUrl: string) -> AdWordsApp.MobileAppBuilder"
      },
      "withMobileFinalUrl": {
        "!type": "fn(mobileFinalUrl: string) -> AdWordsApp.MobileAppBuilder"
      },
      "withMobilePreferred": {
        "!type": "fn(isMobilePreferred: bool) -> AdWordsApp.MobileAppBuilder"
      },
      "withSchedules": {
        "!type": "fn(schedules: [AdWordsApp.ExtensionSchedule]) -> AdWordsApp.MobileAppBuilder"
      },
      "withStartDate": {
        "!type": "fn(date: object) -> AdWordsApp.MobileAppBuilder"
      },
      "withStore": {
        "!type": "fn(store: string) -> AdWordsApp.MobileAppBuilder"
      },
      "withTrackingTemplate": {
        "!type": "fn(trackingTemplate: string) -> AdWordsApp.MobileAppBuilder"
      }
    },
    "AdWordsApp.MobileAppIterator": {
      "hasNext": {
        "!type": "fn() -> bool"
      },
      "next": {
        "!type": "fn() -> AdWordsApp.MobileApp"
      },
      "totalNumEntities": {
        "!type": "fn() -> number"
      }
    },
    "AdWordsApp.MobileAppOperation": {
      "getErrors": {
        "!type": "fn() -> [string]"
      },
      "getResult": {
        "!type": "fn() -> AdWordsApp.MobileApp"
      },
      "isSuccessful": {
        "!type": "fn() -> bool"
      }
    },
    "AdWordsApp.MobileAppSelector": {
      "forDateRange": {
        "!type": "fn(dateFrom: object, dateTo: object) -> AdWordsApp.MobileAppSelector"
      },
      "forDateRange ": {
        "!type": "fn(dateRange: string) -> AdWordsApp.MobileAppSelector"
      },
      "get": {
        "!type": "fn() -> AdWordsApp.MobileAppIterator"
      },
      "orderBy": {
        "!type": "fn(orderBy: string) -> AdWordsApp.MobileAppSelector"
      },
      "withCondition": {
        "!type": "fn(condition: string) -> AdWordsApp.MobileAppSelector"
      },
      "withIds": {
        "!type": "fn(ids: [number]) -> AdWordsApp.MobileAppSelector"
      },
      "withLimit": {
        "!type": "fn(limit: number) -> AdWordsApp.MobileAppSelector"
      }
    },
    "AdWordsApp.MobileAppUrls": {
      "clearMobileFinalUrl": {
        "!type": "fn()"
      },
      "getCustomParameters": {
        "!type": "fn() -> object"
      },
      "getFinalUrl": {
        "!type": "fn() -> string"
      },
      "getMobileFinalUrl": {
        "!type": "fn() -> string"
      },
      "getTrackingTemplate": {
        "!type": "fn() -> string"
      },
      "setCustomParameters": {
        "!type": "fn(customParameters: object)"
      },
      "setFinalUrl": {
        "!type": "fn(finalUrl: string)"
      },
      "setMobileFinalUrl": {
        "!type": "fn(mobileFinalUrl: string)"
      },
      "setTrackingTemplate": {
        "!type": "fn(trackingTemplate: string)"
      }
    },
    "AdWordsApp.NegativeKeyword": {
      "getAdGroup": {
        "!type": "fn() -> AdWordsApp.AdGroup"
      },
      "getCampaign": {
        "!type": "fn() -> AdWordsApp.Campaign"
      },
      "getEntityType": {
        "!type": "fn() -> string"
      },
      "getMatchType": {
        "!type": "fn() -> string"
      },
      "getText": {
        "!type": "fn() -> string"
      },
      "remove": {
        "!type": "fn()"
      }
    },
    "AdWordsApp.NegativeKeywordIterator": {
      "hasNext": {
        "!type": "fn() -> bool"
      },
      "next": {
        "!type": "fn() -> AdWordsApp.NegativeKeyword"
      },
      "totalNumEntities": {
        "!type": "fn() -> number"
      }
    },
    "AdWordsApp.NegativeKeywordList": {
      "addNegativeKeyword": {
        "!type": "fn(keywordText: string)"
      },
      "addNegativeKeywords": {
        "!type": "fn(keywordTexts: [lang.String])"
      },
      "campaigns": {
        "!type": "fn() -> AdWordsApp.CampaignSelector"
      },
      "getEntityType": {
        "!type": "fn() -> string"
      },
      "getId": {
        "!type": "fn() -> number"
      },
      "getName": {
        "!type": "fn() -> string"
      },
      "negativeKeywords": {
        "!type": "fn() -> AdWordsApp.SharedNegativeKeywordSelector"
      },
      "setName": {
        "!type": "fn(name: string)"
      }
    },
    "AdWordsApp.NegativeKeywordListBuilder": {
      "build": {
        "!type": "fn() -> AdWordsApp.NegativeKeywordListOperation"
      },
      "withName": {
        "!type": "fn(name: string) -> AdWordsApp.NegativeKeywordListBuilder"
      }
    },
    "AdWordsApp.NegativeKeywordListIterator": {
      "hasNext": {
        "!type": "fn() -> bool"
      },
      "next": {
        "!type": "fn() -> AdWordsApp.NegativeKeywordList"
      },
      "totalNumEntities": {
        "!type": "fn() -> number"
      }
    },
    "AdWordsApp.NegativeKeywordListOperation": {
      "getErrors": {
        "!type": "fn() -> [string]"
      },
      "getResult": {
        "!type": "fn() -> AdWordsApp.NegativeKeywordList"
      },
      "isSuccessful": {
        "!type": "fn() -> bool"
      }
    },
    "AdWordsApp.NegativeKeywordListSelector": {
      "get": {
        "!type": "fn() -> AdWordsApp.NegativeKeywordListIterator"
      },
      "orderBy": {
        "!type": "fn(orderBy: string) -> AdWordsApp.NegativeKeywordListSelector"
      },
      "withCondition": {
        "!type": "fn(condition: string) -> AdWordsApp.NegativeKeywordListSelector"
      },
      "withIds": {
        "!type": "fn(ids: [number]) -> AdWordsApp.NegativeKeywordListSelector"
      },
      "withLimit": {
        "!type": "fn(limit: number) -> AdWordsApp.NegativeKeywordListSelector"
      }
    },
    "AdWordsApp.NegativeKeywordSelector": {
      "get": {
        "!type": "fn() -> AdWordsApp.NegativeKeywordIterator"
      },
      "orderBy": {
        "!type": "fn(orderBy: string) -> AdWordsApp.NegativeKeywordSelector"
      },
      "withCondition": {
        "!type": "fn(condition: string) -> AdWordsApp.NegativeKeywordSelector"
      },
      "withLimit": {
        "!type": "fn(limit: number) -> AdWordsApp.NegativeKeywordSelector"
      }
    },
    "AdWordsApp.PhoneNumber": {
      "getCountry": {
        "!type": "fn() -> string"
      },
      "getEndDate": {
        "!type": "fn() -> AdWordsApp.AdWordsDate"
      },
      "getEntityType": {
        "!type": "fn() -> string"
      },
      "getId": {
        "!type": "fn() -> number"
      },
      "getPhoneNumber": {
        "!type": "fn() -> string"
      },
      "getSchedules": {
        "!type": "fn() -> [AdWordsApp.ExtensionSchedule]"
      },
      "getStartDate": {
        "!type": "fn() -> AdWordsApp.AdWordsDate"
      },
      "getStatsFor": {
        "!type": "fn(dateFrom: object, dateTo: object) -> AdWordsApp.Stats"
      },
      "getStatsFor ": {
        "!type": "fn(dateRange: string) -> AdWordsApp.Stats"
      },
      "isCallOnly": {
        "!type": "fn() -> bool"
      },
      "isMobilePreferred": {
        "!type": "fn() -> bool"
      },
      "setCallOnly": {
        "!type": "fn(callOnly: bool)"
      },
      "setCountry": {
        "!type": "fn(country: string)"
      },
      "setEndDate": {
        "!type": "fn(date: object)"
      },
      "setMobilePreferred": {
        "!type": "fn(isMobilePreferred: bool)"
      },
      "setPhoneNumber": {
        "!type": "fn(phoneNumber: string)"
      },
      "setSchedules": {
        "!type": "fn(schedules: [AdWordsApp.ExtensionSchedule])"
      },
      "setStartDate": {
        "!type": "fn(date: object)"
      }
    },
    "AdWordsApp.PhoneNumberBuilder": {
      "build": {
        "!type": "fn() -> AdWordsApp.PhoneNumberOperation"
      },
      "withCallOnly": {
        "!type": "fn(callOnly: bool) -> AdWordsApp.PhoneNumberBuilder"
      },
      "withCountry": {
        "!type": "fn(country: string) -> AdWordsApp.PhoneNumberBuilder"
      },
      "withEndDate": {
        "!type": "fn(date: object) -> AdWordsApp.PhoneNumberBuilder"
      },
      "withMobilePreferred": {
        "!type": "fn(isMobilePreferred: bool) -> AdWordsApp.PhoneNumberBuilder"
      },
      "withPhoneNumber": {
        "!type": "fn(phoneNumber: string) -> AdWordsApp.PhoneNumberBuilder"
      },
      "withSchedules": {
        "!type": "fn(schedules: [AdWordsApp.ExtensionSchedule]) -> AdWordsApp.PhoneNumberBuilder"
      },
      "withStartDate": {
        "!type": "fn(date: object) -> AdWordsApp.PhoneNumberBuilder"
      }
    },
    "AdWordsApp.PhoneNumberIterator": {
      "hasNext": {
        "!type": "fn() -> bool"
      },
      "next": {
        "!type": "fn() -> AdWordsApp.PhoneNumber"
      },
      "totalNumEntities": {
        "!type": "fn() -> number"
      }
    },
    "AdWordsApp.PhoneNumberOperation": {
      "getErrors": {
        "!type": "fn() -> [string]"
      },
      "getResult": {
        "!type": "fn() -> AdWordsApp.PhoneNumber"
      },
      "isSuccessful": {
        "!type": "fn() -> bool"
      }
    },
    "AdWordsApp.PhoneNumberSelector": {
      "forDateRange": {
        "!type": "fn(dateFrom: object, dateTo: object) -> AdWordsApp.PhoneNumberSelector"
      },
      "forDateRange ": {
        "!type": "fn(dateRange: string) -> AdWordsApp.PhoneNumberSelector"
      },
      "get": {
        "!type": "fn() -> AdWordsApp.PhoneNumberIterator"
      },
      "orderBy": {
        "!type": "fn(orderBy: string) -> AdWordsApp.PhoneNumberSelector"
      },
      "withCondition": {
        "!type": "fn(condition: string) -> AdWordsApp.PhoneNumberSelector"
      },
      "withIds": {
        "!type": "fn(ids: [number]) -> AdWordsApp.PhoneNumberSelector"
      },
      "withLimit": {
        "!type": "fn(limit: number) -> AdWordsApp.PhoneNumberSelector"
      }
    },
    "AdWordsApp.Placement": {
      "bidding": {
        "!type": "fn() -> AdWordsApp.PlacementBidding"
      },
      "getAdGroup": {
        "!type": "fn() -> AdWordsApp.AdGroup"
      },
      "getCampaign": {
        "!type": "fn() -> AdWordsApp.Campaign"
      },
      "getId": {
        "!type": "fn() -> number"
      },
      "getStatsFor": {
        "!type": "fn(dateFrom: object, dateTo: object) -> AdWordsApp.Stats"
      },
      "getStatsFor ": {
        "!type": "fn(dateRange: string) -> AdWordsApp.Stats"
      },
      "getUrl": {
        "!type": "fn() -> string"
      },
      "isEnabled": {
        "!type": "fn() -> bool"
      },
      "isManaged": {
        "!type": "fn() -> bool"
      },
      "isPaused": {
        "!type": "fn() -> bool"
      },
      "remove": {
        "!type": "fn()"
      }
    },
    "AdWordsApp.PlacementBidding": {
      "clearCpc": {
        "!type": "fn()"
      },
      "clearCpm": {
        "!type": "fn()"
      },
      "clearStrategy": {
        "!type": "fn()"
      },
      "getCpc": {
        "!type": "fn() -> number"
      },
      "getCpm": {
        "!type": "fn() -> number"
      },
      "getStrategy": {
        "!type": "fn() -> AdWordsApp.BiddingStrategy"
      },
      "getStrategySource": {
        "!type": "fn() -> string"
      },
      "getStrategyType": {
        "!type": "fn() -> string"
      },
      "setCpc": {
        "!type": "fn(cpc: number)"
      },
      "setCpm": {
        "!type": "fn(cpm: number)"
      },
      "setStrategy": {
        "!type": "fn(biddingStrategy: BiddingStrategy)"
      },
      "setStrategy ": {
        "!type": "fn(biddingStrategy: string)"
      }
    },
    "AdWordsApp.PlacementBuilder": {
      "build": {
        "!type": "fn() -> AdWordsApp.PlacementOperation"
      },
      "exclude": {
        "!type": "fn() -> AdWordsApp.ExcludedPlacementOperation"
      },
      "withCpc": {
        "!type": "fn(cpc: number) -> AdWordsApp.PlacementBuilder"
      },
      "withCpm": {
        "!type": "fn(cpm: number) -> AdWordsApp.PlacementBuilder"
      },
      "withUrl": {
        "!type": "fn(url: string) -> AdWordsApp.PlacementBuilder"
      }
    },
    "AdWordsApp.PlacementIterator": {
      "hasNext": {
        "!type": "fn() -> bool"
      },
      "next": {
        "!type": "fn() -> AdWordsApp.Placement"
      },
      "totalNumEntities": {
        "!type": "fn() -> number"
      }
    },
    "AdWordsApp.PlacementOperation": {
      "getErrors": {
        "!type": "fn() -> [string]"
      },
      "getResult": {
        "!type": "fn() -> AdWordsApp.Placement"
      },
      "isSuccessful": {
        "!type": "fn() -> bool"
      }
    },
    "AdWordsApp.PlacementSelector": {
      "forDateRange": {
        "!type": "fn(dateFrom: object, dateTo: object) -> AdWordsApp.PlacementSelector"
      },
      "forDateRange ": {
        "!type": "fn(dateRange: string) -> AdWordsApp.PlacementSelector"
      },
      "get": {
        "!type": "fn() -> AdWordsApp.PlacementIterator"
      },
      "orderBy": {
        "!type": "fn(orderBy: string) -> AdWordsApp.PlacementSelector"
      },
      "withCondition": {
        "!type": "fn(condition: string) -> AdWordsApp.PlacementSelector"
      },
      "withIds": {
        "!type": "fn(ids: [number]) -> AdWordsApp.PlacementSelector"
      },
      "withLimit": {
        "!type": "fn(limit: number) -> AdWordsApp.PlacementSelector"
      }
    },
    "AdWordsApp.Platform": {
      "getBidModifier": {
        "!type": "fn() -> number"
      },
      "getCampaign": {
        "!type": "fn() -> AdWordsApp.Campaign"
      },
      "getEntityType": {
        "!type": "fn() -> string"
      },
      "getId": {
        "!type": "fn() -> number"
      },
      "getName": {
        "!type": "fn() -> string"
      },
      "getStatsFor": {
        "!type": "fn(dateFrom: object, dateTo: object) -> AdWordsApp.Stats"
      },
      "getStatsFor ": {
        "!type": "fn(dateRange: string) -> AdWordsApp.Stats"
      },
      "setBidModifier": {
        "!type": "fn(modifier: number)"
      }
    },
    "AdWordsApp.PlatformIterator": {
      "hasNext": {
        "!type": "fn() -> bool"
      },
      "next": {
        "!type": "fn() -> AdWordsApp.Platform"
      },
      "totalNumEntities": {
        "!type": "fn() -> number"
      }
    },
    "AdWordsApp.PlatformSelector": {
      "desktop": {
        "!type": "fn() -> AdWordsApp.PlatformSelector"
      },
      "forDateRange": {
        "!type": "fn(dateFrom: object, dateTo: object) -> AdWordsApp.PlatformSelector"
      },
      "forDateRange ": {
        "!type": "fn(dateRange: string) -> AdWordsApp.PlatformSelector"
      },
      "get": {
        "!type": "fn() -> AdWordsApp.PlatformIterator"
      },
      "mobile": {
        "!type": "fn() -> AdWordsApp.PlatformSelector"
      },
      "orderBy": {
        "!type": "fn(orderBy: string) -> AdWordsApp.PlatformSelector"
      },
      "tablet": {
        "!type": "fn() -> AdWordsApp.PlatformSelector"
      },
      "withCondition": {
        "!type": "fn(condition: string) -> AdWordsApp.PlatformSelector"
      },
      "withIds": {
        "!type": "fn(ids: [number]) -> AdWordsApp.PlatformSelector"
      },
      "withLimit": {
        "!type": "fn(limit: number) -> AdWordsApp.PlatformSelector"
      }
    },
    "AdWordsApp.ProductAd": {
      "applyLabel": {
        "!type": "fn(name: string)"
      },
      "enable": {
        "!type": "fn()"
      },
      "getAdGroup": {
        "!type": "fn() -> AdWordsApp.ShoppingAdGroup"
      },
      "getCampaign": {
        "!type": "fn() -> AdWordsApp.ShoppingCampaign"
      },
      "getEntityType": {
        "!type": "fn() -> string"
      },
      "getId": {
        "!type": "fn() -> number"
      },
      "getPromotionLine": {
        "!type": "fn() -> string"
      },
      "getStatsFor": {
        "!type": "fn(dateFrom: object, dateTo: object) -> AdWordsApp.Stats"
      },
      "getStatsFor ": {
        "!type": "fn(dateRange: string) -> AdWordsApp.Stats"
      },
      "getType": {
        "!type": "fn() -> string"
      },
      "isEnabled": {
        "!type": "fn() -> bool"
      },
      "isMobilePreferred": {
        "!type": "fn() -> bool"
      },
      "isPaused": {
        "!type": "fn() -> bool"
      },
      "labels": {
        "!type": "fn() -> AdWordsApp.LabelSelector"
      },
      "pause": {
        "!type": "fn()"
      },
      "remove": {
        "!type": "fn()"
      },
      "removeLabel": {
        "!type": "fn(name: string)"
      }
    },
    "AdWordsApp.ProductAdBuilder": {
      "build": {
        "!type": "fn() -> AdWordsApp.ProductAdOperation"
      },
      "withMobilePreferred": {
        "!type": "fn(isMobilePreferred: bool) -> AdWordsApp.ProductAdBuilder"
      },
      "withPromotionLine": {
        "!type": "fn(promotionLine: string) -> AdWordsApp.ProductAdBuilder"
      }
    },
    "AdWordsApp.ProductAdIterator": {
      "hasNext": {
        "!type": "fn() -> bool"
      },
      "next": {
        "!type": "fn() -> AdWordsApp.ProductAd"
      },
      "totalNumEntities": {
        "!type": "fn() -> number"
      }
    },
    "AdWordsApp.ProductAdOperation": {
      "getErrors": {
        "!type": "fn() -> [string]"
      },
      "getResult": {
        "!type": "fn() -> AdWordsApp.ProductAd"
      },
      "isSuccessful": {
        "!type": "fn() -> bool"
      }
    },
    "AdWordsApp.ProductAdSelector": {
      "forDateRange": {
        "!type": "fn(dateFrom: object, dateTo: object) -> AdWordsApp.ProductAdSelector"
      },
      "forDateRange ": {
        "!type": "fn(dateRange: string) -> AdWordsApp.ProductAdSelector"
      },
      "get": {
        "!type": "fn() -> AdWordsApp.ProductAdIterator"
      },
      "orderBy": {
        "!type": "fn(orderBy: string) -> AdWordsApp.ProductAdSelector"
      },
      "withCondition": {
        "!type": "fn(condition: string) -> AdWordsApp.ProductAdSelector"
      },
      "withIds": {
        "!type": "fn(ids: [number]) -> AdWordsApp.ProductAdSelector"
      },
      "withLimit": {
        "!type": "fn(limit: number) -> AdWordsApp.ProductAdSelector"
      }
    },
    "AdWordsApp.ProductBrand": {
      "children": {
        "!type": "fn() -> AdWordsApp.ProductGroupSelector"
      },
      "exclude": {
        "!type": "fn()"
      },
      "getAdGroup": {
        "!type": "fn() -> AdWordsApp.ShoppingAdGroup"
      },
      "getCampaign": {
        "!type": "fn() -> AdWordsApp.ShoppingCampaign"
      },
      "getEntityType": {
        "!type": "fn() -> string"
      },
      "getId": {
        "!type": "fn() -> number"
      },
      "getMaxCpc": {
        "!type": "fn() -> number"
      },
      "getName": {
        "!type": "fn() -> string"
      },
      "getStatsFor": {
        "!type": "fn(dateFrom: object, dateTo: object) -> AdWordsApp.Stats"
      },
      "getStatsFor ": {
        "!type": "fn(dateRange: string) -> AdWordsApp.Stats"
      },
      "getValue": {
        "!type": "fn() -> string"
      },
      "include": {
        "!type": "fn()"
      },
      "isExcluded": {
        "!type": "fn() -> bool"
      },
      "isOtherCase": {
        "!type": "fn() -> bool"
      },
      "newChild": {
        "!type": "fn() -> AdWordsApp.ProductGroupBuilderSpace"
      },
      "parent": {
        "!type": "fn() -> AdWordsApp.ProductGroup"
      },
      "remove": {
        "!type": "fn()"
      },
      "removeAllChildren": {
        "!type": "fn()"
      },
      "setMaxCpc": {
        "!type": "fn(maxCpc: number)"
      }
    },
    "AdWordsApp.ProductBrandBuilder": {
      "build": {
        "!type": "fn() -> AdWordsApp.ProductBrandOperation"
      },
      "withBid": {
        "!type": "fn(bid: number) -> AdWordsApp.ProductBrandBuilder"
      },
      "withName": {
        "!type": "fn(productBrandName: string) -> AdWordsApp.ProductBrandBuilder"
      },
      "withValue": {
        "!type": "fn(value: string) -> AdWordsApp.ProductBrandBuilder"
      }
    },
    "AdWordsApp.ProductBrandOperation": {
      "getErrors": {
        "!type": "fn() -> [string]"
      },
      "getResult": {
        "!type": "fn() -> AdWordsApp.ProductBrand"
      },
      "isSuccessful": {
        "!type": "fn() -> bool"
      }
    },
    "AdWordsApp.ProductCategory": {
      "children": {
        "!type": "fn() -> AdWordsApp.ProductGroupSelector"
      },
      "exclude": {
        "!type": "fn()"
      },
      "getAdGroup": {
        "!type": "fn() -> AdWordsApp.ShoppingAdGroup"
      },
      "getCampaign": {
        "!type": "fn() -> AdWordsApp.ShoppingCampaign"
      },
      "getCountry": {
        "!type": "fn() -> string"
      },
      "getEntityType": {
        "!type": "fn() -> string"
      },
      "getId": {
        "!type": "fn() -> number"
      },
      "getMaxCpc": {
        "!type": "fn() -> number"
      },
      "getName": {
        "!type": "fn() -> string"
      },
      "getStatsFor": {
        "!type": "fn(dateFrom: object, dateTo: object) -> AdWordsApp.Stats"
      },
      "getStatsFor ": {
        "!type": "fn(dateRange: string) -> AdWordsApp.Stats"
      },
      "getValue": {
        "!type": "fn() -> string"
      },
      "hasChildren": {
        "!type": "fn() -> bool"
      },
      "include": {
        "!type": "fn()"
      },
      "isExcluded": {
        "!type": "fn() -> bool"
      },
      "isOtherCase": {
        "!type": "fn() -> bool"
      },
      "newChild": {
        "!type": "fn() -> AdWordsApp.ProductGroupBuilderSpace"
      },
      "parent": {
        "!type": "fn() -> AdWordsApp.ProductGroup"
      },
      "remove": {
        "!type": "fn()"
      },
      "removeAllChildren": {
        "!type": "fn()"
      },
      "setMaxCpc": {
        "!type": "fn(maxCpc: number)"
      }
    },
    "AdWordsApp.ProductCategoryBuilder": {
      "build": {
        "!type": "fn() -> AdWordsApp.ProductCategoryOperation"
      },
      "withBid": {
        "!type": "fn(bid: number) -> AdWordsApp.ProductCategoryBuilder"
      },
      "withName": {
        "!type": "fn(productCategoryName: string) -> AdWordsApp.ProductCategoryBuilder"
      },
      "withValue": {
        "!type": "fn(value: string) -> AdWordsApp.ProductCategoryBuilder"
      }
    },
    "AdWordsApp.ProductCategoryOperation": {
      "getErrors": {
        "!type": "fn() -> [string]"
      },
      "getResult": {
        "!type": "fn() -> AdWordsApp.ProductCategory"
      },
      "isSuccessful": {
        "!type": "fn() -> bool"
      }
    },
    "AdWordsApp.ProductChannel": {
      "children": {
        "!type": "fn() -> AdWordsApp.ProductGroupSelector"
      },
      "exclude": {
        "!type": "fn()"
      },
      "getAdGroup": {
        "!type": "fn() -> AdWordsApp.ShoppingAdGroup"
      },
      "getCampaign": {
        "!type": "fn() -> AdWordsApp.ShoppingCampaign"
      },
      "getChannel": {
        "!type": "fn() -> string"
      },
      "getEntityType": {
        "!type": "fn() -> string"
      },
      "getId": {
        "!type": "fn() -> number"
      },
      "getMaxCpc": {
        "!type": "fn() -> number"
      },
      "getStatsFor": {
        "!type": "fn(dateFrom: object, dateTo: object) -> AdWordsApp.Stats"
      },
      "getStatsFor ": {
        "!type": "fn(dateRange: string) -> AdWordsApp.Stats"
      },
      "getValue": {
        "!type": "fn() -> string"
      },
      "hasChildren": {
        "!type": "fn() -> bool"
      },
      "include": {
        "!type": "fn()"
      },
      "isExcluded": {
        "!type": "fn() -> bool"
      },
      "isOtherCase": {
        "!type": "fn() -> bool"
      },
      "newChild": {
        "!type": "fn() -> AdWordsApp.ProductGroupBuilderSpace"
      },
      "parent": {
        "!type": "fn() -> AdWordsApp.ProductGroup"
      },
      "remove": {
        "!type": "fn()"
      },
      "removeAllChildren": {
        "!type": "fn()"
      },
      "setMaxCpc": {
        "!type": "fn(maxCpc: number)"
      }
    },
    "AdWordsApp.ProductChannelBuilder": {
      "build": {
        "!type": "fn() -> AdWordsApp.ProductChannelOperation"
      },
      "withBid": {
        "!type": "fn(bid: number) -> AdWordsApp.ProductChannelBuilder"
      },
      "withChannel": {
        "!type": "fn(channel: string) -> AdWordsApp.ProductChannelBuilder"
      },
      "withValue": {
        "!type": "fn(value: string) -> AdWordsApp.ProductChannelBuilder"
      }
    },
    "AdWordsApp.ProductChannelExclusivity": {
      "children": {
        "!type": "fn() -> AdWordsApp.ProductGroupSelector"
      },
      "exclude": {
        "!type": "fn()"
      },
      "getAdGroup": {
        "!type": "fn() -> AdWordsApp.ShoppingAdGroup"
      },
      "getCampaign": {
        "!type": "fn() -> AdWordsApp.ShoppingCampaign"
      },
      "getChannelExclusivity": {
        "!type": "fn() -> string"
      },
      "getEntityType": {
        "!type": "fn() -> string"
      },
      "getId": {
        "!type": "fn() -> number"
      },
      "getMaxCpc": {
        "!type": "fn() -> number"
      },
      "getStatsFor": {
        "!type": "fn(dateFrom: object, dateTo: object) -> AdWordsApp.Stats"
      },
      "getStatsFor ": {
        "!type": "fn(dateRange: string) -> AdWordsApp.Stats"
      },
      "getValue": {
        "!type": "fn() -> string"
      },
      "hasChildren": {
        "!type": "fn() -> bool"
      },
      "include": {
        "!type": "fn()"
      },
      "isExcluded": {
        "!type": "fn() -> bool"
      },
      "isOtherCase": {
        "!type": "fn() -> bool"
      },
      "newChild": {
        "!type": "fn() -> AdWordsApp.ProductGroupBuilderSpace"
      },
      "parent": {
        "!type": "fn() -> AdWordsApp.ProductGroup"
      },
      "remove": {
        "!type": "fn()"
      },
      "removeAllChildren": {
        "!type": "fn()"
      },
      "setMaxCpc": {
        "!type": "fn(maxCpc: number)"
      }
    },
    "AdWordsApp.ProductChannelExclusivityBuilder": {
      "build": {
        "!type": "fn() -> AdWordsApp.ProductChannelExclusivityOperation"
      },
      "withBid": {
        "!type": "fn(bid: number) -> AdWordsApp.ProductChannelExclusivityBuilder"
      },
      "withChannelExclusivity": {
        "!type": "fn(channelExclusivity: string) -> AdWordsApp.ProductChannelExclusivityBuilder"
      },
      "withValue": {
        "!type": "fn(value: string) -> AdWordsApp.ProductChannelExclusivityBuilder"
      }
    },
    "AdWordsApp.ProductChannelExclusivityOperation": {
      "getErrors": {
        "!type": "fn() -> [string]"
      },
      "getResult": {
        "!type": "fn() -> AdWordsApp.ProductChannelExclusivity"
      },
      "isSuccessful": {
        "!type": "fn() -> bool"
      }
    },
    "AdWordsApp.ProductChannelOperation": {
      "getErrors": {
        "!type": "fn() -> [string]"
      },
      "getResult": {
        "!type": "fn() -> AdWordsApp.ProductChannel"
      },
      "isSuccessful": {
        "!type": "fn() -> bool"
      }
    },
    "AdWordsApp.ProductCondition": {
      "children": {
        "!type": "fn() -> AdWordsApp.ProductGroupSelector"
      },
      "exclude": {
        "!type": "fn()"
      },
      "getAdGroup": {
        "!type": "fn() -> AdWordsApp.ShoppingAdGroup"
      },
      "getCampaign": {
        "!type": "fn() -> AdWordsApp.ShoppingCampaign"
      },
      "getCondition": {
        "!type": "fn() -> string"
      },
      "getEntityType": {
        "!type": "fn() -> string"
      },
      "getId": {
        "!type": "fn() -> number"
      },
      "getMaxCpc": {
        "!type": "fn() -> number"
      },
      "getStatsFor": {
        "!type": "fn(dateFrom: object, dateTo: object) -> AdWordsApp.Stats"
      },
      "getStatsFor ": {
        "!type": "fn(dateRange: string) -> AdWordsApp.Stats"
      },
      "getValue": {
        "!type": "fn() -> string"
      },
      "hasChildren": {
        "!type": "fn() -> bool"
      },
      "include": {
        "!type": "fn()"
      },
      "isExcluded": {
        "!type": "fn() -> bool"
      },
      "isOtherCase": {
        "!type": "fn() -> bool"
      },
      "newChild": {
        "!type": "fn() -> AdWordsApp.ProductGroupBuilderSpace"
      },
      "parent": {
        "!type": "fn() -> AdWordsApp.ProductGroup"
      },
      "remove": {
        "!type": "fn()"
      },
      "removeAllChildren": {
        "!type": "fn()"
      },
      "setMaxCpc": {
        "!type": "fn(maxCpc: number)"
      }
    },
    "AdWordsApp.ProductConditionBuilder": {
      "build": {
        "!type": "fn() -> AdWordsApp.ProductConditionOperation"
      },
      "withBid": {
        "!type": "fn(bid: number) -> AdWordsApp.ProductConditionBuilder"
      },
      "withCondition": {
        "!type": "fn(condition: string) -> AdWordsApp.ProductConditionBuilder"
      },
      "withValue": {
        "!type": "fn(value: string) -> AdWordsApp.ProductConditionBuilder"
      }
    },
    "AdWordsApp.ProductConditionOperation": {
      "getErrors": {
        "!type": "fn() -> [string]"
      },
      "getResult": {
        "!type": "fn() -> AdWordsApp.ProductCondition"
      },
      "isSuccessful": {
        "!type": "fn() -> bool"
      }
    },
    "AdWordsApp.ProductCustomLabel": {
      "children": {
        "!type": "fn() -> AdWordsApp.ProductGroupSelector"
      },
      "exclude": {
        "!type": "fn()"
      },
      "getAdGroup": {
        "!type": "fn() -> AdWordsApp.ShoppingAdGroup"
      },
      "getCampaign": {
        "!type": "fn() -> AdWordsApp.ShoppingCampaign"
      },
      "getEntityType": {
        "!type": "fn() -> string"
      },
      "getId": {
        "!type": "fn() -> number"
      },
      "getMaxCpc": {
        "!type": "fn() -> number"
      },
      "getStatsFor": {
        "!type": "fn(dateFrom: object, dateTo: object) -> AdWordsApp.Stats"
      },
      "getStatsFor ": {
        "!type": "fn(dateRange: string) -> AdWordsApp.Stats"
      },
      "getType": {
        "!type": "fn() -> string"
      },
      "getValue": {
        "!type": "fn() -> string"
      },
      "hasChildren": {
        "!type": "fn() -> bool"
      },
      "include": {
        "!type": "fn()"
      },
      "isExcluded": {
        "!type": "fn() -> bool"
      },
      "isOtherCase": {
        "!type": "fn() -> bool"
      },
      "newChild": {
        "!type": "fn() -> AdWordsApp.ProductGroupBuilderSpace"
      },
      "parent": {
        "!type": "fn() -> AdWordsApp.ProductGroup"
      },
      "remove": {
        "!type": "fn()"
      },
      "removeAllChildren": {
        "!type": "fn()"
      },
      "setMaxCpc": {
        "!type": "fn(maxCpc: number)"
      }
    },
    "AdWordsApp.ProductCustomLabelBuilder": {
      "build": {
        "!type": "fn() -> AdWordsApp.ProductCustomLabelOperation"
      },
      "withBid": {
        "!type": "fn(bid: number) -> AdWordsApp.ProductCustomLabelBuilder"
      },
      "withType": {
        "!type": "fn(type: string) -> AdWordsApp.ProductCustomLabelBuilder"
      },
      "withValue": {
        "!type": "fn(value: string) -> AdWordsApp.ProductCustomLabelBuilder"
      }
    },
    "AdWordsApp.ProductCustomLabelOperation": {
      "getErrors": {
        "!type": "fn() -> [string]"
      },
      "getResult": {
        "!type": "fn() -> AdWordsApp.ProductCustomLabel"
      },
      "isSuccessful": {
        "!type": "fn() -> bool"
      }
    },
    "AdWordsApp.ProductGroup": {
      "asBrand": {
        "!type": "fn() -> AdWordsApp.ProductBrand"
      },
      "asCategory": {
        "!type": "fn() -> AdWordsApp.ProductCategory"
      },
      "asChannel": {
        "!type": "fn() -> AdWordsApp.ProductChannel"
      },
      "asChannelExclusivity": {
        "!type": "fn() -> AdWordsApp.ProductChannelExclusivity"
      },
      "asCondition": {
        "!type": "fn() -> AdWordsApp.ProductCondition"
      },
      "asCustomLabel": {
        "!type": "fn() -> AdWordsApp.ProductCustomLabel"
      },
      "asItemId": {
        "!type": "fn() -> AdWordsApp.ProductItemId"
      },
      "asProductType": {
        "!type": "fn() -> AdWordsApp.ProductType"
      },
      "children": {
        "!type": "fn() -> AdWordsApp.ProductGroupSelector"
      },
      "exclude": {
        "!type": "fn()"
      },
      "getAdGroup": {
        "!type": "fn() -> AdWordsApp.ShoppingAdGroup"
      },
      "getCampaign": {
        "!type": "fn() -> AdWordsApp.ShoppingCampaign"
      },
      "getDimension": {
        "!type": "fn() -> string"
      },
      "getEntityType": {
        "!type": "fn() -> string"
      },
      "getId": {
        "!type": "fn() -> number"
      },
      "getMaxCpc": {
        "!type": "fn() -> number"
      },
      "getStatsFor": {
        "!type": "fn(dateFrom: object, dateTo: object) -> AdWordsApp.Stats"
      },
      "getStatsFor ": {
        "!type": "fn(dateRange: string) -> AdWordsApp.Stats"
      },
      "getValue": {
        "!type": "fn() -> string"
      },
      "hasChildren": {
        "!type": "fn() -> bool"
      },
      "include": {
        "!type": "fn()"
      },
      "isExcluded": {
        "!type": "fn() -> bool"
      },
      "isOtherCase": {
        "!type": "fn() -> bool"
      },
      "newChild": {
        "!type": "fn() -> AdWordsApp.ProductGroupBuilderSpace"
      },
      "parent": {
        "!type": "fn() -> AdWordsApp.ProductGroup"
      },
      "remove": {
        "!type": "fn()"
      },
      "removeAllChildren": {
        "!type": "fn()"
      },
      "setMaxCpc": {
        "!type": "fn(maxCpc: number)"
      }
    },
    "AdWordsApp.ProductGroupBuilderSpace": {
      "brandBuilder": {
        "!type": "fn() -> AdWordsApp.ProductBrandBuilder"
      },
      "categoryBuilder": {
        "!type": "fn() -> AdWordsApp.ProductCategoryBuilder"
      },
      "channelBuilder": {
        "!type": "fn() -> AdWordsApp.ProductChannelBuilder"
      },
      "channelExclusivityBuilder": {
        "!type": "fn() -> AdWordsApp.ProductChannelExclusivityBuilder"
      },
      "conditionBuilder": {
        "!type": "fn() -> AdWordsApp.ProductConditionBuilder"
      },
      "customLabelBuilder": {
        "!type": "fn() -> AdWordsApp.ProductCustomLabelBuilder"
      },
      "itemIdBuilder": {
        "!type": "fn() -> AdWordsApp.ProductItemIdBuilder"
      },
      "productTypeBuilder": {
        "!type": "fn() -> AdWordsApp.ProductTypeBuilder"
      }
    },
    "AdWordsApp.ProductGroupIterator": {
      "hasNext": {
        "!type": "fn() -> bool"
      },
      "next": {
        "!type": "fn() -> AdWordsApp.ProductGroup"
      },
      "totalNumEntities": {
        "!type": "fn() -> number"
      }
    },
    "AdWordsApp.ProductGroupSelector": {
      "forDateRange": {
        "!type": "fn(dateFrom: object, dateTo: object) -> AdWordsApp.ProductGroupSelector"
      },
      "forDateRange ": {
        "!type": "fn(dateRange: string) -> AdWordsApp.ProductGroupSelector"
      },
      "get": {
        "!type": "fn() -> AdWordsApp.ProductGroupIterator"
      },
      "orderBy": {
        "!type": "fn(orderBy: string) -> AdWordsApp.ProductGroupSelector"
      },
      "withCondition": {
        "!type": "fn(condition: string) -> AdWordsApp.ProductGroupSelector"
      },
      "withIds": {
        "!type": "fn(ids: [number]) -> AdWordsApp.ProductGroupSelector"
      },
      "withLimit": {
        "!type": "fn(limit: number) -> AdWordsApp.ProductGroupSelector"
      }
    },
    "AdWordsApp.ProductItemId": {
      "children": {
        "!type": "fn() -> AdWordsApp.ProductGroupSelector"
      },
      "exclude": {
        "!type": "fn()"
      },
      "getAdGroup": {
        "!type": "fn() -> AdWordsApp.ShoppingAdGroup"
      },
      "getCampaign": {
        "!type": "fn() -> AdWordsApp.ShoppingCampaign"
      },
      "getEntityType": {
        "!type": "fn() -> string"
      },
      "getId": {
        "!type": "fn() -> number"
      },
      "getMaxCpc": {
        "!type": "fn() -> number"
      },
      "getStatsFor": {
        "!type": "fn(dateFrom: object, dateTo: object) -> AdWordsApp.Stats"
      },
      "getStatsFor ": {
        "!type": "fn(dateRange: string) -> AdWordsApp.Stats"
      },
      "getValue": {
        "!type": "fn() -> string"
      },
      "hasChildren": {
        "!type": "fn() -> bool"
      },
      "include": {
        "!type": "fn()"
      },
      "isExcluded": {
        "!type": "fn() -> bool"
      },
      "isOtherCase": {
        "!type": "fn() -> bool"
      },
      "newChild": {
        "!type": "fn() -> AdWordsApp.ProductGroupBuilderSpace"
      },
      "parent": {
        "!type": "fn() -> AdWordsApp.ProductGroup"
      },
      "remove": {
        "!type": "fn()"
      },
      "removeAllChildren": {
        "!type": "fn()"
      },
      "setMaxCpc": {
        "!type": "fn(maxCpc: number)"
      }
    },
    "AdWordsApp.ProductItemIdBuilder": {
      "build": {
        "!type": "fn() -> AdWordsApp.ProductItemIdOperation"
      },
      "withBid": {
        "!type": "fn(bid: number) -> AdWordsApp.ProductItemIdBuilder"
      },
      "withValue": {
        "!type": "fn(value: string) -> AdWordsApp.ProductItemIdBuilder"
      }
    },
    "AdWordsApp.ProductItemIdOperation": {
      "getErrors": {
        "!type": "fn() -> [string]"
      },
      "getResult": {
        "!type": "fn() -> AdWordsApp.ProductItemId"
      },
      "isSuccessful": {
        "!type": "fn() -> bool"
      }
    },
    "AdWordsApp.ProductType": {
      "children": {
        "!type": "fn() -> AdWordsApp.ProductGroupSelector"
      },
      "exclude": {
        "!type": "fn()"
      },
      "getAdGroup": {
        "!type": "fn() -> AdWordsApp.ShoppingAdGroup"
      },
      "getCampaign": {
        "!type": "fn() -> AdWordsApp.ShoppingCampaign"
      },
      "getEntityType": {
        "!type": "fn() -> string"
      },
      "getId": {
        "!type": "fn() -> number"
      },
      "getMaxCpc": {
        "!type": "fn() -> number"
      },
      "getStatsFor": {
        "!type": "fn(dateFrom: object, dateTo: object) -> AdWordsApp.Stats"
      },
      "getStatsFor ": {
        "!type": "fn(dateRange: string) -> AdWordsApp.Stats"
      },
      "getType": {
        "!type": "fn() -> string"
      },
      "getValue": {
        "!type": "fn() -> string"
      },
      "hasChildren": {
        "!type": "fn() -> bool"
      },
      "include": {
        "!type": "fn()"
      },
      "isExcluded": {
        "!type": "fn() -> bool"
      },
      "isOtherCase": {
        "!type": "fn() -> bool"
      },
      "newChild": {
        "!type": "fn() -> AdWordsApp.ProductGroupBuilderSpace"
      },
      "parent": {
        "!type": "fn() -> AdWordsApp.ProductGroup"
      },
      "remove": {
        "!type": "fn()"
      },
      "removeAllChildren": {
        "!type": "fn()"
      },
      "setMaxCpc": {
        "!type": "fn(maxCpc: number)"
      }
    },
    "AdWordsApp.ProductTypeBuilder": {
      "build": {
        "!type": "fn() -> AdWordsApp.ProductTypeOperation"
      },
      "withBid": {
        "!type": "fn(bid: number) -> AdWordsApp.ProductTypeBuilder"
      },
      "withValue": {
        "!type": "fn(value: string) -> AdWordsApp.ProductTypeBuilder"
      }
    },
    "AdWordsApp.ProductTypeOperation": {
      "getErrors": {
        "!type": "fn() -> [string]"
      },
      "getResult": {
        "!type": "fn() -> AdWordsApp.ProductType"
      },
      "isSuccessful": {
        "!type": "fn() -> bool"
      }
    },
    "AdWordsApp.Report": {
      "exportToSheet": {
        "!type": "fn(sheet: Sheet)"
      },
      "getColumnHeader": {
        "!type": "fn(awqlColumnName: string) -> AdWordsApp.ReportColumnHeader"
      },
      "rows": {
        "!type": "fn() -> AdWordsApp.ReportRowIterator"
      }
    },
    "AdWordsApp.ReportColumnHeader": {
      "getAwqlColumnName": {
        "!type": "fn() -> string"
      },
      "getDisplayColumnName": {
        "!type": "fn() -> string"
      }
    },
    "AdWordsApp.ReportRow": {
      "formatForUpload": {
        "!type": "fn() -> object"
      }
    },
    "AdWordsApp.ReportRowIterator": {
      "hasNext": {
        "!type": "fn() -> bool"
      },
      "next": {
        "!type": "fn() -> AdWordsApp.ReportRow"
      }
    },
    "AdWordsApp.Review": {
      "getEndDate": {
        "!type": "fn() -> AdWordsApp.AdWordsDate"
      },
      "getEntityType": {
        "!type": "fn() -> string"
      },
      "getId": {
        "!type": "fn() -> number"
      },
      "getSchedules": {
        "!type": "fn() -> [AdWordsApp.ExtensionSchedule]"
      },
      "getSourceName": {
        "!type": "fn() -> string"
      },
      "getSourceUrl": {
        "!type": "fn() -> string"
      },
      "getStartDate": {
        "!type": "fn() -> AdWordsApp.AdWordsDate"
      },
      "getStatsFor": {
        "!type": "fn(dateFrom: object, dateTo: object) -> AdWordsApp.Stats"
      },
      "getStatsFor ": {
        "!type": "fn(dateRange: string) -> AdWordsApp.Stats"
      },
      "getText": {
        "!type": "fn() -> string"
      },
      "isExactlyQuoted": {
        "!type": "fn() -> bool"
      },
      "isMobilePreferred": {
        "!type": "fn() -> bool"
      },
      "setEndDate": {
        "!type": "fn(date: object)"
      },
      "setExactlyQuoted": {
        "!type": "fn(isExactlyQuoted: bool)"
      },
      "setMobilePreferred": {
        "!type": "fn(isMobilePreferred: bool)"
      },
      "setSchedules": {
        "!type": "fn(schedules: [AdWordsApp.ExtensionSchedule])"
      },
      "setSourceName": {
        "!type": "fn(sourceName: string)"
      },
      "setSourceUrl": {
        "!type": "fn(sourceUrl: string)"
      },
      "setStartDate": {
        "!type": "fn(date: object)"
      },
      "setText": {
        "!type": "fn(text: string)"
      }
    },
    "AdWordsApp.ReviewBuilder": {
      "build": {
        "!type": "fn() -> AdWordsApp.ReviewOperation"
      },
      "withEndDate": {
        "!type": "fn(date: object) -> AdWordsApp.ReviewBuilder"
      },
      "withExactlyQuoted": {
        "!type": "fn(isExactlyQuoted: bool) -> AdWordsApp.ReviewBuilder"
      },
      "withMobilePreferred": {
        "!type": "fn(isMobilePreferred: bool) -> AdWordsApp.ReviewBuilder"
      },
      "withSchedules": {
        "!type": "fn(schedules: [AdWordsApp.ExtensionSchedule]) -> AdWordsApp.ReviewBuilder"
      },
      "withSourceName": {
        "!type": "fn(sourceName: string) -> AdWordsApp.ReviewBuilder"
      },
      "withSourceUrl": {
        "!type": "fn(sourceUrl: string) -> AdWordsApp.ReviewBuilder"
      },
      "withStartDate": {
        "!type": "fn(date: object) -> AdWordsApp.ReviewBuilder"
      },
      "withText": {
        "!type": "fn(text: string) -> AdWordsApp.ReviewBuilder"
      }
    },
    "AdWordsApp.ReviewIterator": {
      "hasNext": {
        "!type": "fn() -> bool"
      },
      "next": {
        "!type": "fn() -> AdWordsApp.Review"
      },
      "totalNumEntities": {
        "!type": "fn() -> number"
      }
    },
    "AdWordsApp.ReviewOperation": {
      "getErrors": {
        "!type": "fn() -> [string]"
      },
      "getResult": {
        "!type": "fn() -> AdWordsApp.Review"
      },
      "isSuccessful": {
        "!type": "fn() -> bool"
      }
    },
    "AdWordsApp.ReviewSelector": {
      "forDateRange": {
        "!type": "fn(dateFrom: object, dateTo: object) -> AdWordsApp.ReviewSelector"
      },
      "forDateRange ": {
        "!type": "fn(dateRange: string) -> AdWordsApp.ReviewSelector"
      },
      "get": {
        "!type": "fn() -> AdWordsApp.ReviewIterator"
      },
      "orderBy": {
        "!type": "fn(orderBy: string) -> AdWordsApp.ReviewSelector"
      },
      "withCondition": {
        "!type": "fn(condition: string) -> AdWordsApp.ReviewSelector"
      },
      "withIds": {
        "!type": "fn(ids: [number]) -> AdWordsApp.ReviewSelector"
      },
      "withLimit": {
        "!type": "fn(limit: number) -> AdWordsApp.ReviewSelector"
      }
    },
    "AdWordsApp.SharedExcludedPlacement": {
      "getEntityType": {
        "!type": "fn() -> string"
      },
      "getExcludedPlacementList": {
        "!type": "fn() -> AdWordsApp.ExcludedPlacementList"
      },
      "getUrl": {
        "!type": "fn() -> string"
      },
      "remove": {
        "!type": "fn()"
      }
    },
    "AdWordsApp.SharedExcludedPlacementIterator": {
      "hasNext": {
        "!type": "fn() -> bool"
      },
      "next": {
        "!type": "fn() -> AdWordsApp.SharedExcludedPlacement"
      },
      "totalNumEntities": {
        "!type": "fn() -> number"
      }
    },
    "AdWordsApp.SharedExcludedPlacementSelector": {
      "get": {
        "!type": "fn() -> AdWordsApp.SharedExcludedPlacementIterator"
      },
      "orderBy": {
        "!type": "fn(orderBy: string) -> AdWordsApp.SharedExcludedPlacementSelector"
      },
      "withCondition": {
        "!type": "fn(condition: string) -> AdWordsApp.SharedExcludedPlacementSelector"
      },
      "withLimit": {
        "!type": "fn(limit: number) -> AdWordsApp.SharedExcludedPlacementSelector"
      }
    },
    "AdWordsApp.SharedNegativeKeyword": {
      "getEntityType": {
        "!type": "fn() -> string"
      },
      "getMatchType": {
        "!type": "fn() -> string"
      },
      "getNegativeKeywordList": {
        "!type": "fn() -> AdWordsApp.NegativeKeywordList"
      },
      "getText": {
        "!type": "fn() -> string"
      },
      "remove": {
        "!type": "fn()"
      }
    },
    "AdWordsApp.SharedNegativeKeywordIterator": {
      "hasNext": {
        "!type": "fn() -> bool"
      },
      "next": {
        "!type": "fn() -> AdWordsApp.SharedNegativeKeyword"
      },
      "totalNumEntities": {
        "!type": "fn() -> number"
      }
    },
    "AdWordsApp.SharedNegativeKeywordSelector": {
      "get": {
        "!type": "fn() -> AdWordsApp.SharedNegativeKeywordIterator"
      },
      "orderBy": {
        "!type": "fn(orderBy: string) -> AdWordsApp.SharedNegativeKeywordSelector"
      },
      "withCondition": {
        "!type": "fn(condition: string) -> AdWordsApp.SharedNegativeKeywordSelector"
      },
      "withLimit": {
        "!type": "fn(limit: number) -> AdWordsApp.SharedNegativeKeywordSelector"
      }
    },
    "AdWordsApp.ShoppingAdGroup": {
      "ads": {
        "!type": "fn() -> AdWordsApp.ProductAdSelector"
      },
      "applyLabel": {
        "!type": "fn(name: string)"
      },
      "bidding": {
        "!type": "fn() -> AdWordsApp.ShoppingAdGroupBidding"
      },
      "createNegativeKeyword": {
        "!type": "fn(keywordText: string)"
      },
      "createRootProductGroup": {
        "!type": "fn() -> Operation"
      },
      "enable": {
        "!type": "fn()"
      },
      "getCampaign": {
        "!type": "fn() -> AdWordsApp.ShoppingCampaign"
      },
      "getEntityType": {
        "!type": "fn() -> string"
      },
      "getId": {
        "!type": "fn() -> number"
      },
      "getMobileBidModifier": {
        "!type": "fn() -> number"
      },
      "getName": {
        "!type": "fn() -> string"
      },
      "getStatsFor": {
        "!type": "fn(dateFrom: object, dateTo: object) -> AdWordsApp.Stats"
      },
      "getStatsFor ": {
        "!type": "fn(dateRange: string) -> AdWordsApp.Stats"
      },
      "isEnabled": {
        "!type": "fn() -> bool"
      },
      "isPaused": {
        "!type": "fn() -> bool"
      },
      "isRemoved": {
        "!type": "fn() -> bool"
      },
      "labels": {
        "!type": "fn() -> AdWordsApp.LabelSelector"
      },
      "newAdBuilder": {
        "!type": "fn() -> AdWordsApp.ProductAdBuilder"
      },
      "pause": {
        "!type": "fn()"
      },
      "productGroups": {
        "!type": "fn() -> AdWordsApp.ProductGroupSelector"
      },
      "removeLabel": {
        "!type": "fn(name: string)"
      },
      "rootProductGroup": {
        "!type": "fn() -> AdWordsApp.ProductGroup"
      },
      "setMobileBidModifier": {
        "!type": "fn(modifier: number)"
      },
      "setName": {
        "!type": "fn(name: string)"
      }
    },
    "AdWordsApp.ShoppingAdGroupBidding": {
      "clearStrategy": {
        "!type": "fn()"
      },
      "getCpc": {
        "!type": "fn() -> number"
      },
      "getStrategy": {
        "!type": "fn() -> AdWordsApp.BiddingStrategy"
      },
      "getStrategySource": {
        "!type": "fn() -> string"
      },
      "getStrategyType": {
        "!type": "fn() -> string"
      },
      "setCpc": {
        "!type": "fn(cpc: number)"
      },
      "setStrategy": {
        "!type": "fn(biddingStrategy: BiddingStrategy)"
      },
      "setStrategy ": {
        "!type": "fn(biddingStrategy: string)"
      }
    },
    "AdWordsApp.ShoppingAdGroupBuilder": {
      "build": {
        "!type": "fn() -> AdWordsApp.ShoppingAdGroupOperation"
      },
      "withBiddingStrategy": {
        "!type": "fn(biddingStrategy: BiddingStrategy) -> AdWordsApp.ShoppingAdGroupBuilder"
      },
      "withBiddingStrategy ": {
        "!type": "fn(biddingStrategy: string) -> AdWordsApp.ShoppingAdGroupBuilder"
      },
      "withCpc": {
        "!type": "fn(cpc: number) -> AdWordsApp.ShoppingAdGroupBuilder"
      },
      "withName": {
        "!type": "fn(name: string) -> AdWordsApp.ShoppingAdGroupBuilder"
      },
      "withStatus": {
        "!type": "fn(status: string) -> AdWordsApp.ShoppingAdGroupBuilder"
      }
    },
    "AdWordsApp.ShoppingAdGroupIterator": {
      "hasNext": {
        "!type": "fn() -> bool"
      },
      "next": {
        "!type": "fn() -> AdWordsApp.ShoppingAdGroup"
      },
      "totalNumEntities": {
        "!type": "fn() -> number"
      }
    },
    "AdWordsApp.ShoppingAdGroupOperation": {
      "getErrors": {
        "!type": "fn() -> [string]"
      },
      "getResult": {
        "!type": "fn() -> AdWordsApp.ShoppingAdGroup"
      },
      "isSuccessful": {
        "!type": "fn() -> bool"
      }
    },
    "AdWordsApp.ShoppingAdGroupSelector": {
      "forDateRange": {
        "!type": "fn(dateFrom: object, dateTo: object) -> AdWordsApp.ShoppingAdGroupSelector"
      },
      "forDateRange ": {
        "!type": "fn(dateRange: string) -> AdWordsApp.ShoppingAdGroupSelector"
      },
      "get": {
        "!type": "fn() -> AdWordsApp.ShoppingAdGroupIterator"
      },
      "orderBy": {
        "!type": "fn(orderBy: string) -> AdWordsApp.ShoppingAdGroupSelector"
      },
      "withCondition": {
        "!type": "fn(condition: string) -> AdWordsApp.ShoppingAdGroupSelector"
      },
      "withIds": {
        "!type": "fn(ids: [number]) -> AdWordsApp.ShoppingAdGroupSelector"
      },
      "withLimit": {
        "!type": "fn(limit: number) -> AdWordsApp.ShoppingAdGroupSelector"
      }
    },
    "AdWordsApp.ShoppingCampaign": {
      "adGroups": {
        "!type": "fn() -> AdWordsApp.ShoppingAdGroupSelector"
      },
      "addAdSchedule": {
        "!type": "fn(adSchedule: object)"
      },
      "addAdSchedule ": {
        "!type": "fn(dayOfWeek: string, startHour: number, startMinute: number, endHour: number, endMinute: number, bidModifier: number)"
      },
      "addLocation": {
        "!type": "fn(locationId: number, bidModifier: number)"
      },
      "addLocation ": {
        "!type": "fn(location: object)"
      },
      "addProximity": {
        "!type": "fn(latitude: number, longitude: number, radius: number, radiusUnits: string, optArgs: object)"
      },
      "addProximity ": {
        "!type": "fn(proximity: object)"
      },
      "ads": {
        "!type": "fn() -> AdWordsApp.ProductAdSelector"
      },
      "applyLabel": {
        "!type": "fn(name: string)"
      },
      "bidding": {
        "!type": "fn() -> AdWordsApp.ShoppingCampaignBidding"
      },
      "createNegativeKeyword": {
        "!type": "fn(keywordText: string)"
      },
      "enable": {
        "!type": "fn()"
      },
      "excludeLocation": {
        "!type": "fn(locationOrId: object)"
      },
      "getAdRotationType": {
        "!type": "fn() -> string"
      },
      "getBiddingStrategyType": {
        "!type": "fn() -> string"
      },
      "getBudget": {
        "!type": "fn() -> AdWordsApp.Budget"
      },
      "getEndDate": {
        "!type": "fn() -> AdWordsApp.AdWordsDate"
      },
      "getEntityType": {
        "!type": "fn() -> string"
      },
      "getId": {
        "!type": "fn() -> number"
      },
      "getName": {
        "!type": "fn() -> string"
      },
      "getStartDate": {
        "!type": "fn() -> AdWordsApp.AdWordsDate"
      },
      "getStatsFor": {
        "!type": "fn(dateFrom: object, dateTo: object) -> AdWordsApp.Stats"
      },
      "getStatsFor ": {
        "!type": "fn(dateRange: string) -> AdWordsApp.Stats"
      },
      "isDeleted": {
        "!type": "fn() -> bool"
      },
      "isEnabled": {
        "!type": "fn() -> bool"
      },
      "isPaused": {
        "!type": "fn() -> bool"
      },
      "labels": {
        "!type": "fn() -> AdWordsApp.LabelSelector"
      },
      "negativeKeywords": {
        "!type": "fn() -> AdWordsApp.NegativeKeywordSelector"
      },
      "newAdGroupBuilder": {
        "!type": "fn() -> AdWordsApp.ShoppingAdGroupBuilder"
      },
      "pause": {
        "!type": "fn()"
      },
      "productGroups": {
        "!type": "fn() -> AdWordsApp.ProductGroupSelector"
      },
      "removeLabel": {
        "!type": "fn(name: string)"
      },
      "setAdRotationType": {
        "!type": "fn(adRotationType: string)"
      },
      "setEndDate": {
        "!type": "fn(date: object)"
      },
      "setName": {
        "!type": "fn(name: string)"
      },
      "setStartDate": {
        "!type": "fn(date: object)"
      },
      "targeting": {
        "!type": "fn() -> AdWordsApp.Targeting"
      }
    },
    "AdWordsApp.ShoppingCampaignBidding": {
      "getStrategy": {
        "!type": "fn() -> AdWordsApp.BiddingStrategy"
      },
      "getStrategySource": {
        "!type": "fn() -> string"
      },
      "getStrategyType": {
        "!type": "fn() -> string"
      },
      "setStrategy": {
        "!type": "fn(biddingStrategy: BiddingStrategy)"
      },
      "setStrategy ": {
        "!type": "fn(biddingStrategy: string)"
      }
    },
    "AdWordsApp.ShoppingCampaignIterator": {
      "hasNext": {
        "!type": "fn() -> bool"
      },
      "next": {
        "!type": "fn() -> AdWordsApp.ShoppingCampaign"
      },
      "totalNumEntities": {
        "!type": "fn() -> number"
      }
    },
    "AdWordsApp.ShoppingCampaignSelector": {
      "forDateRange": {
        "!type": "fn(dateFrom: object, dateTo: object) -> AdWordsApp.ShoppingCampaignSelector"
      },
      "forDateRange ": {
        "!type": "fn(dateRange: string) -> AdWordsApp.ShoppingCampaignSelector"
      },
      "get": {
        "!type": "fn() -> AdWordsApp.ShoppingCampaignIterator"
      },
      "orderBy": {
        "!type": "fn(orderBy: string) -> AdWordsApp.ShoppingCampaignSelector"
      },
      "withCondition": {
        "!type": "fn(condition: string) -> AdWordsApp.ShoppingCampaignSelector"
      },
      "withIds": {
        "!type": "fn(ids: [number]) -> AdWordsApp.ShoppingCampaignSelector"
      },
      "withLimit": {
        "!type": "fn(limit: number) -> AdWordsApp.ShoppingCampaignSelector"
      }
    },
    "AdWordsApp.Sitelink": {
      "clearDescription1": {
        "!type": "fn()"
      },
      "clearDescription2": {
        "!type": "fn()"
      },
      "clearLinkUrl": {
        "!type": "fn()"
      },
      "getDescription1": {
        "!type": "fn() -> string"
      },
      "getDescription2": {
        "!type": "fn() -> string"
      },
      "getEndDate": {
        "!type": "fn() -> AdWordsApp.AdWordsDate"
      },
      "getEntityType": {
        "!type": "fn() -> string"
      },
      "getId": {
        "!type": "fn() -> number"
      },
      "getLinkText": {
        "!type": "fn() -> string"
      },
      "getLinkUrl": {
        "!type": "fn() -> string"
      },
      "getSchedules": {
        "!type": "fn() -> [AdWordsApp.ExtensionSchedule]"
      },
      "getStartDate": {
        "!type": "fn() -> AdWordsApp.AdWordsDate"
      },
      "getStatsFor": {
        "!type": "fn(dateFrom: object, dateTo: object) -> AdWordsApp.Stats"
      },
      "getStatsFor ": {
        "!type": "fn(dateRange: string) -> AdWordsApp.Stats"
      },
      "isMobilePreferred": {
        "!type": "fn() -> bool"
      },
      "setDescription1": {
        "!type": "fn(description1: string)"
      },
      "setDescription2": {
        "!type": "fn(description2: string)"
      },
      "setEndDate": {
        "!type": "fn(date: object)"
      },
      "setLinkText": {
        "!type": "fn(linkText: string)"
      },
      "setLinkUrl": {
        "!type": "fn(linkUrl: string)"
      },
      "setMobilePreferred": {
        "!type": "fn(isMobilePreferred: bool)"
      },
      "setSchedules": {
        "!type": "fn(schedules: [AdWordsApp.ExtensionSchedule])"
      },
      "setStartDate": {
        "!type": "fn(date: object)"
      },
      "urls": {
        "!type": "fn() -> AdWordsApp.SitelinkUrls"
      }
    },
    "AdWordsApp.SitelinkBuilder": {
      "build": {
        "!type": "fn() -> AdWordsApp.SitelinkOperation"
      },
      "withCustomParameters": {
        "!type": "fn(customParameters: object) -> AdWordsApp.SitelinkBuilder"
      },
      "withDescription1": {
        "!type": "fn(description1: string) -> AdWordsApp.SitelinkBuilder"
      },
      "withDescription2": {
        "!type": "fn(description2: string) -> AdWordsApp.SitelinkBuilder"
      },
      "withEndDate": {
        "!type": "fn(date: object) -> AdWordsApp.SitelinkBuilder"
      },
      "withFinalUrl": {
        "!type": "fn(finalUrl: string) -> AdWordsApp.SitelinkBuilder"
      },
      "withLinkText": {
        "!type": "fn(linkText: string) -> AdWordsApp.SitelinkBuilder"
      },
      "withLinkUrl": {
        "!type": "fn(linkUrl: string) -> AdWordsApp.SitelinkBuilder"
      },
      "withMobileFinalUrl": {
        "!type": "fn(mobileFinalUrl: string) -> AdWordsApp.SitelinkBuilder"
      },
      "withMobilePreferred": {
        "!type": "fn(isMobilePreferred: bool) -> AdWordsApp.SitelinkBuilder"
      },
      "withSchedules": {
        "!type": "fn(schedules: [AdWordsApp.ExtensionSchedule]) -> AdWordsApp.SitelinkBuilder"
      },
      "withStartDate": {
        "!type": "fn(date: object) -> AdWordsApp.SitelinkBuilder"
      },
      "withTrackingTemplate": {
        "!type": "fn(trackingTemplate: string) -> AdWordsApp.SitelinkBuilder"
      }
    },
    "AdWordsApp.SitelinkIterator": {
      "hasNext": {
        "!type": "fn() -> bool"
      },
      "next": {
        "!type": "fn() -> AdWordsApp.Sitelink"
      },
      "totalNumEntities": {
        "!type": "fn() -> number"
      }
    },
    "AdWordsApp.SitelinkOperation": {
      "getErrors": {
        "!type": "fn() -> [string]"
      },
      "getResult": {
        "!type": "fn() -> AdWordsApp.Sitelink"
      },
      "isSuccessful": {
        "!type": "fn() -> bool"
      }
    },
    "AdWordsApp.SitelinkSelector": {
      "forDateRange": {
        "!type": "fn(dateFrom: object, dateTo: object) -> AdWordsApp.SitelinkSelector"
      },
      "forDateRange ": {
        "!type": "fn(dateRange: string) -> AdWordsApp.SitelinkSelector"
      },
      "get": {
        "!type": "fn() -> AdWordsApp.SitelinkIterator"
      },
      "orderBy": {
        "!type": "fn(orderBy: string) -> AdWordsApp.SitelinkSelector"
      },
      "withCondition": {
        "!type": "fn(condition: string) -> AdWordsApp.SitelinkSelector"
      },
      "withIds": {
        "!type": "fn(ids: [number]) -> AdWordsApp.SitelinkSelector"
      },
      "withLimit": {
        "!type": "fn(limit: number) -> AdWordsApp.SitelinkSelector"
      }
    },
    "AdWordsApp.SitelinkUrls": {
      "clearMobileFinalUrl": {
        "!type": "fn()"
      },
      "clearTrackingTemplate": {
        "!type": "fn()"
      },
      "getCustomParameters": {
        "!type": "fn() -> object"
      },
      "getFinalUrl": {
        "!type": "fn() -> string"
      },
      "getMobileFinalUrl": {
        "!type": "fn() -> string"
      },
      "getTrackingTemplate": {
        "!type": "fn() -> string"
      },
      "setCustomParameters": {
        "!type": "fn(customParameters: object)"
      },
      "setFinalUrl": {
        "!type": "fn(finalUrl: string)"
      },
      "setMobileFinalUrl": {
        "!type": "fn(mobileFinalUrl: string)"
      },
      "setTrackingTemplate": {
        "!type": "fn(trackingTemplate: string)"
      }
    },
    "AdWordsApp.Stats": {
      "getAverageCpc": {
        "!type": "fn() -> number"
      },
      "getAverageCpm": {
        "!type": "fn() -> number"
      },
      "getAveragePageviews": {
        "!type": "fn() -> number"
      },
      "getAveragePosition": {
        "!type": "fn() -> number"
      },
      "getAverageTimeOnSite": {
        "!type": "fn() -> number"
      },
      "getBounceRate": {
        "!type": "fn() -> number"
      },
      "getClickConversionRate": {
        "!type": "fn() -> number"
      },
      "getClicks": {
        "!type": "fn() -> number"
      },
      "getConversionRate": {
        "!type": "fn() -> number"
      },
      "getConversions": {
        "!type": "fn() -> number"
      },
      "getConvertedClicks": {
        "!type": "fn() -> number"
      },
      "getCost": {
        "!type": "fn() -> number"
      },
      "getCtr": {
        "!type": "fn() -> number"
      },
      "getImpressions": {
        "!type": "fn() -> number"
      }
    },
    "AdWordsApp.String": {
      "charAt": {
        "!type": "fn(index: number) -> string"
      },
      "charCodeAt": {
        "!type": "fn(index: number) -> number"
      },
      "concat": {
        "!type": "fn(string2: string) -> string"
      },
      "fromCharCode": {
        "!type": "fn(code: number) -> string"
      },
      "indexOf": {
        "!type": "fn(searchString: string, start: number) -> number"
      },
      "lastIndexOf": {
        "!type": "fn(searchString: string, start: number) -> number"
      },
      "match": {
        "!type": "fn(regexp: RegExp) -> AdWordsApp.Array"
      },
      "replace": {
        "!type": "fn(regexp: RegExp, newString: string) -> string"
      },
      "replace ": {
        "!type": "fn(subString: string, newString: string) -> string"
      },
      "search": {
        "!type": "fn(regexp: RegExp) -> number"
      },
      "slice": {
        "!type": "fn(begin: number) -> string"
      },
      "slice ": {
        "!type": "fn(begin: number, end: number) -> string"
      },
      "split": {
        "!type": "fn(separator: string) -> AdWordsApp.Array"
      },
      "split ": {
        "!type": "fn(separator: string, limit: number) -> AdWordsApp.Array"
      },
      "substr": {
        "!type": "fn(start: number) -> string"
      },
      "substr ": {
        "!type": "fn(start: number, length: number) -> string"
      },
      "substring": {
        "!type": "fn(from: number) -> string"
      },
      "substring ": {
        "!type": "fn(from: number, to: number) -> string"
      },
      "toLowerCase": {
        "!type": "fn() -> string"
      },
      "toUpperCase": {
        "!type": "fn() -> string"
      }
    },
    "AdWordsApp.TargetedLocation": {
      "getBidModifier": {
        "!type": "fn() -> number"
      },
      "getCampaign": {
        "!type": "fn() -> AdWordsApp.Campaign"
      },
      "getCountryCode": {
        "!type": "fn() -> string"
      },
      "getEntityType": {
        "!type": "fn() -> string"
      },
      "getId": {
        "!type": "fn() -> number"
      },
      "getName": {
        "!type": "fn() -> string"
      },
      "getStatsFor": {
        "!type": "fn(dateFrom: object, dateTo: object) -> AdWordsApp.Stats"
      },
      "getStatsFor ": {
        "!type": "fn(dateRange: string) -> AdWordsApp.Stats"
      },
      "getTargetType": {
        "!type": "fn() -> string"
      },
      "getTargetingStatus": {
        "!type": "fn() -> string"
      },
      "remove": {
        "!type": "fn()"
      },
      "setBidModifier": {
        "!type": "fn(modifier: number)"
      }
    },
    "AdWordsApp.TargetedLocationIterator": {
      "hasNext": {
        "!type": "fn() -> bool"
      },
      "next": {
        "!type": "fn() -> AdWordsApp.TargetedLocation"
      },
      "totalNumEntities": {
        "!type": "fn() -> number"
      }
    },
    "AdWordsApp.TargetedLocationSelector": {
      "forDateRange": {
        "!type": "fn(dateFrom: object, dateTo: object) -> AdWordsApp.TargetedLocationSelector"
      },
      "forDateRange ": {
        "!type": "fn(dateRange: string) -> AdWordsApp.TargetedLocationSelector"
      },
      "get": {
        "!type": "fn() -> AdWordsApp.TargetedLocationIterator"
      },
      "orderBy": {
        "!type": "fn(orderBy: string) -> AdWordsApp.TargetedLocationSelector"
      },
      "withCondition": {
        "!type": "fn(condition: string) -> AdWordsApp.TargetedLocationSelector"
      },
      "withIds": {
        "!type": "fn(ids: [number]) -> AdWordsApp.TargetedLocationSelector"
      },
      "withLimit": {
        "!type": "fn(limit: number) -> AdWordsApp.TargetedLocationSelector"
      }
    },
    "AdWordsApp.TargetedProximity": {
      "getAddress": {
        "!type": "fn() -> AdWordsApp.Address"
      },
      "getBidModifier": {
        "!type": "fn() -> number"
      },
      "getCampaign": {
        "!type": "fn() -> AdWordsApp.Campaign"
      },
      "getEntityType": {
        "!type": "fn() -> string"
      },
      "getId": {
        "!type": "fn() -> number"
      },
      "getLatitude": {
        "!type": "fn() -> number"
      },
      "getLongitude": {
        "!type": "fn() -> number"
      },
      "getRadius": {
        "!type": "fn() -> number"
      },
      "getRadiusUnits": {
        "!type": "fn() -> string"
      },
      "getStatsFor": {
        "!type": "fn(dateFrom: object, dateTo: object) -> AdWordsApp.Stats"
      },
      "getStatsFor ": {
        "!type": "fn(dateRange: string) -> AdWordsApp.Stats"
      },
      "remove": {
        "!type": "fn()"
      },
      "setBidModifier": {
        "!type": "fn(modifier: number)"
      }
    },
    "AdWordsApp.TargetedProximityIterator": {
      "hasNext": {
        "!type": "fn() -> bool"
      },
      "next": {
        "!type": "fn() -> AdWordsApp.TargetedProximity"
      },
      "totalNumEntities": {
        "!type": "fn() -> number"
      }
    },
    "AdWordsApp.TargetedProximitySelector": {
      "forDateRange": {
        "!type": "fn(dateFrom: object, dateTo: object) -> AdWordsApp.TargetedProximitySelector"
      },
      "forDateRange ": {
        "!type": "fn(dateRange: string) -> AdWordsApp.TargetedProximitySelector"
      },
      "get": {
        "!type": "fn() -> AdWordsApp.TargetedProximityIterator"
      },
      "orderBy": {
        "!type": "fn(orderBy: string) -> AdWordsApp.TargetedProximitySelector"
      },
      "withCondition": {
        "!type": "fn(condition: string) -> AdWordsApp.TargetedProximitySelector"
      },
      "withIds": {
        "!type": "fn(ids: [number]) -> AdWordsApp.TargetedProximitySelector"
      },
      "withLimit": {
        "!type": "fn(limit: number) -> AdWordsApp.TargetedProximitySelector"
      }
    },
    "AdWordsApp.Targeting": {
      "adSchedules": {
        "!type": "fn() -> AdWordsApp.AdScheduleSelector"
      },
      "excludedLocations": {
        "!type": "fn() -> AdWordsApp.ExcludedLocationSelector"
      },
      "platforms": {
        "!type": "fn() -> AdWordsApp.PlatformSelector"
      },
      "targetedLocations": {
        "!type": "fn() -> AdWordsApp.TargetedLocationSelector"
      },
      "targetedProximities": {
        "!type": "fn() -> AdWordsApp.TargetedProximitySelector"
      }
    },
    "AdWordsApp.Topic": {
      "bidding": {
        "!type": "fn() -> AdWordsApp.TopicBidding"
      },
      "getAdGroup": {
        "!type": "fn() -> AdWordsApp.AdGroup"
      },
      "getCampaign": {
        "!type": "fn() -> AdWordsApp.Campaign"
      },
      "getId": {
        "!type": "fn() -> number"
      },
      "getStatsFor": {
        "!type": "fn(dateFrom: object, dateTo: object) -> AdWordsApp.Stats"
      },
      "getStatsFor ": {
        "!type": "fn(dateRange: string) -> AdWordsApp.Stats"
      },
      "getTopicId": {
        "!type": "fn() -> number"
      },
      "isEnabled": {
        "!type": "fn() -> bool"
      },
      "isPaused": {
        "!type": "fn() -> bool"
      },
      "remove": {
        "!type": "fn()"
      }
    },
    "AdWordsApp.TopicBidding": {
      "clearCpc": {
        "!type": "fn()"
      },
      "clearCpm": {
        "!type": "fn()"
      },
      "getCpc": {
        "!type": "fn() -> number"
      },
      "getCpm": {
        "!type": "fn() -> number"
      },
      "getStrategy": {
        "!type": "fn() -> AdWordsApp.BiddingStrategy"
      },
      "getStrategySource": {
        "!type": "fn() -> string"
      },
      "getStrategyType": {
        "!type": "fn() -> string"
      },
      "setCpc": {
        "!type": "fn(cpc: number)"
      },
      "setCpm": {
        "!type": "fn(cpm: number)"
      }
    },
    "AdWordsApp.TopicBuilder": {
      "build": {
        "!type": "fn() -> AdWordsApp.TopicOperation"
      },
      "exclude": {
        "!type": "fn() -> AdWordsApp.ExcludedTopicOperation"
      },
      "withCpc": {
        "!type": "fn(cpc: number) -> AdWordsApp.TopicBuilder"
      },
      "withCpm": {
        "!type": "fn(cpm: number) -> AdWordsApp.TopicBuilder"
      },
      "withTopicId": {
        "!type": "fn(topicId: number) -> AdWordsApp.TopicBuilder"
      }
    },
    "AdWordsApp.TopicIterator": {
      "hasNext": {
        "!type": "fn() -> bool"
      },
      "next": {
        "!type": "fn() -> AdWordsApp.Topic"
      },
      "totalNumEntities": {
        "!type": "fn() -> number"
      }
    },
    "AdWordsApp.TopicOperation": {
      "getErrors": {
        "!type": "fn() -> [string]"
      },
      "getResult": {
        "!type": "fn() -> AdWordsApp.Topic"
      },
      "isSuccessful": {
        "!type": "fn() -> bool"
      }
    },
    "AdWordsApp.TopicSelector": {
      "forDateRange": {
        "!type": "fn(dateFrom: object, dateTo: object) -> AdWordsApp.TopicSelector"
      },
      "forDateRange ": {
        "!type": "fn(dateRange: string) -> AdWordsApp.TopicSelector"
      },
      "get": {
        "!type": "fn() -> AdWordsApp.TopicIterator"
      },
      "orderBy": {
        "!type": "fn(orderBy: string) -> AdWordsApp.TopicSelector"
      },
      "withCondition": {
        "!type": "fn(condition: string) -> AdWordsApp.TopicSelector"
      },
      "withIds": {
        "!type": "fn(ids: [number]) -> AdWordsApp.TopicSelector"
      },
      "withLimit": {
        "!type": "fn(limit: number) -> AdWordsApp.TopicSelector"
      }
    },
    "XmlService.Attribute": {
      "getName": {
        "!type": "fn() -> string",
        "!doc": "Gets the local name of the attribute. If the attribute has a namespace prefix, use\n getNamespace().getPrefix() to get the prefix."
      },
      "getNamespace": {
        "!type": "fn() -> XmlService.Namespace",
        "!doc": "Gets the namespace for the attribute."
      },
      "getValue": {
        "!type": "fn() -> string",
        "!doc": "Gets the value of the attribute."
      },
      "setName": {
        "!type": "fn(name: string) -> XmlService.Attribute",
        "!doc": "Sets the local name of the attribute. To set a namespace prefix for the attribute, use\n setNamespace(namespace) in conjunction with\n XmlService.getNamespace(prefix, uri)."
      },
      "setNamespace": {
        "!type": "fn(namespace: XmlService.Namespace) -> XmlService.Attribute",
        "!doc": "Sets the namespace for the attribute. The namespace must have a prefix."
      },
      "setValue": {
        "!type": "fn(value: string) -> XmlService.Attribute",
        "!doc": "Sets the value of the attribute."
      }
    },
    "XmlService.Cdata": {
      "append": {
        "!type": "fn(text: string) -> XmlService.Text",
        "!doc": "Appends the given text to any content that already exists in the node."
      },
      "detach": {
        "!type": "fn() -> XmlService.Content",
        "!doc": "Detaches the node from its parent Element node. If the node does not have a parent,\n this method has no effect."
      },
      "getParentElement": {
        "!type": "fn() -> XmlService.Element",
        "!doc": "Gets the node's parent Element node. If the node does not have a parent, this method\n returns null."
      },
      "getText": {
        "!type": "fn() -> string",
        "!doc": "Gets the text value of the Text node."
      },
      "getValue": {
        "!type": "fn() -> string",
        "!doc": "Gets the text value of all nodes that are direct or indirect children of the node, in the order\n they appear in the document."
      },
      "setText": {
        "!type": "fn(text: string) -> XmlService.Text",
        "!doc": "Sets the text value of the Text node."
      }
    },
    "XmlService.Comment": {
      "detach": {
        "!type": "fn() -> XmlService.Content",
        "!doc": "Detaches the node from its parent Element node. If the node does not have a parent,\n this method has no effect."
      },
      "getParentElement": {
        "!type": "fn() -> XmlService.Element",
        "!doc": "Gets the node's parent Element node. If the node does not have a parent, this method\n returns null."
      },
      "getText": {
        "!type": "fn() -> string",
        "!doc": "Gets the text value of the Comment node."
      },
      "getValue": {
        "!type": "fn() -> string",
        "!doc": "Gets the text value of all nodes that are direct or indirect children of the node, in the order\n they appear in the document."
      },
      "setText": {
        "!type": "fn(text: string) -> XmlService.Comment",
        "!doc": "Sets the text value of the Comment node."
      }
    },
    "XmlService.Content": {
      "asCdata": {
        "!type": "fn() -> XmlService.Cdata",
        "!doc": "Casts the node as a CDATASection node for the purposes of autocomplete. If the\n node's ContentType is not already CDATA, this method returns null."
      },
      "asComment": {
        "!type": "fn() -> XmlService.Comment",
        "!doc": "Casts the node as a Comment node for the purposes of autocomplete. If the node's\n ContentType is not already COMMENT, this method returns null."
      },
      "asDocType": {
        "!type": "fn() -> XmlService.DocType",
        "!doc": "Casts the node as a DocumentType node for the purposes of autocomplete. If\n the node's ContentType is not already DOCTYPE, this method returns\n null."
      },
      "asElement": {
        "!type": "fn() -> XmlService.Element",
        "!doc": "Casts the node as an Element node for the purposes of autocomplete. If the node's\n ContentType is not already ELEMENT, this method returns null."
      },
      "asEntityRef": {
        "!type": "fn() -> XmlService.EntityRef",
        "!doc": "Casts the node as a EntityReference node for the purposes of autocomplete.\n If the node's ContentType is not already ENTITYREF, this method returns\n null."
      },
      "asProcessingInstruction": {
        "!type": "fn() -> XmlService.ProcessingInstruction",
        "!doc": "Casts the node as a ProcessingInstruction node for the purposes of autocomplete. If\n the node's ContentType is not already PROCESSINGINSTRUCTION, this method\n returns null."
      },
      "asText": {
        "!type": "fn() -> XmlService.Text",
        "!doc": "Casts the node as a Text node for the purposes of autocomplete. If the node's\n ContentType is not already TEXT, this method returns null."
      },
      "detach": {
        "!type": "fn() -> XmlService.Content",
        "!doc": "Detaches the node from its parent Element node. If the node does not have a parent,\n this method has no effect."
      },
      "getParentElement": {
        "!type": "fn() -> XmlService.Element",
        "!doc": "Gets the node's parent Element node. If the node does not have a parent, this method\n returns null."
      },
      "getType": {
        "!type": "fn() -> XmlService.ContentType",
        "!doc": "Gets the node's content type."
      },
      "getValue": {
        "!type": "fn() -> string",
        "!doc": "Gets the text value of all nodes that are direct or indirect children of the node, in the order\n they appear in the document."
      }
    },
    "XmlService.ContentType": {
      "CDATA": {
        "!type": "XmlService.ContentType",
        "!doc": "An XML CDATASection node."
      },
      "COMMENT": {
        "!type": "XmlService.ContentType",
        "!doc": "An XML Comment node."
      },
      "DOCTYPE": {
        "!type": "XmlService.ContentType",
        "!doc": "An XML DocumentType node."
      },
      "ELEMENT": {
        "!type": "XmlService.ContentType",
        "!doc": "An XML Element node."
      },
      "ENTITYREF": {
        "!type": "XmlService.ContentType",
        "!doc": "An XML EntityReference node."
      },
      "PROCESSINGINSTRUCTION": {
        "!type": "XmlService.ContentType",
        "!doc": "An XML ProcessingInstruction node."
      },
      "TEXT": {
        "!type": "XmlService.ContentType",
        "!doc": "An XML Text node."
      }
    },
    "XmlService.DocType": {
      "detach": {
        "!type": "fn() -> XmlService.Content",
        "!doc": "Detaches the node from its parent Element node. If the node does not have a parent,\n this method has no effect."
      },
      "getElementName": {
        "!type": "fn() -> string",
        "!doc": "Gets the name of the root Element node specified in the DocType declaration."
      },
      "getInternalSubset": {
        "!type": "fn() -> string",
        "!doc": "Gets the internal subset data for the DocumentType node."
      },
      "getParentElement": {
        "!type": "fn() -> XmlService.Element",
        "!doc": "Gets the node's parent Element node. If the node does not have a parent, this method\n returns null."
      },
      "getPublicId": {
        "!type": "fn() -> string",
        "!doc": "Gets the public ID of the external subset data for the DocumentType node."
      },
      "getSystemId": {
        "!type": "fn() -> string",
        "!doc": "Gets the system ID of the external subset data for the DocumentType node."
      },
      "getValue": {
        "!type": "fn() -> string",
        "!doc": "Gets the text value of all nodes that are direct or indirect children of the node, in the order\n they appear in the document."
      },
      "setElementName": {
        "!type": "fn(name: string) -> XmlService.DocType",
        "!doc": "Sets the name of the root Element node to specify in the DocType\n declaration."
      },
      "setInternalSubset": {
        "!type": "fn(data: string) -> XmlService.DocType",
        "!doc": "Sets the internal subset data for the DocumentType node."
      },
      "setPublicId": {
        "!type": "fn(id: string) -> XmlService.DocType",
        "!doc": "Sets the public ID of the external subset data for the DocumentType node."
      },
      "setSystemId": {
        "!type": "fn(id: string) -> XmlService.DocType",
        "!doc": "Sets the system ID of the external subset data for the DocumentType node."
      }
    },
    "XmlService.Document": {
      "addContent": {
        "!type": "fn(index: number, content: XmlService.Content) -> XmlService.Document",
        "!doc": "Inserts the given node at the given index among all nodes that are immediate children of the\n document. The content argument can be a Content object or any node object\n that corresponds to a type listed in ContentType. Note, however, that a document\n can only have one child Element node, which is implicitly the root Element\n node."
      },
      "addContent ": {
        "!type": "fn(content: XmlService.Content) -> XmlService.Document",
        "!doc": "Appends the given node to the end of the document. The content argument can be a\n Content object or any node object that corresponds to a type listed in \n ContentType. Note, however, that a document can only have one child\n Element node, which is implicitly the root Element node."
      },
      "cloneContent": {
        "!type": "fn() -> [XmlService.Content]",
        "!doc": "Creates unattached copies of all nodes that are immediate children of the document."
      },
      "detachRootElement": {
        "!type": "fn() -> XmlService.Element",
        "!doc": "Detaches and returns the document's root Element node. If the document does not have\n a root Element node, this method returns null."
      },
      "getAllContent": {
        "!type": "fn() -> [XmlService.Content]",
        "!doc": "Gets all nodes that are immediate children of the document."
      },
      "getContent": {
        "!type": "fn(index: number) -> XmlService.Content",
        "!doc": "Gets the node at the given index among all nodes that are immediate children of the\n document. If there is no node at the given index, this method returns null."
      },
      "getContentSize": {
        "!type": "fn() -> number",
        "!doc": "Gets the number of nodes that are immediate children of the document."
      },
      "getDescendants": {
        "!type": "fn() -> [XmlService.Content]",
        "!doc": "Gets all nodes that are direct or indirect children of the document, in the order they\n appear in the document."
      },
      "getDocType": {
        "!type": "fn() -> XmlService.DocType",
        "!doc": "Gets the document's DocType declaration. If the document does not have a\n DocumentType node, this method returns null."
      },
      "getRootElement": {
        "!type": "fn() -> XmlService.Element",
        "!doc": "Gets the document's root Element node. If the document does not have a root\n Element node, this method returns null."
      },
      "hasRootElement": {
        "!type": "fn() -> bool",
        "!doc": "Determines whether the document has a root Element node."
      },
      "removeContent": {
        "!type": "fn() -> [XmlService.Content]",
        "!doc": "Removes all nodes that are immediate children of the document."
      },
      "removeContent ": {
        "!type": "fn(index: number) -> XmlService.Content",
        "!doc": "Removes the node at the given index among all nodes that are immediate children of the\n document. If there is no node at the given index, this method returns null."
      },
      "removeContent  ": {
        "!type": "fn(content: XmlService.Content) -> bool",
        "!doc": "Removes the given node, if the node is an immediate child of the document. The\n content argument can be a Content object or any node object that corresponds\n to a type listed in ContentType."
      },
      "setDocType": {
        "!type": "fn(docType: XmlService.DocType) -> XmlService.Document",
        "!doc": "Sets the document's DocType declaration. If the document already has a different\n DocType node, this method overwrites the old node. This method throws an exception if\n the document already contains the same DocType node that is being set."
      },
      "setRootElement": {
        "!type": "fn(element: XmlService.Element) -> XmlService.Document",
        "!doc": "Sets the document's root Element node. If the document already has a root\n Element node, this method overwrites the old node."
      }
    },
    "XmlService.Element": {
      "addContent": {
        "!type": "fn(index: number, content: XmlService.Content) -> XmlService.Element",
        "!doc": "Inserts the given node at the given index among all nodes that are immediate children of the\n Element node. The content argument can be a Element object or any\n node object that corresponds to a type listed in ContentType."
      },
      "addContent ": {
        "!type": "fn(content: XmlService.Content) -> XmlService.Element",
        "!doc": "Appends the given node as the last child of the Element node. The content\n argument can be a Element object or any node object that corresponds to a type\n listed in ContentType."
      },
      "cloneContent": {
        "!type": "fn() -> [XmlService.Content]",
        "!doc": "Creates unattached copies of all nodes that are immediate children of the {@code Element} node."
      },
      "detach": {
        "!type": "fn() -> XmlService.Content",
        "!doc": "Detaches the node from its parent Element node. If the node does not have a parent,\n this method has no effect."
      },
      "getAllContent": {
        "!type": "fn() -> [XmlService.Content]",
        "!doc": "Gets all nodes that are immediate children of the {@code Element} node."
      },
      "getAttribute": {
        "!type": "fn(name: string) -> XmlService.Attribute",
        "!doc": "Gets the attribute for this Element node with the given name and no namespace. If there\n is no such attribute, this method returns null."
      },
      "getAttribute ": {
        "!type": "fn(name: string, namespace: XmlService.Namespace) -> XmlService.Attribute",
        "!doc": "Gets the attribute for this Element node with the given name and namespace. If there is\n no such node, this method returns null."
      },
      "getAttributes": {
        "!type": "fn() -> [XmlService.Attribute]",
        "!doc": "Gets all attributes for this Element node, in the order they appear in the document."
      },
      "getChild": {
        "!type": "fn(name: string) -> XmlService.Element",
        "!doc": "Gets the first Element node with the given name and no namespace that is an immediate\n child of this Element node. If there is no such node, this method returns null."
      },
      "getChild ": {
        "!type": "fn(name: string, namespace: XmlService.Namespace) -> XmlService.Element",
        "!doc": "Gets the first Element node with the given name and namespace that is an immediate\n child of this Element node. If there is no such node, this method returns null."
      },
      "getChildText": {
        "!type": "fn(name: string) -> string",
        "!doc": "Gets the text value of the node with the given name and no namespace, if the node is an\n immediate child of the Element node. If there is no such node, this method returns\n null."
      },
      "getChildText ": {
        "!type": "fn(name: string, namespace: XmlService.Namespace) -> string",
        "!doc": "Gets the text value of the node with the given name and namespace, if the node is an immediate\n child of the Element node. If there is no such node, this method returns null."
      },
      "getChildren": {
        "!type": "fn() -> [XmlService.Element]",
        "!doc": "Gets all Element nodes that are immediate children of this Element node, in the\n order they appear in the document."
      },
      "getChildren ": {
        "!type": "fn(name: string) -> [XmlService.Element]",
        "!doc": "Gets all Element nodes with the given name and no namespace that are immediate children\n of this Element node, in the order they appear in the document."
      },
      "getChildren  ": {
        "!type": "fn(name: string, namespace: XmlService.Namespace) -> [XmlService.Element]",
        "!doc": "Gets all Element nodes with the given name and namespace that are immediate children of\n this Element node, in the order they appear in the document."
      },
      "getContent": {
        "!type": "fn(index: number) -> XmlService.Content",
        "!doc": "Gets the node at the given index among all nodes that are immediate children of the\n {@code Element} node. If there is no node at the given index, this method returns null."
      },
      "getContentSize": {
        "!type": "fn() -> number",
        "!doc": "Gets the number of nodes that are immediate children of the {@code Element} node."
      },
      "getDescendants": {
        "!type": "fn() -> [XmlService.Content]",
        "!doc": "Gets all nodes that are direct or indirect children of the {@code Element} node, in the order they\n appear in the document."
      },
      "getDocument": {
        "!type": "fn() -> XmlService.Document",
        "!doc": "Gets the XML document that contains the {@code Element} node."
      },
      "getName": {
        "!type": "fn() -> string",
        "!doc": "Gets the local name of the Element node. If the node has a namespace prefix, use\n getQualifiedName() or\n getNamespace().getPrefix() to get the prefix."
      },
      "getNamespace": {
        "!type": "fn() -> XmlService.Namespace",
        "!doc": "Gets the namespace for the Element node."
      },
      "getNamespace ": {
        "!type": "fn(prefix: string) -> XmlService.Namespace",
        "!doc": "Gets the namespace with the given prefix for the Element node."
      },
      "getParentElement": {
        "!type": "fn() -> XmlService.Element",
        "!doc": "Gets the node's parent Element node. If the node does not have a parent, this method\n returns null."
      },
      "getQualifiedName": {
        "!type": "fn() -> string",
        "!doc": "Gets the local name and namespace prefix of the Element node, in the form\n [namespacePrefix]:[localName]. If the node does not have a namespace prefix, use\n getName()."
      },
      "getText": {
        "!type": "fn() -> string",
        "!doc": "Gets the text value of the Element node."
      },
      "getValue": {
        "!type": "fn() -> string",
        "!doc": "Gets the text value of all nodes that are direct or indirect children of the node, in the order\n they appear in the document."
      },
      "isAncestorOf": {
        "!type": "fn(other: XmlService.Element) -> bool",
        "!doc": "Determines whether this Element node is a direct or indirect parent of a given\n Element node."
      },
      "isRootElement": {
        "!type": "fn() -> bool",
        "!doc": "Determines whether the Element node is the document's root node."
      },
      "removeAttribute": {
        "!type": "fn(attributeName: string) -> bool",
        "!doc": "Removes the attribute for this Element node with the given name and no namespace, if\n such an attribute exists."
      },
      "removeAttribute ": {
        "!type": "fn(attributeName: string, namespace: XmlService.Namespace) -> bool",
        "!doc": "Removes the attribute for this Element node with the given name and namespace, if such\n an attribute exists."
      },
      "removeAttribute  ": {
        "!type": "fn(attribute: XmlService.Attribute) -> bool",
        "!doc": "Removes the given attribute for this Element node, if such an attribute exists."
      },
      "removeContent": {
        "!type": "fn() -> [XmlService.Content]",
        "!doc": "Removes all nodes that are immediate children of the {@code Element} node."
      },
      "removeContent ": {
        "!type": "fn(index: number) -> XmlService.Content",
        "!doc": "Removes the node at the given index among all nodes that are immediate children of the\n {@code Element} node. If there is no node at the given index, this method returns null."
      },
      "removeContent  ": {
        "!type": "fn(content: XmlService.Content) -> bool",
        "!doc": "Removes the given node, if the node is an immediate child of the {@code Element} node. The\n content argument can be a Element object or any node object that corresponds\n to a type listed in ContentType."
      },
      "setAttribute": {
        "!type": "fn(name: string, value: string) -> XmlService.Element",
        "!doc": "Sets the attribute for this Element node with the given name, value, and no namespace."
      },
      "setAttribute ": {
        "!type": "fn(name: string, value: string, namespace: XmlService.Namespace) -> XmlService.Element",
        "!doc": "Sets the attribute for this Element node with the given name, value, and namespace."
      },
      "setAttribute  ": {
        "!type": "fn(attribute: XmlService.Attribute) -> XmlService.Element",
        "!doc": "Sets the given attribute for this Element node."
      },
      "setName": {
        "!type": "fn(name: string) -> XmlService.Element",
        "!doc": "Sets the local name of the Element node. To set a namespace prefix for the node, use\n setNamespace(namespace) in conjunction with\n XmlService.getNamespace(prefix, uri)."
      },
      "setNamespace": {
        "!type": "fn(namespace: XmlService.Namespace) -> XmlService.Element",
        "!doc": "Sets the namespace for the Element node."
      },
      "setText": {
        "!type": "fn(text: string) -> XmlService.Element",
        "!doc": "Sets the text value of the Element node. If the node already contains a text value or\n any child nodes, this method overwrites the old content. To append or insert content instead,\n use addContent(content) or addContent(index, content)."
      }
    },
    "XmlService.EntityRef": {
      "detach": {
        "!type": "fn() -> XmlService.Content",
        "!doc": "Detaches the node from its parent Element node. If the node does not have a parent,\n this method has no effect."
      },
      "getName": {
        "!type": "fn() -> string",
        "!doc": "Gets the name of the EntityReference node."
      },
      "getParentElement": {
        "!type": "fn() -> XmlService.Element",
        "!doc": "Gets the node's parent Element node. If the node does not have a parent, this method\n returns null."
      },
      "getPublicId": {
        "!type": "fn() -> string",
        "!doc": "Gets the public ID of the EntityReference node. If the node does not have a public ID,\n this method returns null."
      },
      "getSystemId": {
        "!type": "fn() -> string",
        "!doc": "Gets the system ID of the EntityReference node. If the node does not have a system ID,\n this method returns null."
      },
      "getValue": {
        "!type": "fn() -> string",
        "!doc": "Gets the text value of all nodes that are direct or indirect children of the node, in the order\n they appear in the document."
      },
      "setName": {
        "!type": "fn(name: string) -> XmlService.EntityRef",
        "!doc": "Sets the name of the EntityReference node."
      },
      "setPublicId": {
        "!type": "fn(id: string) -> XmlService.EntityRef",
        "!doc": "Sets the public ID of the EntityReference node."
      },
      "setSystemId": {
        "!type": "fn(id: string) -> XmlService.EntityRef",
        "!doc": "Sets the system ID of the EntityReference node."
      }
    },
    "XmlService.Format": {
      "format": {
        "!type": "fn(document: XmlService.Document) -> string",
        "!doc": "Outputs the given Document as a formatted string."
      },
      "format ": {
        "!type": "fn(element: XmlService.Element) -> string",
        "!doc": "Outputs the given Element node as a formatted string."
      },
      "setEncoding": {
        "!type": "fn(encoding: string) -> XmlService.Format",
        "!doc": "Sets the character encoding that the formatter should use. The encoding argument must\n be an accepted XML encoding like ISO-8859-1, US-ASCII, UTF-8, or\n UTF-16.\n\n \n \n // Log an XML document with encoding that does not support certain special characters.\n var xml = &#39;&lt;root&gt;&lt;a&gt;&lt;b&gt;???&lt;/b&gt;&lt;b&gt;???&lt;/b&gt;&lt;/a&gt;&lt;/root&gt;&#39;;\n var document = XmlService.parse(xml);\n var output = XmlService.getRawFormat()\n     .setEncoding(&#39;ISO-8859-1&#39;)\n     .format(document);\n Logger.log(output);\n "
      },
      "setIndent": {
        "!type": "fn(indent: string) -> XmlService.Format",
        "!doc": "Sets the string used to indent child nodes relative to their parents. Setting an indent other\n than null will cause the formatter to insert a line break after every node.\n\n \n \n // Log an XML document with each child node indented four spaces.\n var xml = &#39;&lt;root&gt;&lt;a&gt;&lt;b&gt;Text!&lt;/b&gt;&lt;b&gt;More text!&lt;/b&gt;&lt;/a&gt;&lt;/root&gt;&#39;;\n var document = XmlService.parse(xml);\n var output = XmlService.getCompactFormat()\n     .setIndent(&#39;    &#39;)\n     .format(document);\n Logger.log(output);\n "
      },
      "setLineSeparator": {
        "!type": "fn(separator: string) -> XmlService.Format",
        "!doc": "Sets the string to insert whenever the formatter would normally insert a line break. The three\n pre-defined formatters have different conditions under which they insert a line break. The\n default line separator is \\r\\n.\n\n \n \n // Log an XML document with several spaces and a pipe character in place of line breaks.\n var xml = &#39;&lt;root&gt;&lt;a&gt;&lt;b&gt;Text!&lt;/b&gt;&lt;b&gt;More text!&lt;/b&gt;&lt;/a&gt;&lt;/root&gt;&#39;;\n var document = XmlService.parse(xml);\n var output = XmlService.getRawFormat()\n     .setLineSeparator(&#39; | &#39;)\n     .format(document);\n Logger.log(output);\n "
      },
      "setOmitDeclaration": {
        "!type": "fn(omitDeclaration: bool) -> XmlService.Format",
        "!doc": "Sets whether the formatter should omit the XML declaration, such as\n &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;."
      },
      "setOmitEncoding": {
        "!type": "fn(omitEncoding: bool) -> XmlService.Format",
        "!doc": "Sets whether the formatter should omit the encoding in the XML declaration,\n such as the encoding field in &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;."
      }
    },
    "XmlService.Namespace": {
      "getPrefix": {
        "!type": "fn() -> string",
        "!doc": "Gets the prefix for the namespace."
      },
      "getURI": {
        "!type": "fn() -> string",
        "!doc": "Gets the URI for the namespace."
      }
    },
    "XmlService.ProcessingInstruction": {
      "detach": {
        "!type": "fn() -> XmlService.Content",
        "!doc": "Detaches the node from its parent Element node. If the node does not have a parent,\n this method has no effect."
      },
      "getData": {
        "!type": "fn() -> string",
        "!doc": "Gets the raw data for every instruction in the ProcessingInstruction node."
      },
      "getParentElement": {
        "!type": "fn() -> XmlService.Element",
        "!doc": "Gets the node's parent Element node. If the node does not have a parent, this method\n returns null."
      },
      "getTarget": {
        "!type": "fn() -> string",
        "!doc": "Gets the target for the ProcessingInstruction node."
      },
      "getValue": {
        "!type": "fn() -> string",
        "!doc": "Gets the text value of all nodes that are direct or indirect children of the node, in the order\n they appear in the document."
      }
    },
    "XmlService.Text": {
      "append": {
        "!type": "fn(text: string) -> XmlService.Text",
        "!doc": "Appends the given text to any content that already exists in the node."
      },
      "detach": {
        "!type": "fn() -> XmlService.Content",
        "!doc": "Detaches the node from its parent Element node. If the node does not have a parent,\n this method has no effect."
      },
      "getParentElement": {
        "!type": "fn() -> XmlService.Element",
        "!doc": "Gets the node's parent Element node. If the node does not have a parent, this method\n returns null."
      },
      "getText": {
        "!type": "fn() -> string",
        "!doc": "Gets the text value of the Text node."
      },
      "getValue": {
        "!type": "fn() -> string",
        "!doc": "Gets the text value of all nodes that are direct or indirect children of the node, in the order\n they appear in the document."
      },
      "setText": {
        "!type": "fn(text: string) -> XmlService.Text",
        "!doc": "Sets the text value of the Text node."
      }
    },
    "DriveApp.Access": {
      "ANYONE": {
        "!type": "DriveApp.Access",
        "!doc": "Anyone on the Internet can find and access. No sign-in required.\n\n Domain administrators can prohibit this setting for users of Google Apps for Business,\n Google Apps for Education, or Google Apps for Your Domain. If the setting is disabled, passing\n this value to File.setSharing(accessType, permissionType) throws an exception."
      },
      "ANYONE_WITH_LINK": {
        "!type": "DriveApp.Access",
        "!doc": "Anyone who has the link can access. No sign-in required.\n\n Domain administrators can prohibit this setting for users of Google Apps for Business,\n Google Apps for Education, or Google Apps for Your Domain. If the setting is disabled, passing\n this value to File.setSharing(accessType, permissionType) throws an exception."
      },
      "DOMAIN": {
        "!type": "DriveApp.Access",
        "!doc": "People in your domain can find and access. Sign-in required.\n\n This setting is available only for users of Google Apps for Business, Google Apps for\n Education, or Google Apps for Your Domain. For other types of Google accounts, passing this\n value to File.setSharing(accessType, permissionType) throws an exception."
      },
      "DOMAIN_WITH_LINK": {
        "!type": "DriveApp.Access",
        "!doc": "People in your domain who have the link can access. Sign-in required.\n\n This setting is available only for users of Google Apps for Business, Google Apps for\n Education, or Google Apps for Your Domain. For other types of Google accounts, passing this\n value to File.setSharing(accessType, permissionType) throws an exception."
      },
      "PRIVATE": {
        "!type": "DriveApp.Access",
        "!doc": "Only people explicitly granted permission can access. Sign-in required."
      }
    },
    "DriveApp.File": {
      "addCommenter": {
        "!type": "fn(emailAddress: string) -> DriveApp.File",
        "!doc": "Add the given user to the list of commenters for the File. If the user was\n already on the list of viewers, this method promotes the user out of the list of viewers."
      },
      "addCommenter ": {
        "!type": "fn(user: User) -> DriveApp.File",
        "!doc": "Add the given user to the list of commenters for the File. If the user was\n already on the list of viewers, this method promotes the user out of the list of viewers."
      },
      "addCommenters": {
        "!type": "fn(emailAddresses: [string]) -> DriveApp.File",
        "!doc": "Add the given array of users to the list of commenters for the File. If any\n of the users were already on the list of viewers, this method promotes them out of the list of\n viewers."
      },
      "addEditor": {
        "!type": "fn(emailAddress: string) -> DriveApp.File",
        "!doc": "Adds the given user to the list of editors for the File. If the user was already\n on the list of viewers, this method promotes the user out of the list of viewers."
      },
      "addEditor ": {
        "!type": "fn(user: User) -> DriveApp.File",
        "!doc": "Adds the given user to the list of editors for the File. If the user was already\n on the list of viewers, this method promotes the user out of the list of viewers."
      },
      "addEditors": {
        "!type": "fn(emailAddresses: [string]) -> DriveApp.File",
        "!doc": "Adds the given array of users to the list of editors for the File. If any of the\n users were already on the list of viewers, this method promotes them out of the list of\n viewers."
      },
      "addViewer": {
        "!type": "fn(emailAddress: string) -> DriveApp.File",
        "!doc": "Adds the given user to the list of viewers for the File. If the user was already\n on the list of editors, this method has no effect."
      },
      "addViewer ": {
        "!type": "fn(user: User) -> DriveApp.File",
        "!doc": "Adds the given user to the list of viewers for the File. If the user was already\n on the list of editors, this method has no effect."
      },
      "addViewers": {
        "!type": "fn(emailAddresses: [string]) -> DriveApp.File",
        "!doc": "Adds the given array of users to the list of viewers for the File. If any of the\n users were already on the list of editors, this method has no effect for them."
      },
      "getAccess": {
        "!type": "fn(email: string) -> DriveApp.Permission",
        "!doc": "Gets the permission granted to the given user."
      },
      "getAccess ": {
        "!type": "fn(user: User) -> DriveApp.Permission",
        "!doc": "Gets the permission granted to the given user."
      },
      "getAs": {
        "!type": "fn(contentType: string) -> Blob",
        "!doc": "Return the data inside this object as a blob converted to the specified content type. This\n method adds the appropriate extension to the filename ? for example, \"myfile.pdf\". However, it\n assumes that the part of the filename that follows the last period (if any) is an existing\n extension that should be replaced. Consequently, \"ChristmasList.12.25.2014\" will become\n \"ChristmasList.12.25.pdf\"."
      },
      "getBlob": {
        "!type": "fn() -> Blob",
        "!doc": "Return the data inside this object as a blob."
      },
      "getDateCreated": {
        "!type": "fn() -> Date",
        "!doc": "Gets the date the File was created."
      },
      "getDescription": {
        "!type": "fn() -> string",
        "!doc": "Gets the description for the File."
      },
      "getDownloadUrl": {
        "!type": "fn() -> string",
        "!doc": "Gets the URL that can be used to download the file. Only users with permission to open the\n file in Google Drive can access the URL."
      },
      "getEditors": {
        "!type": "fn() -> [DriveApp.User]",
        "!doc": "Gets the list of editors for this File. If the user who executes the script\n does not have edit access to the File, this method returns an empty array."
      },
      "getId": {
        "!type": "fn() -> string",
        "!doc": "Gets the ID of the File."
      },
      "getLastUpdated": {
        "!type": "fn() -> Date",
        "!doc": "Gets the date the File was last updated."
      },
      "getMimeType": {
        "!type": "fn() -> string",
        "!doc": "Gets the MIME type of the file."
      },
      "getName": {
        "!type": "fn() -> string",
        "!doc": "Gets the name of the File."
      },
      "getOwner": {
        "!type": "fn() -> DriveApp.User",
        "!doc": "Gets the owner of the File."
      },
      "getParents": {
        "!type": "fn() -> DriveApp.FolderIterator",
        "!doc": "Gets a collection of folders that are immediate parents of the File."
      },
      "getSharingAccess": {
        "!type": "fn() -> DriveApp.Access",
        "!doc": "Gets which class of users can access the File, besides any individual\n users who have been explicitly given access."
      },
      "getSharingPermission": {
        "!type": "fn() -> DriveApp.Permission",
        "!doc": "Gets the permission granted to those users who can access the File,\n besides any individual users who have been explicitly given access."
      },
      "getSize": {
        "!type": "fn() -> number",
        "!doc": "Gets the number of bytes used to store the File in Drive. Note that\n Google Apps files do not count toward Drive storage limits and thus return 0 bytes."
      },
      "getThumbnail": {
        "!type": "fn() -> Blob",
        "!doc": "Gets a thumbnail image for the file, or null if no thumbnail exists."
      },
      "getUrl": {
        "!type": "fn() -> string",
        "!doc": "Gets the URL that can be used to open the File in a Google App like\n Drive or Docs."
      },
      "getViewers": {
        "!type": "fn() -> [DriveApp.User]",
        "!doc": "Gets the list of viewers and commenters for this File.  If the user who\n executes the script does not have edit access to the File, this method\n returns an empty array."
      },
      "isShareableByEditors": {
        "!type": "fn() -> bool",
        "!doc": "Determines whether users with edit permissions to the File are allowed to\n share with other users or change the permissions."
      },
      "isStarred": {
        "!type": "fn() -> bool",
        "!doc": "Determines whether the File has been starred in the user's Drive."
      },
      "isTrashed": {
        "!type": "fn() -> bool",
        "!doc": "Determines whether the File is in the trash of the user's Drive."
      },
      "makeCopy": {
        "!type": "fn() -> DriveApp.File",
        "!doc": "Creates a copy of the file."
      },
      "makeCopy ": {
        "!type": "fn(destination: DriveApp.Folder) -> DriveApp.File",
        "!doc": "Creates a copy of the file in the destination directory."
      },
      "makeCopy  ": {
        "!type": "fn(name: string) -> DriveApp.File",
        "!doc": "Creates a copy of the file and names it with the name provided."
      },
      "makeCopy   ": {
        "!type": "fn(name: string, destination: DriveApp.Folder) -> DriveApp.File",
        "!doc": "Creates a copy of the file in the destination directory and names it with the name provided."
      },
      "removeCommenter": {
        "!type": "fn(emailAddress: string) -> DriveApp.File",
        "!doc": "Removes the given user from the list of commenters for the File.  This method\n does not block users from access the File if they belong to a class of users\n who have general access ? for example, if the File is shared with the user's\n entire domain."
      },
      "removeCommenter ": {
        "!type": "fn(user: User) -> DriveApp.File",
        "!doc": "Removes the given user from the list of commenters for the File.  This method\n does not block users from access the File if they belong to a class of users\n who have general access ? for example, if the File is shared with the user's\n entire domain."
      },
      "removeEditor": {
        "!type": "fn(emailAddress: string) -> DriveApp.File",
        "!doc": "Removes the given user from the list of editors for the File. This method does not\n block users from accessing the File if they belong to a class of users who have\n general access ? for example, if the File is shared with the user's entire domain."
      },
      "removeEditor ": {
        "!type": "fn(user: User) -> DriveApp.File",
        "!doc": "Removes the given user from the list of editors for the File. This method does not\n block users from accessing the File if they belong to a class of users who have\n general access ? for example, if the File is shared with the user's entire domain."
      },
      "removeViewer": {
        "!type": "fn(emailAddress: string) -> DriveApp.File",
        "!doc": "Removes the given user from the list of viewers and commenters for the File.  This\n method has no effect if the user is an editor, not a viewer or commenter. This method also does\n not block users from accessing the File if they belong to a class of users who\n have general access ? for example, if the File is shared with the user's entire\n domain."
      },
      "removeViewer ": {
        "!type": "fn(user: User) -> DriveApp.File",
        "!doc": "Removes the given user from the list of viewers and commenters for the File.  This\n method has no effect if the user is an editor, not a viewer. This method also does not block\n users from accessing the File if they belong to a class of users who have general\n access ? for example, if the File is shared with the user's entire domain."
      },
      "revokePermissions": {
        "!type": "fn(user: string) -> DriveApp.File",
        "!doc": "Revokes the access to the File granted to the given user. This method does\n not block users from accessing the File if they belong to a class of users\n who have general access ? for example, if the File is shared with the user's\n entire domain."
      },
      "revokePermissions ": {
        "!type": "fn(user: User) -> DriveApp.File",
        "!doc": "Revokes the access to the File granted to the given user. This method does\n not block users from accessing the File if they belong to a class of users\n who have general access ? for example, if the File is shared with the user's\n entire domain."
      },
      "setContent": {
        "!type": "fn(content: string) -> DriveApp.File",
        "!doc": "Overwrites the content of the file with a given replacement. Throws an exception if\n content is larger than 10MB.\n\n Beware: this change is irreversible."
      },
      "setDescription": {
        "!type": "fn(description: string) -> DriveApp.File",
        "!doc": "Sets the description for the File."
      },
      "setName": {
        "!type": "fn(name: string) -> DriveApp.File",
        "!doc": "Sets the name of the File."
      },
      "setOwner": {
        "!type": "fn(emailAddress: string) -> DriveApp.File",
        "!doc": "Changes the owner of the File. This method also gives the previous owner\n explicit edit access to the File."
      },
      "setOwner ": {
        "!type": "fn(user: User) -> DriveApp.File",
        "!doc": "Changes the owner of the File. This method also gives the previous owner\n explicit edit access to the File."
      },
      "setShareableByEditors": {
        "!type": "fn(shareable: bool) -> DriveApp.File",
        "!doc": "Sets whether users with edit permissions to the File are allowed to share\n with other users or change the permissions. The default for a new File is\n true."
      },
      "setSharing": {
        "!type": "fn(accessType: DriveApp.Access, permissionType: DriveApp.Permission) -> DriveApp.File",
        "!doc": "Sets which class of users can access the File and what permissions\n those users are granted, besides any individual users who have been explicitly given access.\n\n \n // Creates a folder that anyone on the Internet can read from and write to. (Domain\n // administrators can prohibit this setting for users of Google Apps for Business, Google Apps\n // for Education, or Google Apps for Your Domain.)\n var folder = DriveApp.createFolder('Shared Folder');\n folder.setSharing(DriveApp.Access.ANYONE, DriveApp.Permission.EDIT);\n "
      },
      "setStarred": {
        "!type": "fn(starred: bool) -> DriveApp.File",
        "!doc": "Sets whether the File is starred in the user's Drive. The default for\n new Files is false."
      },
      "setTrashed": {
        "!type": "fn(trashed: bool) -> DriveApp.File",
        "!doc": "Sets whether the File is in the trash of the user's Drive. The default\n for new Files is false."
      }
    },
    "DriveApp.FileIterator": {
      "getContinuationToken": {
        "!type": "fn() -> string",
        "!doc": "Gets a token that can be used to resume this iteration at a later time. This method is\n useful if processing an iterator in one execution would exceed the maximum execution\n time. Continuation tokens are generally valid for one week."
      },
      "hasNext": {
        "!type": "fn() -> bool",
        "!doc": "Determines whether calling next() will return an item."
      },
      "next": {
        "!type": "fn() -> DriveApp.File",
        "!doc": "Gets the next item in the collection of files or folders. Throws an exception if no items\n remain."
      }
    },
    "DriveApp.Folder": {
      "addEditor": {
        "!type": "fn(emailAddress: string) -> DriveApp.Folder",
        "!doc": "Adds the given user to the list of editors for the Folder. If the user was already\n on the list of viewers, this method promotes the user out of the list of viewers."
      },
      "addEditor ": {
        "!type": "fn(user: User) -> DriveApp.Folder",
        "!doc": "Adds the given user to the list of editors for the Folder. If the user was already\n on the list of viewers, this method promotes the user out of the list of viewers."
      },
      "addEditors": {
        "!type": "fn(emailAddresses: [string]) -> DriveApp.Folder",
        "!doc": "Adds the given array of users to the list of editors for the Folder. If any of the\n users were already on the list of viewers, this method promotes them out of the list of\n viewers."
      },
      "addFile": {
        "!type": "fn(child: DriveApp.File) -> DriveApp.Folder",
        "!doc": "Adds the given file to the current folder. This method does not move the file out of its\n existing parent folder; a file can have more than one parent simultaneously."
      },
      "addFolder": {
        "!type": "fn(child: DriveApp.Folder) -> DriveApp.Folder",
        "!doc": "Adds the given folder to the current folder. This method does not move the folder out of\n its existing parent folder; a folder can have more than one parent simultaneously."
      },
      "addViewer": {
        "!type": "fn(emailAddress: string) -> DriveApp.Folder",
        "!doc": "Adds the given user to the list of viewers for the Folder. If the user was already\n on the list of editors, this method has no effect."
      },
      "addViewer ": {
        "!type": "fn(user: User) -> DriveApp.Folder",
        "!doc": "Adds the given user to the list of viewers for the Folder. If the user was already\n on the list of editors, this method has no effect."
      },
      "addViewers": {
        "!type": "fn(emailAddresses: [string]) -> DriveApp.Folder",
        "!doc": "Adds the given array of users to the list of viewers for the Folder. If any of the\n users were already on the list of editors, this method has no effect for them."
      },
      "createFile": {
        "!type": "fn(blob: BlobSource) -> DriveApp.File",
        "!doc": "Creates a file in the current folder from a given Blob of arbitrary data.\n\n \n // Create an image file in Google Drive using the Maps service.\n var blob = Maps.newStaticMap().setCenter('76 9th Avenue, New York NY').getBlob();\n DriveApp.getRootFolder().createFile(blob);\n "
      },
      "createFile ": {
        "!type": "fn(name: string, content: string) -> DriveApp.File",
        "!doc": "Creates a text file in the current folder with the given name and contents. Throws an\n exception if content is larger than 10MB.\n\n \n // Create a text file with the content \"Hello, world!\"\n DriveApp.getRootFolder().createFile('New Text File', 'Hello, world!');\n "
      },
      "createFile  ": {
        "!type": "fn(name: string, content: string, mimeType: string) -> DriveApp.File",
        "!doc": "Creates a file in the current folder with the given name, contents, and MIME type. Throws\n an exception if content is larger than 10MB.\n\n \n \n // Create an HTML file with the content &quot;Hello, world!&quot;\n DriveApp.getRootFolder().createFile(&#39;New HTML File&#39;, &#39;&lt;b&gt;Hello, world!&lt;/b&gt;&#39;, MimeType.HTML);\n \n "
      },
      "createFolder": {
        "!type": "fn(name: string) -> DriveApp.Folder",
        "!doc": "Creates a folder in the current folder with the given name."
      },
      "getAccess": {
        "!type": "fn(email: string) -> DriveApp.Permission",
        "!doc": "Gets the permission granted to the given user."
      },
      "getAccess ": {
        "!type": "fn(user: User) -> DriveApp.Permission",
        "!doc": "Gets the permission granted to the given user."
      },
      "getDateCreated": {
        "!type": "fn() -> Date",
        "!doc": "Gets the date the Folder was created."
      },
      "getDescription": {
        "!type": "fn() -> string",
        "!doc": "Gets the description for the Folder."
      },
      "getEditors": {
        "!type": "fn() -> [DriveApp.User]",
        "!doc": "Gets the list of editors for this Folder. If the user who executes the script\n does not have edit access to the Folder, this method returns an empty array."
      },
      "getFiles": {
        "!type": "fn() -> DriveApp.FileIterator",
        "!doc": "Gets a collection of all files that are children of the current folder."
      },
      "getFilesByName": {
        "!type": "fn(name: string) -> DriveApp.FileIterator",
        "!doc": "Gets a collection of all files that are children of the current folder and have the given name."
      },
      "getFilesByType": {
        "!type": "fn(mimeType: string) -> DriveApp.FileIterator",
        "!doc": "Gets a collection of all files that are children of the current folder and have the given MIME type."
      },
      "getFolders": {
        "!type": "fn() -> DriveApp.FolderIterator",
        "!doc": "Gets a collection of all folders that are children of the current folder."
      },
      "getFoldersByName": {
        "!type": "fn(name: string) -> DriveApp.FolderIterator",
        "!doc": "Gets a collection of all folders that are children of the current folder and have the given name."
      },
      "getId": {
        "!type": "fn() -> string",
        "!doc": "Gets the ID of the Folder."
      },
      "getLastUpdated": {
        "!type": "fn() -> Date",
        "!doc": "Gets the date the Folder was last updated."
      },
      "getName": {
        "!type": "fn() -> string",
        "!doc": "Gets the name of the Folder."
      },
      "getOwner": {
        "!type": "fn() -> DriveApp.User",
        "!doc": "Gets the owner of the Folder."
      },
      "getParents": {
        "!type": "fn() -> DriveApp.FolderIterator",
        "!doc": "Gets a collection of folders that are immediate parents of the Folder."
      },
      "getSharingAccess": {
        "!type": "fn() -> DriveApp.Access",
        "!doc": "Gets which class of users can access the Folder, besides any individual\n users who have been explicitly given access."
      },
      "getSharingPermission": {
        "!type": "fn() -> DriveApp.Permission",
        "!doc": "Gets the permission granted to those users who can access the Folder,\n besides any individual users who have been explicitly given access."
      },
      "getSize": {
        "!type": "fn() -> number",
        "!doc": "Gets the number of bytes used to store the Folder in Drive. Note that\n Google Apps files do not count toward Drive storage limits and thus return 0 bytes."
      },
      "getUrl": {
        "!type": "fn() -> string",
        "!doc": "Gets the URL that can be used to open the Folder in a Google App like\n Drive or Docs."
      },
      "getViewers": {
        "!type": "fn() -> [DriveApp.User]",
        "!doc": "Gets the list of viewers and commenters for this Folder.  If the user who\n executes the script does not have edit access to the Folder, this method\n returns an empty array."
      },
      "isShareableByEditors": {
        "!type": "fn() -> bool",
        "!doc": "Determines whether users with edit permissions to the Folder are allowed to\n share with other users or change the permissions."
      },
      "isStarred": {
        "!type": "fn() -> bool",
        "!doc": "Determines whether the Folder has been starred in the user's Drive."
      },
      "isTrashed": {
        "!type": "fn() -> bool",
        "!doc": "Determines whether the Folder is in the trash of the user's Drive."
      },
      "removeEditor": {
        "!type": "fn(emailAddress: string) -> DriveApp.Folder",
        "!doc": "Removes the given user from the list of editors for the Folder. This method does not\n block users from accessing the Folder if they belong to a class of users who have\n general access ? for example, if the Folder is shared with the user's entire domain."
      },
      "removeEditor ": {
        "!type": "fn(user: User) -> DriveApp.Folder",
        "!doc": "Removes the given user from the list of editors for the Folder. This method does not\n block users from accessing the Folder if they belong to a class of users who have\n general access ? for example, if the Folder is shared with the user's entire domain."
      },
      "removeFile": {
        "!type": "fn(child: DriveApp.File) -> DriveApp.Folder",
        "!doc": "Removes the given file from the current folder. This method does not delete the file, but\n if a file is removed from all of its parents, it cannot be seen in Drive except by searching\n for it or using the \"All items\" view."
      },
      "removeFolder": {
        "!type": "fn(child: DriveApp.Folder) -> DriveApp.Folder",
        "!doc": "Removes the given folder from the current folder. This method does not delete the folder\n or its contents, but if a folder is removed from all of its parents, it cannot be seen in Drive\n except by searching for it or using the \"All items\" view."
      },
      "removeViewer": {
        "!type": "fn(emailAddress: string) -> DriveApp.Folder",
        "!doc": "Removes the given user from the list of viewers and commenters for the Folder.  This\n method has no effect if the user is an editor, not a viewer or commenter. This method also does\n not block users from accessing the Folder if they belong to a class of users who\n have general access ? for example, if the Folder is shared with the user's entire\n domain."
      },
      "removeViewer ": {
        "!type": "fn(user: User) -> DriveApp.Folder",
        "!doc": "Removes the given user from the list of viewers and commenters for the Folder.  This\n method has no effect if the user is an editor, not a viewer. This method also does not block\n users from accessing the Folder if they belong to a class of users who have general\n access ? for example, if the Folder is shared with the user's entire domain."
      },
      "revokePermissions": {
        "!type": "fn(user: string) -> DriveApp.Folder",
        "!doc": "Revokes the access to the Folder granted to the given user. This method does\n not block users from accessing the Folder if they belong to a class of users\n who have general access ? for example, if the Folder is shared with the user's\n entire domain."
      },
      "revokePermissions ": {
        "!type": "fn(user: User) -> DriveApp.Folder",
        "!doc": "Revokes the access to the Folder granted to the given user. This method does\n not block users from accessing the Folder if they belong to a class of users\n who have general access ? for example, if the Folder is shared with the user's\n entire domain."
      },
      "searchFiles": {
        "!type": "fn(params: string) -> DriveApp.FileIterator",
        "!doc": "Gets a collection of all files that are children of the current folder and match the given search\n criteria. The search criteria are detailed the Google Drive\n SDK documentation. Note that the params argument is a query string that may\n contain string values, so take care to escape quotation marks correctly (for example\n &quot;title contains &#39;Gulliver\\\\&#39;s Travels&#39;&quot; or &#39;title contains &quot;Gulliver\\&#39;s\n Travels&quot;&#39;).\n\n \n // Log the name of every file that are children of the current folder and modified after February 28,\n // 2013 whose name contains \"untitled\".\n var files = DriveApp.getRootFolder().searchFiles(\n     'modifiedDate > \"2013-02-28\" and title contains \"untitled\"');\n while (files.hasNext()) {\n   var file = files.next();\n   Logger.log(file.getName());\n }\n "
      },
      "searchFolders": {
        "!type": "fn(params: string) -> DriveApp.FolderIterator",
        "!doc": "Gets a collection of all folders that are children of the current folder and match the given search\n criteria. The search criteria are detailed the Google Drive\n SDK documentation. Note that the params argument is a query string that may\n contain string values, so take care to escape quotation marks correctly (for example\n &quot;title contains &#39;Gulliver\\\\&#39;s Travels&#39;&quot; or &#39;title contains &quot;Gulliver\\&#39;s\n Travels&quot;&#39;).\n\n \n // Log the name of every folder that are children of the current folder and you own and is starred.\n var folders = DriveApp.getRootFolder().searchFolders('starred = true and \"me\" in owners');\n while (folders.hasNext()) {\n   var folder = folders.next();\n   Logger.log(folder.getName());\n }\n "
      },
      "setDescription": {
        "!type": "fn(description: string) -> DriveApp.Folder",
        "!doc": "Sets the description for the Folder."
      },
      "setName": {
        "!type": "fn(name: string) -> DriveApp.Folder",
        "!doc": "Sets the name of the Folder."
      },
      "setOwner": {
        "!type": "fn(emailAddress: string) -> DriveApp.Folder",
        "!doc": "Changes the owner of the Folder. This method also gives the previous owner\n explicit edit access to the Folder."
      },
      "setOwner ": {
        "!type": "fn(user: User) -> DriveApp.Folder",
        "!doc": "Changes the owner of the Folder. This method also gives the previous owner\n explicit edit access to the Folder."
      },
      "setShareableByEditors": {
        "!type": "fn(shareable: bool) -> DriveApp.Folder",
        "!doc": "Sets whether users with edit permissions to the Folder are allowed to share\n with other users or change the permissions. The default for a new Folder is\n true."
      },
      "setSharing": {
        "!type": "fn(accessType: DriveApp.Access, permissionType: DriveApp.Permission) -> DriveApp.Folder",
        "!doc": "Sets which class of users can access the Folder and what permissions\n those users are granted, besides any individual users who have been explicitly given access.\n\n \n // Creates a folder that anyone on the Internet can read from and write to. (Domain\n // administrators can prohibit this setting for users of Google Apps for Business, Google Apps\n // for Education, or Google Apps for Your Domain.)\n var folder = DriveApp.createFolder('Shared Folder');\n folder.setSharing(DriveApp.Access.ANYONE, DriveApp.Permission.EDIT);\n "
      },
      "setStarred": {
        "!type": "fn(starred: bool) -> DriveApp.Folder",
        "!doc": "Sets whether the Folder is starred in the user's Drive. The default for\n new Folders is false."
      },
      "setTrashed": {
        "!type": "fn(trashed: bool) -> DriveApp.Folder",
        "!doc": "Sets whether the Folder is in the trash of the user's Drive. The default\n for new Folders is false."
      }
    },
    "DriveApp.FolderIterator": {
      "getContinuationToken": {
        "!type": "fn() -> string",
        "!doc": "Gets a token that can be used to resume this iteration at a later time. This method is\n useful if processing an iterator in one execution would exceed the maximum execution\n time. Continuation tokens are generally valid for one week."
      },
      "hasNext": {
        "!type": "fn() -> bool",
        "!doc": "Determines whether calling next() will return an item."
      },
      "next": {
        "!type": "fn() -> DriveApp.Folder",
        "!doc": "Gets the next item in the collection of files or folders. Throws an exception if no items\n remain."
      }
    },
    "DriveApp.Permission": {
      "COMMENT": {
        "!type": "DriveApp.Permission",
        "!doc": "Users who can access the file or folder are able only to view it, copy it, or comment on it.\n Passing this value to File.setSharing(accessType, permissionType) throws an exception if\n the type of file does not support it."
      },
      "EDIT": {
        "!type": "DriveApp.Permission",
        "!doc": "Users who can access the file or folder are able to edit it. Unless\n File.setShareableByEditors(shareable) is set to false, users can also change the\n sharing settings.  Passing this value to File.setSharing(accessType, permissionType)\n throws an exception if the type of file does not support it."
      },
      "NONE": {
        "!type": "DriveApp.Permission",
        "!doc": "The user does not have any permissions for the file or folder. This value can be returned, but\n passing it to File.setSharing(accessType, permissionType) throws an exception unless it\n is set in combination with Access.ANYONE."
      },
      "OWNER": {
        "!type": "DriveApp.Permission",
        "!doc": "The user owns the file or folder. This value can be returned, but passing it to\n File.setSharing(accessType, permissionType) throws an exception."
      },
      "VIEW": {
        "!type": "DriveApp.Permission",
        "!doc": "Users who can access the file or folder are able only to view it or copy it. Passing this value\n to File.setSharing(accessType, permissionType) throws an exception if the type of file\n does not support it."
      }
    },
    "DriveApp.User": {
      "getDomain": {
        "!type": "fn() -> string",
        "!doc": "Gets the domain name associated with the user's account.\n\n \n \n // Log the domain names associated with all users who have edit access to a file.\n var file = DriveApp.getFileById(&#39;1234567890abcdefghijklmnopqrstuvwxyz&#39;);\n var editors = file.getEditors();\n for (var i = 0; i &lt; editors.length; i++) {\n   Logger.log(editors[i].getDomain());\n }\n "
      },
      "getEmail": {
        "!type": "fn() -> string",
        "!doc": "Gets the user's email address. The user's email address is only available if the user has\n chosen to share the address from the Google+ account settings page, or if the user belongs to\n the same domain as the user running the script and the domain administrator has allowed all\n users within the domain to see other users' email addresses.\n\n \n \n // Log the email address of all users who have edit access to a file.\n var file = DriveApp.getFileById(&#39;1234567890abcdefghijklmnopqrstuvwxyz&#39;);\n var editors = file.getEditors();\n for (var i = 0; i &lt; editors.length; i++) {\n   Logger.log(editors[i].getEmail());\n }\n "
      },
      "getName": {
        "!type": "fn() -> string",
        "!doc": "Gets the user's name. This method returns null if the user's name is not available.\n\n \n \n // Log the names of all users who have edit access to a file.\n var file = DriveApp.getFileById(&#39;1234567890abcdefghijklmnopqrstuvwxyz&#39;);\n var editors = file.getEditors();\n for (var i = 0; i &lt; editors.length; i++) {\n   Logger.log(editors[i].getName());\n }\n "
      },
      "getPhotoUrl": {
        "!type": "fn() -> string",
        "!doc": "Gets the URL for the user's photo. This method returns null if the user's photo is not\n available.\n\n \n \n // Log the URLs for the photos of all users who have edit access to a file.\n var file = DriveApp.getFileById(&#39;1234567890abcdefghijklmnopqrstuvwxyz&#39;);\n var editors = file.getEditors();\n for (var i = 0; i &lt; editors.length; i++) {\n   Logger.log(editors[i].getPhotoUrl());\n }\n "
      },
      "getUserLoginId": {
        "!type": "fn() -> string",
        "!doc": "Gets the user's email address.\n\n \n // Log the email address of the person running the script.\n Logger.log(Session.getActiveUser().getUserLoginId());\n "
      }
    },
    "MccApp.AccountLabel": {
      "accounts": {
        "!type": "fn() -> MccApp.ManagedAccountSelector"
      },
      "getEntityType": {
        "!type": "fn() -> string"
      },
      "getId": {
        "!type": "fn() -> string"
      },
      "getName": {
        "!type": "fn() -> string"
      },
      "remove": {
        "!type": "fn()"
      },
      "setName": {
        "!type": "fn(name: string)"
      }
    },
    "MccApp.AccountLabelIterator": {
      "hasNext": {
        "!type": "fn() -> bool"
      },
      "next": {
        "!type": "fn() -> MccApp.AccountLabel"
      },
      "totalNumEntities": {
        "!type": "fn() -> number"
      }
    },
    "MccApp.AccountLabelSelector": {
      "get": {
        "!type": "fn() -> MccApp.AccountLabelIterator"
      },
      "withCondition": {
        "!type": "fn(condition: string) -> MccApp.AccountLabelSelector"
      },
      "withIds": {
        "!type": "fn(ids: [long]) -> MccApp.AccountLabelSelector"
      }
    },
    "MccApp.Array": {
      "concat": {
        "!type": "fn(array2: Array) -> MccApp.Array"
      },
      "join": {
        "!type": "fn(separator: string) -> string"
      },
      "pop": {
        "!type": "fn() -> number"
      },
      "push": {
        "!type": "fn(element1: object) -> number"
      },
      "reverse": {
        "!type": "fn() -> MccApp.Array"
      },
      "shift": {
        "!type": "fn() -> object"
      },
      "slice": {
        "!type": "fn(start: number) -> MccApp.Array"
      },
      "slice ": {
        "!type": "fn(start: number, end: number) -> MccApp.Array"
      },
      "sort": {
        "!type": "fn() -> MccApp.Array"
      },
      "sort ": {
        "!type": "fn(sortfunc: object) -> MccApp.Array"
      },
      "splice": {
        "!type": "fn(index: number, howmany: number, element1: object) -> MccApp.Array"
      },
      "toString ": {
        "!type": "fn() -> string"
      },
      "unshift": {
        "!type": "fn(element1: object) -> MccApp.Array"
      }
    },
    "MccApp.ExecutionResult": {
      "getCustomerId": {
        "!type": "fn() -> string"
      },
      "getError": {
        "!type": "fn() -> string"
      },
      "getReturnValue": {
        "!type": "fn() -> string"
      },
      "getStatus": {
        "!type": "fn() -> string"
      }
    },
    "MccApp.ManagedAccount": {
      "applyLabel": {
        "!type": "fn(name: string)"
      },
      "getCurrencyCode": {
        "!type": "fn() -> string"
      },
      "getCustomerId": {
        "!type": "fn() -> string"
      },
      "getEntityType": {
        "!type": "fn() -> string"
      },
      "getName": {
        "!type": "fn() -> string"
      },
      "getStatsFor": {
        "!type": "fn(dateFrom: object, dateTo: object) -> MccApp.ManagedAccountStats"
      },
      "getStatsFor ": {
        "!type": "fn(dateRange: string) -> MccApp.ManagedAccountStats"
      },
      "getTimeZone": {
        "!type": "fn() -> string"
      },
      "labels": {
        "!type": "fn() -> MccApp.AccountLabelSelector"
      },
      "removeLabel": {
        "!type": "fn(name: string)"
      }
    },
    "MccApp.ManagedAccountIterator": {
      "hasNext": {
        "!type": "fn() -> bool"
      },
      "next": {
        "!type": "fn() -> MccApp.ManagedAccount"
      },
      "totalNumEntities": {
        "!type": "fn() -> number"
      }
    },
    "MccApp.ManagedAccountSelector": {
      "executeInParallel": {
        "!type": "fn(functionName: string, optionalCallbackFunctionName: string)"
      },
      "executeInParallel ": {
        "!type": "fn(functionName: string, optionalCallbackFunctionName: string, optionalInput: string)"
      },
      "forDateRange": {
        "!type": "fn(dateFrom: object, dateTo: object) -> MccApp.ManagedAccountSelector"
      },
      "forDateRange ": {
        "!type": "fn(dateRange: string) -> MccApp.ManagedAccountSelector"
      },
      "get": {
        "!type": "fn() -> MccApp.ManagedAccountIterator"
      },
      "orderBy": {
        "!type": "fn(orderBy: string) -> MccApp.ManagedAccountSelector"
      },
      "withCondition": {
        "!type": "fn(condition: string) -> MccApp.ManagedAccountSelector"
      },
      "withIds": {
        "!type": "fn(ids: [long]) -> MccApp.ManagedAccountSelector"
      },
      "withLimit": {
        "!type": "fn(limit: number) -> MccApp.ManagedAccountSelector"
      }
    },
    "MccApp.ManagedAccountStats": {
      "getClickConversionRate": {
        "!type": "fn() -> number"
      },
      "getClicks": {
        "!type": "fn() -> number"
      },
      "getConversionRate": {
        "!type": "fn() -> number"
      },
      "getConversions": {
        "!type": "fn() -> number"
      },
      "getConvertedClicks": {
        "!type": "fn() -> number"
      },
      "getCost": {
        "!type": "fn() -> number"
      },
      "getCtr": {
        "!type": "fn() -> number"
      },
      "getImpressions": {
        "!type": "fn() -> number"
      }
    },
    "MccApp.Stats": {
      "getAverageCpc": {
        "!type": "fn() -> number"
      },
      "getAverageCpm": {
        "!type": "fn() -> number"
      },
      "getAveragePageviews": {
        "!type": "fn() -> number"
      },
      "getAveragePosition": {
        "!type": "fn() -> number"
      },
      "getAverageTimeOnSite": {
        "!type": "fn() -> number"
      },
      "getBounceRate": {
        "!type": "fn() -> number"
      },
      "getClickConversionRate": {
        "!type": "fn() -> number"
      },
      "getClicks": {
        "!type": "fn() -> number"
      },
      "getConversionRate": {
        "!type": "fn() -> number"
      },
      "getConversions": {
        "!type": "fn() -> number"
      },
      "getConvertedClicks": {
        "!type": "fn() -> number"
      },
      "getCost": {
        "!type": "fn() -> number"
      },
      "getCtr": {
        "!type": "fn() -> number"
      },
      "getImpressions": {
        "!type": "fn() -> number"
      }
    },
    "MccApp.String": {
      "charAt": {
        "!type": "fn(index: number) -> string"
      },
      "charCodeAt": {
        "!type": "fn(index: number) -> number"
      },
      "concat": {
        "!type": "fn(string2: string) -> string"
      },
      "fromCharCode": {
        "!type": "fn(code: number) -> string"
      },
      "indexOf": {
        "!type": "fn(searchString: string, start: number) -> number"
      },
      "lastIndexOf": {
        "!type": "fn(searchString: string, start: number) -> number"
      },
      "match": {
        "!type": "fn(regexp: RegExp) -> MccApp.Array"
      },
      "replace": {
        "!type": "fn(regexp: RegExp, newString: string) -> string"
      },
      "replace ": {
        "!type": "fn(subString: string, newString: string) -> string"
      },
      "search": {
        "!type": "fn(regexp: RegExp) -> number"
      },
      "slice": {
        "!type": "fn(begin: number) -> string"
      },
      "slice ": {
        "!type": "fn(begin: number, end: number) -> string"
      },
      "split": {
        "!type": "fn(separator: string) -> MccApp.Array"
      },
      "split ": {
        "!type": "fn(separator: string, limit: number) -> MccApp.Array"
      },
      "substr": {
        "!type": "fn(start: number) -> string"
      },
      "substr ": {
        "!type": "fn(start: number, length: number) -> string"
      },
      "substring": {
        "!type": "fn(from: number) -> string"
      },
      "substring ": {
        "!type": "fn(from: number, to: number) -> string"
      },
      "toLowerCase": {
        "!type": "fn() -> string"
      },
      "toUpperCase": {
        "!type": "fn() -> string"
      }
    },
    "Jdbc.JdbcArray": {
      "free": {
        "!type": "fn()",
        "!doc": "For documentation of this method, see java.sql.Array#free()."
      },
      "getArray": {
        "!type": "fn() -> object",
        "!doc": "For documentation of this method, see java.sql.Array#getArray()."
      },
      "getArray ": {
        "!type": "fn(index: number, count: number) -> object",
        "!doc": "For documentation of this method, see java.sql.Array#getArray(long, int)."
      },
      "getBaseType": {
        "!type": "fn() -> number",
        "!doc": "For documentation of this method, see java.sql.Array#getBaseType()."
      },
      "getBaseTypeName": {
        "!type": "fn() -> string",
        "!doc": "For documentation of this method, see java.sql.Array#getBaseTypeName()."
      },
      "getResultSet": {
        "!type": "fn() -> Jdbc.JdbcResultSet",
        "!doc": "For documentation of this method, see java.sql.Array#getResultSet()."
      },
      "getResultSet ": {
        "!type": "fn(index: number, count: number) -> Jdbc.JdbcResultSet",
        "!doc": "For documentation of this method, see java.sql.Array#getResultSet(long, int)."
      }
    },
    "Jdbc.JdbcBlob": {
      "free": {
        "!type": "fn()",
        "!doc": "For documentation of this method, see java.sql.Blob#free()."
      },
      "getAppsScriptBlob": {
        "!type": "fn() -> Blob",
        "!doc": "Gets the content of this JdbcBlob as an Apps Script blob."
      },
      "getAs": {
        "!type": "fn(contentType: string) -> Blob",
        "!doc": "Return the data inside this object as a blob converted to the specified content type. This\n method adds the appropriate extension to the filename ? for example, \"myfile.pdf\". However, it\n assumes that the part of the filename that follows the last period (if any) is an existing\n extension that should be replaced. Consequently, \"ChristmasList.12.25.2014\" will become\n \"ChristmasList.12.25.pdf\"."
      },
      "getBytes": {
        "!type": "fn(position: number, length: number) -> [number]",
        "!doc": "For documentation of this method, see java.sql.Blob#getBytes(long, int)."
      },
      "length": {
        "!type": "fn() -> number",
        "!doc": "For documentation of this method, see java.sql.Blob#length()."
      },
      "position": {
        "!type": "fn(pattern: [number], start: number) -> number",
        "!doc": "For documentation of this method, see java.sql.Blob#position(byte[], long)."
      },
      "position ": {
        "!type": "fn(pattern: Jdbc.JdbcBlob, start: number) -> number",
        "!doc": "For documentation of this method, see java.sql.Blob#position(java.sql.Blob, long)."
      },
      "setBytes": {
        "!type": "fn(position: number, blobSource: BlobSource) -> number",
        "!doc": "Convenience method for BlobSources."
      },
      "setBytes ": {
        "!type": "fn(position: number, blobSource: BlobSource, offset: number, length: number) -> number",
        "!doc": "Convenience method for BlobSources."
      },
      "setBytes  ": {
        "!type": "fn(position: number, bytes: [number]) -> number",
        "!doc": "For documentation of this method, see java.sql.Blob#setBytes(long, byte[])."
      },
      "setBytes   ": {
        "!type": "fn(position: number, bytes: [number], offset: number, length: number) -> number",
        "!doc": "For documentation of this method, see java.sql.Blob#setBytes(long, byte[], int, int)."
      },
      "truncate": {
        "!type": "fn(length: number)",
        "!doc": "For documentation of this method, see java.sql.Blob#truncate(long)."
      }
    },
    "Jdbc.JdbcCallableStatement": {
      "addBatch": {
        "!type": "fn()",
        "!doc": "For documentation of this method, see java.sql.PreparedStatement#addBatch()."
      },
      "addBatch ": {
        "!type": "fn(sql: string)",
        "!doc": "For documentation of this method, see java.sql.Statement#addBatch(String)."
      },
      "cancel": {
        "!type": "fn()",
        "!doc": "For documentation of this method, see java.sql.Statement#cancel()."
      },
      "clearBatch": {
        "!type": "fn()",
        "!doc": "For documentation of this method, see java.sql.Statement#clearBatch()."
      },
      "clearParameters": {
        "!type": "fn()",
        "!doc": "For documentation of this method, see java.sql.PreparedStatement#clearParameters()."
      },
      "clearWarnings": {
        "!type": "fn()",
        "!doc": "For documentation of this method, see java.sql.Statement#clearWarnings()."
      },
      "close": {
        "!type": "fn()",
        "!doc": "For documentation of this method, see java.sql.Statement#close()."
      },
      "execute": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see java.sql.PreparedStatement#execute()."
      },
      "execute ": {
        "!type": "fn(sql: string) -> bool",
        "!doc": "For documentation of this method, see java.sql.Statement#execute(String)."
      },
      "execute  ": {
        "!type": "fn(sql: string, autoGeneratedKeys: number) -> bool",
        "!doc": "For documentation of this method, see java.sql.Statement#execute(String, int)."
      },
      "execute   ": {
        "!type": "fn(sql: string, columnIndexes: [number]) -> bool",
        "!doc": "For documentation of this method, see java.sql.Statement#execute(String, int[])."
      },
      "execute    ": {
        "!type": "fn(sql: string, columnNames: [string]) -> bool",
        "!doc": "For documentation of this method, see java.sql.Statement#execute(String, String[])."
      },
      "executeBatch": {
        "!type": "fn() -> [number]",
        "!doc": "For documentation of this method, see java.sql.Statement#executeBatch()."
      },
      "executeQuery": {
        "!type": "fn() -> Jdbc.JdbcResultSet",
        "!doc": "For documentation of this method, see java.sql.PreparedStatement#executeQuery()."
      },
      "executeQuery ": {
        "!type": "fn(sql: string) -> Jdbc.JdbcResultSet",
        "!doc": "For documentation of this method, see java.sql.Statement#executeQuery(String)."
      },
      "executeUpdate": {
        "!type": "fn() -> number",
        "!doc": "For documentation of this method, see java.sql.PreparedStatement#executeUpdate()."
      },
      "executeUpdate ": {
        "!type": "fn(sql: string) -> number",
        "!doc": "For documentation of this method, see java.sql.Statement#executeUpdate(String)."
      },
      "executeUpdate  ": {
        "!type": "fn(sql: string, autoGeneratedKeys: number) -> number",
        "!doc": "For documentation of this method, see java.sql.Statement#executeUpdate(String, int)."
      },
      "executeUpdate   ": {
        "!type": "fn(sql: string, columnIndexes: [number]) -> number",
        "!doc": "For documentation of this method, see java.sql.Statement#executeUpdate(String, int)."
      },
      "executeUpdate    ": {
        "!type": "fn(sql: string, columnNames: [string]) -> number",
        "!doc": "For documentation of this method, see\n java.sql.Statement#executeUpdate(String, String[])."
      },
      "getArray": {
        "!type": "fn(parameterIndex: number) -> Jdbc.JdbcArray",
        "!doc": "For documentation of this method, see\n java.sql.CallableStatement#getArray(int)."
      },
      "getArray ": {
        "!type": "fn(parameterName: string) -> Jdbc.JdbcArray",
        "!doc": "For documentation of this method, see\n java.sql.CallableStatement#getArray(String)."
      },
      "getBigDecimal": {
        "!type": "fn(parameterIndex: number) -> BigNumber",
        "!doc": "For documentation of this method, see\n java.sql.CallableStatement#getBigDecimal(int)."
      },
      "getBigDecimal ": {
        "!type": "fn(parameterName: string) -> BigNumber",
        "!doc": "For documentation of this method, see\n java.sql.CallableStatement#getBigDecimal(String)."
      },
      "getBlob": {
        "!type": "fn(parameterIndex: number) -> Jdbc.JdbcBlob",
        "!doc": "For documentation of this method, see\n java.sql.CallableStatement#getBlob(int)."
      },
      "getBlob ": {
        "!type": "fn(parameterName: string) -> Jdbc.JdbcBlob",
        "!doc": "For documentation of this method, see\n java.sql.CallableStatement#getBlob(String)."
      },
      "getBoolean": {
        "!type": "fn(parameterIndex: number) -> bool",
        "!doc": "For documentation of this method, see\n java.sql.CallableStatement#getBoolean(int)."
      },
      "getBoolean ": {
        "!type": "fn(parameterName: string) -> bool",
        "!doc": "For documentation of this method, see\n java.sql.CallableStatement#getBoolean(String)."
      },
      "getByte": {
        "!type": "fn(parameterIndex: number) -> number",
        "!doc": "For documentation of this method, see\n java.sql.CallableStatement#getByte(int)."
      },
      "getByte ": {
        "!type": "fn(parameterName: string) -> number",
        "!doc": "For documentation of this method, see\n java.sql.CallableStatement#getByte(String)."
      },
      "getBytes": {
        "!type": "fn(parameterIndex: number) -> [number]",
        "!doc": "For documentation of this method, see\n java.sql.CallableStatement#getBytes(int)."
      },
      "getBytes ": {
        "!type": "fn(parameterName: string) -> [number]",
        "!doc": "For documentation of this method, see\n java.sql.CallableStatement#getBytes(String)."
      },
      "getClob": {
        "!type": "fn(parameterIndex: number) -> Jdbc.JdbcClob",
        "!doc": "For documentation of this method, see\n java.sql.CallableStatement#getClob(int)."
      },
      "getClob ": {
        "!type": "fn(parameterName: string) -> Jdbc.JdbcClob",
        "!doc": "For documentation of this method, see\n java.sql.CallableStatement#getClob(String)."
      },
      "getConnection": {
        "!type": "fn() -> Jdbc.JdbcConnection",
        "!doc": "For documentation of this method, see java.sql.Statement#getConnection()."
      },
      "getDate": {
        "!type": "fn(parameterIndex: number) -> Jdbc.JdbcDate",
        "!doc": "For documentation of this method, see\n java.sql.CallableStatement#getDate(int)."
      },
      "getDate ": {
        "!type": "fn(parameterIndex: number, timeZone: string) -> Jdbc.JdbcDate",
        "!doc": "For documentation of this method, see\n java.sql.CallableStatement#getDate(int, java.util.Calendar)."
      },
      "getDate  ": {
        "!type": "fn(parameterName: string) -> Jdbc.JdbcDate",
        "!doc": "For documentation of this method, see\n java.sql.CallableStatement#getDate(String)."
      },
      "getDate   ": {
        "!type": "fn(parameterName: string, timeZone: string) -> Jdbc.JdbcDate",
        "!doc": "For documentation of this method, see\n java.sql.CallableStatement#getDate(String, java.util.Calendar)."
      },
      "getDouble": {
        "!type": "fn(parameterIndex: number) -> number",
        "!doc": "For documentation of this method, see\n java.sql.CallableStatement#getDouble(int)."
      },
      "getDouble ": {
        "!type": "fn(parameterName: string) -> number",
        "!doc": "For documentation of this method, see\n java.sql.CallableStatement#getDouble(String)."
      },
      "getFetchDirection": {
        "!type": "fn() -> number",
        "!doc": "For documentation of this method, see java.sql.Statement#getFetchDirection()."
      },
      "getFetchSize": {
        "!type": "fn() -> number",
        "!doc": "For documentation of this method, see java.sql.Statement#getFetchSize()."
      },
      "getFloat": {
        "!type": "fn(parameterIndex: number) -> number",
        "!doc": "For documentation of this method, see\n java.sql.CallableStatement#getFloat(int)."
      },
      "getFloat ": {
        "!type": "fn(parameterName: string) -> number",
        "!doc": "For documentation of this method, see\n java.sql.CallableStatement#getFloat(String)."
      },
      "getGeneratedKeys": {
        "!type": "fn() -> Jdbc.JdbcResultSet",
        "!doc": "For documentation of this method, see java.sql.Statement#getGeneratedKeys()."
      },
      "getInt": {
        "!type": "fn(parameterIndex: number) -> number",
        "!doc": "For documentation of this method, see\n java.sql.CallableStatement#getInt(int)."
      },
      "getInt ": {
        "!type": "fn(parameterName: string) -> number",
        "!doc": "For documentation of this method, see\n java.sql.CallableStatement#getInt(String)."
      },
      "getLong": {
        "!type": "fn(parameterIndex: number) -> number",
        "!doc": "For documentation of this method, see\n java.sql.CallableStatement#getLong(int)."
      },
      "getLong ": {
        "!type": "fn(parameterName: string) -> number",
        "!doc": "For documentation of this method, see\n java.sql.CallableStatement#getLong(String)."
      },
      "getMaxFieldSize": {
        "!type": "fn() -> number",
        "!doc": "For documentation of this method, see java.sql.Statement#getMaxFieldSize()."
      },
      "getMaxRows": {
        "!type": "fn() -> number",
        "!doc": "For documentation of this method, see java.sql.Statement#getMaxRows()."
      },
      "getMetaData": {
        "!type": "fn() -> Jdbc.JdbcResultSetMetaData",
        "!doc": "For documentation of this method, see java.sql.PreparedStatement#getMetaData()."
      },
      "getMoreResults": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see java.sql.Statement#getMoreResults()."
      },
      "getMoreResults ": {
        "!type": "fn(current: number) -> bool",
        "!doc": "For documentation of this method, see java.sql.Statement#getMoreResults(int)."
      },
      "getNClob": {
        "!type": "fn(parameterIndex: number) -> Jdbc.JdbcClob",
        "!doc": "For documentation of this method, see\n java.sql.CallableStatement#getNClob(int)."
      },
      "getNClob ": {
        "!type": "fn(parameterName: string) -> Jdbc.JdbcClob",
        "!doc": "For documentation of this method, see\n java.sql.CallableStatement#getNClob(String)."
      },
      "getNString": {
        "!type": "fn(parameterIndex: number) -> string",
        "!doc": "For documentation of this method, see\n java.sql.CallableStatement#getNString(int)."
      },
      "getNString ": {
        "!type": "fn(parameterName: string) -> string",
        "!doc": "For documentation of this method, see\n java.sql.CallableStatement#getNString(String)."
      },
      "getObject": {
        "!type": "fn(parameterIndex: number) -> object",
        "!doc": "For documentation of this method, see\n java.sql.CallableStatement#getObject(int)."
      },
      "getObject ": {
        "!type": "fn(parameterName: string) -> object",
        "!doc": "For documentation of this method, see\n java.sql.CallableStatement#getObject(String)."
      },
      "getParameterMetaData": {
        "!type": "fn() -> Jdbc.JdbcParameterMetaData",
        "!doc": "For documentation of this method, see\n java.sql.PreparedStatement#getParameterMetaData()."
      },
      "getQueryTimeout": {
        "!type": "fn() -> number",
        "!doc": "For documentation of this method, see java.sql.Statement#getQueryTimeout()."
      },
      "getRef": {
        "!type": "fn(parameterIndex: number) -> Jdbc.JdbcRef",
        "!doc": "For documentation of this method, see\n java.sql.CallableStatement#getRef(int)."
      },
      "getRef ": {
        "!type": "fn(parameterName: string) -> Jdbc.JdbcRef",
        "!doc": "For documentation of this method, see\n java.sql.CallableStatement#getRef(String)."
      },
      "getResultSet": {
        "!type": "fn() -> Jdbc.JdbcResultSet",
        "!doc": "For documentation of this method, see java.sql.Statement#getResultSet()."
      },
      "getResultSetConcurrency": {
        "!type": "fn() -> number",
        "!doc": "For documentation of this method, see java.sql.Statement#getResultSetConcurrency()."
      },
      "getResultSetHoldability": {
        "!type": "fn() -> number",
        "!doc": "For documentation of this method, see java.sql.Statement#getResultSetHoldability()."
      },
      "getResultSetType": {
        "!type": "fn() -> number",
        "!doc": "For documentation of this method, see java.sql.Statement#getResultSetType()."
      },
      "getRowId": {
        "!type": "fn(parameterIndex: number) -> Jdbc.JdbcRowId",
        "!doc": "For documentation of this method, see\n java.sql.CallableStatement#getRowId(int)."
      },
      "getRowId ": {
        "!type": "fn(parameterName: string) -> Jdbc.JdbcRowId",
        "!doc": "For documentation of this method, see\n java.sql.CallableStatement#getRowId(String)."
      },
      "getSQLXML": {
        "!type": "fn(parameterIndex: number) -> Jdbc.JdbcSQLXML",
        "!doc": "For documentation of this method, see\n java.sql.CallableStatement#getSQLXML(int)."
      },
      "getSQLXML ": {
        "!type": "fn(parameterName: string) -> Jdbc.JdbcSQLXML",
        "!doc": "For documentation of this method, see\n java.sql.CallableStatement#getSQLXML(String)."
      },
      "getShort": {
        "!type": "fn(parameterIndex: number) -> number",
        "!doc": "For documentation of this method, see\n java.sql.CallableStatement#getShort(int)."
      },
      "getShort ": {
        "!type": "fn(parameterName: string) -> number",
        "!doc": "For documentation of this method, see\n java.sql.CallableStatement#getShort(String)."
      },
      "getString": {
        "!type": "fn(parameterIndex: number) -> string",
        "!doc": "For documentation of this method, see\n java.sql.CallableStatement#getString(int)."
      },
      "getString ": {
        "!type": "fn(parameterName: string) -> string",
        "!doc": "For documentation of this method, see\n java.sql.CallableStatement#getString(String)."
      },
      "getTime": {
        "!type": "fn(parameterIndex: number) -> Jdbc.JdbcTime",
        "!doc": "For documentation of this method, see\n java.sql.CallableStatement#getTime(int)."
      },
      "getTime ": {
        "!type": "fn(parameterIndex: number, timeZone: string) -> Jdbc.JdbcTime",
        "!doc": "For documentation of this method, see\n java.sql.CallableStatement#getTime(int, java.util.Calendar)."
      },
      "getTime  ": {
        "!type": "fn(parameterName: string) -> Jdbc.JdbcTime",
        "!doc": "For documentation of this method, see\n java.sql.CallableStatement#getTime(String)."
      },
      "getTime   ": {
        "!type": "fn(parameterName: string, timeZone: string) -> Jdbc.JdbcTime",
        "!doc": "For documentation of this method, see\n java.sql.CallableStatement#getTime(String, java.util.Calendar)."
      },
      "getTimestamp": {
        "!type": "fn(parameterIndex: number) -> Jdbc.JdbcTimestamp",
        "!doc": "For documentation of this method, see\n java.sql.CallableStatement#getTimestamp(int)."
      },
      "getTimestamp ": {
        "!type": "fn(parameterIndex: number, timeZone: string) -> Jdbc.JdbcTimestamp",
        "!doc": "For documentation of this method, see\n java.sql.CallableStatement#getTimestamp(int, java.util.Calendar)."
      },
      "getTimestamp  ": {
        "!type": "fn(parameterName: string) -> Jdbc.JdbcTimestamp",
        "!doc": "For documentation of this method, see\n java.sql.CallableStatement#getTimestamp(String)."
      },
      "getTimestamp   ": {
        "!type": "fn(parameterName: string, timeZone: string) -> Jdbc.JdbcTimestamp",
        "!doc": "For documentation of this method, see\n java.sql.CallableStatement#getTimestamp(String, java.util.Calendar)."
      },
      "getURL": {
        "!type": "fn(parameterIndex: number) -> string",
        "!doc": "For documentation of this method, see\n java.sql.CallableStatement#getURL(int)."
      },
      "getURL ": {
        "!type": "fn(parameterName: string) -> string",
        "!doc": "For documentation of this method, see\n java.sql.CallableStatement#getURL(String)."
      },
      "getUpdateCount": {
        "!type": "fn() -> number",
        "!doc": "For documentation of this method, see java.sql.Statement#getUpdateCount()."
      },
      "getWarnings": {
        "!type": "fn() -> [string]",
        "!doc": "Returns the current set of warnings reported by the driver. For documentation of this method,\n see java.sql.Statement#getWarnings()"
      },
      "isClosed": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see java.sql.Statement#isClosed()."
      },
      "isPoolable": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see java.sql.Statement#isPoolable()."
      },
      "registerOutParameter": {
        "!type": "fn(parameterIndex: number, sqlType: number)",
        "!doc": "For documentation of this method, see\n java.sql.CallableStatement#registerOutParameter(int, int)."
      },
      "registerOutParameter ": {
        "!type": "fn(parameterIndex: number, sqlType: number, scale: number)",
        "!doc": "For documentation of this method, see\n java.sql.CallableStatement#registerOutParameter(int, int, int)."
      },
      "registerOutParameter  ": {
        "!type": "fn(parameterIndex: number, sqlType: number, typeName: string)",
        "!doc": "For documentation of this method, see\n java.sql.CallableStatement#registerOutParameter(int, int, String)."
      },
      "registerOutParameter   ": {
        "!type": "fn(parameterName: string, sqlType: number)",
        "!doc": "For documentation of this method, see\n java.sql.CallableStatement#registerOutParameter(String, int)."
      },
      "registerOutParameter    ": {
        "!type": "fn(parameterName: string, sqlType: number, scale: number)",
        "!doc": "For documentation of this method, see\n java.sql.CallableStatement#registerOutParameter(String, int, int)."
      },
      "registerOutParameter     ": {
        "!type": "fn(parameterName: string, sqlType: number, typeName: string)",
        "!doc": "For documentation of this method, see\n java.sql.CallableStatement#registerOutParameter(String, int, String)."
      },
      "setArray": {
        "!type": "fn(parameterIndex: number, x: Jdbc.JdbcArray)",
        "!doc": "For documentation of this method, see\n java.sql.PreparedStatement#setArray(int, java.sql.Array)."
      },
      "setBigDecimal": {
        "!type": "fn(parameterIndex: number, x: BigNumber)",
        "!doc": "For documentation of this method, see\n java.sql.PreparedStatement#setBigDecimal(int, java.math.BigDecimal)."
      },
      "setBigDecimal ": {
        "!type": "fn(parameterName: string, x: BigNumber)",
        "!doc": "For documentation of this method, see\n java.sql.CallableStatement#setBigDecimal(String, java.math.BigDecimal)."
      },
      "setBlob": {
        "!type": "fn(parameterIndex: number, x: Jdbc.JdbcBlob)",
        "!doc": "For documentation of this method, see\n java.sql.PreparedStatement#setBlob(int, java.sql.Blob)."
      },
      "setBlob ": {
        "!type": "fn(parameterName: string, x: Jdbc.JdbcBlob)",
        "!doc": "For documentation of this method, see\n java.sql.CallableStatement#setBlob(String, java.sql.Blob)."
      },
      "setBoolean": {
        "!type": "fn(parameterIndex: number, x: bool)",
        "!doc": "For documentation of this method, see\n java.sql.PreparedStatement#setBoolean(int, boolean)."
      },
      "setBoolean ": {
        "!type": "fn(parameterName: string, x: bool)",
        "!doc": "For documentation of this method, see\n java.sql.CallableStatement#setBoolean(String, boolean)."
      },
      "setByte": {
        "!type": "fn(parameterIndex: number, x: number)",
        "!doc": "For documentation of this method, see java.sql.PreparedStatement#setByte(int, byte)."
      },
      "setByte ": {
        "!type": "fn(parameterName: string, x: number)",
        "!doc": "For documentation of this method, see\n java.sql.CallableStatement#setByte(String, byte)."
      },
      "setBytes": {
        "!type": "fn(parameterIndex: number, x: [number])",
        "!doc": "For documentation of this method, see\n java.sql.PreparedStatement#setBytes(int, byte[])."
      },
      "setBytes ": {
        "!type": "fn(parameterName: string, x: [number])",
        "!doc": "For documentation of this method, see\n java.sql.CallableStatement#setBytes(String, byte[])."
      },
      "setClob": {
        "!type": "fn(parameterIndex: number, x: Jdbc.JdbcClob)",
        "!doc": "For documentation of this method, see\n java.sql.PreparedStatement#setClob(int, java.sql.Clob)."
      },
      "setClob ": {
        "!type": "fn(parameterName: string, x: Jdbc.JdbcClob)",
        "!doc": "For documentation of this method, see\n java.sql.CallableStatement#setClob(String, java.sql.Clob)."
      },
      "setCursorName": {
        "!type": "fn(name: string)",
        "!doc": "For documentation of this method, see java.sql.Statement#setCursorName(String)."
      },
      "setDate": {
        "!type": "fn(parameterIndex: number, x: Jdbc.JdbcDate)",
        "!doc": "For documentation of this method, see\n java.sql.PreparedStatement#setDate(int, java.sql.Date)."
      },
      "setDate ": {
        "!type": "fn(parameterIndex: number, x: Jdbc.JdbcDate, timeZone: string)",
        "!doc": "For documentation of this method, see\n java.sql.PreparedStatement#setDate(int, java.sql.Date, java.util.Calendar)."
      },
      "setDate  ": {
        "!type": "fn(parameterName: string, x: Jdbc.JdbcDate)",
        "!doc": "For documentation of this method, see\n java.sql.CallableStatement#setDate(String, java.sql.Date)."
      },
      "setDate   ": {
        "!type": "fn(parameterName: string, x: Jdbc.JdbcDate, timeZone: string)",
        "!doc": "For documentation of this method, see\n java.sql.CallableStatement#setDate(String, java.sql.Date, java.util.Calendar)."
      },
      "setDouble": {
        "!type": "fn(parameterIndex: number, x: number)",
        "!doc": "For documentation of this method, see\n java.sql.PreparedStatement#setDouble(int, double)."
      },
      "setDouble ": {
        "!type": "fn(parameterName: string, x: number)",
        "!doc": "For documentation of this method, see\n java.sql.CallableStatement#setDouble(String, double)."
      },
      "setEscapeProcessing": {
        "!type": "fn(enable: bool)",
        "!doc": "For documentation of this method, see java.sql.Statement#setEscapeProcessing(boolean)."
      },
      "setFetchDirection": {
        "!type": "fn(direction: number)",
        "!doc": "For documentation of this method, see java.sql.Statement#setFetchDirection(int)."
      },
      "setFetchSize": {
        "!type": "fn(rows: number)",
        "!doc": "For documentation of this method, see java.sql.Statement#setFetchSize(int)."
      },
      "setFloat": {
        "!type": "fn(parameterIndex: number, x: number)",
        "!doc": "For documentation of this method, see java.sql.PreparedStatement#setFloat(int, float)."
      },
      "setFloat ": {
        "!type": "fn(parameterName: string, x: number)",
        "!doc": "For documentation of this method, see\n java.sql.CallableStatement#setFloat(String, float)."
      },
      "setInt": {
        "!type": "fn(parameterIndex: number, x: number)",
        "!doc": "For documentation of this method, see java.sql.PreparedStatement#setInt(int, int)."
      },
      "setInt ": {
        "!type": "fn(parameterName: string, x: number)",
        "!doc": "For documentation of this method, see\n java.sql.CallableStatement#setInt(String, int)."
      },
      "setLong": {
        "!type": "fn(parameterIndex: number, x: number)",
        "!doc": "For documentation of this method, see java.sql.PreparedStatement#setLong(int, long)."
      },
      "setLong ": {
        "!type": "fn(parameterName: string, x: number)",
        "!doc": "For documentation of this method, see\n java.sql.CallableStatement#setLong(String, long)."
      },
      "setMaxFieldSize": {
        "!type": "fn(max: number)",
        "!doc": "For documentation of this method, see java.sql.Statement#setMaxFieldSize(int)."
      },
      "setMaxRows": {
        "!type": "fn(max: number)",
        "!doc": "For documentation of this method, see java.sql.Statement#setMaxRows(int)."
      },
      "setNClob": {
        "!type": "fn(parameterIndex: number, x: Jdbc.JdbcClob)",
        "!doc": "For documentation of this method, see\n java.sql.PreparedStatement#setNClob(int, java.sql.NClob)."
      },
      "setNClob ": {
        "!type": "fn(parameterName: string, value: Jdbc.JdbcClob)",
        "!doc": "For documentation of this method, see\n java.sql.CallableStatement#setNClob(String, java.sql.NClob)."
      },
      "setNString": {
        "!type": "fn(parameterIndex: number, x: string)",
        "!doc": "For documentation of this method, see\n java.sql.PreparedStatement#setNString(int, String)."
      },
      "setNString ": {
        "!type": "fn(parameterName: string, value: string)",
        "!doc": "For documentation of this method, see\n java.sql.CallableStatement#setNString(String, String)."
      },
      "setNull": {
        "!type": "fn(parameterIndex: number, sqlType: number)",
        "!doc": "For documentation of this method, see java.sql.PreparedStatement#setNull(int, int)."
      },
      "setNull ": {
        "!type": "fn(parameterIndex: number, sqlType: number, typeName: string)",
        "!doc": "For documentation of this method, see\n java.sql.PreparedStatement#setNull(int, int, String)."
      },
      "setNull  ": {
        "!type": "fn(parameterName: string, sqlType: number)",
        "!doc": "For documentation of this method, see\n java.sql.CallableStatement#setNull(String, int)."
      },
      "setNull   ": {
        "!type": "fn(parameterName: string, sqlType: number, typeName: string)",
        "!doc": "For documentation of this method, see\n java.sql.CallableStatement#setNull(String, int, String)."
      },
      "setObject": {
        "!type": "fn(index: number, x: object)",
        "!doc": "For documentation of this method, see\n java.sql.PreparedStatement#setObject(int, Object)."
      },
      "setObject ": {
        "!type": "fn(parameterIndex: number, x: object, targetSqlType: number)",
        "!doc": "For documentation of this method, see\n java.sql.PreparedStatement#setObject(int, Object, int)."
      },
      "setObject  ": {
        "!type": "fn(parameterIndex: number, x: object, targetSqlType: number, scaleOrLength: number)",
        "!doc": "For documentation of this method, see\n java.sql.PreparedStatement#setObject(int, Object, int, int)."
      },
      "setObject   ": {
        "!type": "fn(parameterName: string, x: object)",
        "!doc": "For documentation of this method, see\n java.sql.CallableStatement#setObject(String, Object)."
      },
      "setObject    ": {
        "!type": "fn(parameterName: string, x: object, targetSqlType: number)",
        "!doc": "For documentation of this method, see\n java.sql.CallableStatement#setObject(String, Object, int)."
      },
      "setObject     ": {
        "!type": "fn(parameterName: string, x: object, targetSqlType: number, scale: number)",
        "!doc": "For documentation of this method, see\n java.sql.CallableStatement#setObject(String, Object, int, int)."
      },
      "setPoolable": {
        "!type": "fn(poolable: bool)",
        "!doc": "For documentation of this method, see java.sql.Statement#setPoolable(boolean)."
      },
      "setQueryTimeout": {
        "!type": "fn(seconds: number)",
        "!doc": "For documentation of this method, see java.sql.Statement#setQueryTimeout(int)."
      },
      "setRef": {
        "!type": "fn(parameterIndex: number, x: Jdbc.JdbcRef)",
        "!doc": "For documentation of this method, see\n java.sql.PreparedStatement#setRef(int, java.sql.Ref)."
      },
      "setRowId": {
        "!type": "fn(parameterIndex: number, x: Jdbc.JdbcRowId)",
        "!doc": "For documentation of this method, see\n java.sql.PreparedStatement#setRowId(int, java.sql.RowId)."
      },
      "setRowId ": {
        "!type": "fn(parameterName: string, x: Jdbc.JdbcRowId)",
        "!doc": "For documentation of this method, see\n java.sql.CallableStatement#setRowId(String, java.sql.RowId)."
      },
      "setSQLXML": {
        "!type": "fn(parameterIndex: number, x: Jdbc.JdbcSQLXML)",
        "!doc": "For documentation of this method, see\n java.sql.PreparedStatement#setSQLXML(int, java.sql.SQLXML)."
      },
      "setSQLXML ": {
        "!type": "fn(parameterName: string, xmlObject: Jdbc.JdbcSQLXML)",
        "!doc": "For documentation of this method, see\n java.sql.CallableStatement#setSQLXML(String, java.sql.SQLXML)."
      },
      "setShort": {
        "!type": "fn(parameterIndex: number, x: number)",
        "!doc": "For documentation of this method, see java.sql.PreparedStatement#setShort(int, short)."
      },
      "setShort ": {
        "!type": "fn(parameterName: string, x: number)",
        "!doc": "For documentation of this method, see\n java.sql.CallableStatement#setShort(String, short)."
      },
      "setString": {
        "!type": "fn(parameterIndex: number, x: string)",
        "!doc": "For documentation of this method, see\n java.sql.PreparedStatement#setString(int, String)."
      },
      "setString ": {
        "!type": "fn(parameterName: string, x: string)",
        "!doc": "For documentation of this method, see\n java.sql.CallableStatement#setString(String, String)."
      },
      "setTime": {
        "!type": "fn(parameterIndex: number, x: Jdbc.JdbcTime)",
        "!doc": "For documentation of this method, see\n java.sql.PreparedStatement#setTime(int, java.sql.Time)."
      },
      "setTime ": {
        "!type": "fn(parameterIndex: number, x: Jdbc.JdbcTime, timeZone: string)",
        "!doc": "For documentation of this method, see\n java.sql.PreparedStatement#setTime(int, java.sql.Time, java.util.Calendar)."
      },
      "setTime  ": {
        "!type": "fn(parameterName: string, x: Jdbc.JdbcTime)",
        "!doc": "For documentation of this method, see\n java.sql.CallableStatement#setTime(String, java.sql.Time)."
      },
      "setTime   ": {
        "!type": "fn(parameterName: string, x: Jdbc.JdbcTime, timeZone: string)",
        "!doc": "For documentation of this method, see\n java.sql.CallableStatement#setTime(String, java.sql.Time, java.util.Calendar)."
      },
      "setTimestamp": {
        "!type": "fn(parameterIndex: number, x: Jdbc.JdbcTimestamp)",
        "!doc": "For documentation of this method, see\n java.sql.PreparedStatement#setTimestamp(int, java.sql.Timestamp)."
      },
      "setTimestamp ": {
        "!type": "fn(parameterIndex: number, x: Jdbc.JdbcTimestamp, timeZone: string)",
        "!doc": "For documentation of this method, see\n java.sql.PreparedStatement#setTimestamp(int, java.sql.Timestamp, java.util.Calendar)."
      },
      "setTimestamp  ": {
        "!type": "fn(parameterName: string, x: Jdbc.JdbcTimestamp)",
        "!doc": "For documentation of this method, see\n java.sql.CallableStatement#setTimestamp(String, java.sql.Timestamp)."
      },
      "setTimestamp   ": {
        "!type": "fn(parameterName: string, x: Jdbc.JdbcTimestamp, timeZone: string)",
        "!doc": "For documentation of this method, see java.sql.CallableStatement#setTimestamp(String, java.sql.Timestamp, java.util.Calendar)."
      },
      "setURL": {
        "!type": "fn(parameterIndex: number, x: string)",
        "!doc": "For documentation of this method, see\n java.sql.PreparedStatement#setURL(int, java.net.URL)."
      },
      "setURL ": {
        "!type": "fn(parameterName: string, val: string)",
        "!doc": "For documentation of this method, see\n java.sql.CallableStatement#setURL(String, java.net.URL)."
      },
      "wasNull": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see\n java.sql.CallableStatement#wasNull()."
      }
    },
    "Jdbc.JdbcClob": {
      "free": {
        "!type": "fn()",
        "!doc": "For documentation of this method, see java.sql.Clob#free()."
      },
      "getAppsScriptBlob": {
        "!type": "fn() -> Blob",
        "!doc": "Gets the content of this JdbcClob as an Apps Script blob."
      },
      "getAs": {
        "!type": "fn(contentType: string) -> Blob",
        "!doc": "Return the data inside this object as a blob converted to the specified content type. This\n method adds the appropriate extension to the filename ? for example, \"myfile.pdf\". However, it\n assumes that the part of the filename that follows the last period (if any) is an existing\n extension that should be replaced. Consequently, \"ChristmasList.12.25.2014\" will become\n \"ChristmasList.12.25.pdf\"."
      },
      "getSubString": {
        "!type": "fn(position: number, length: number) -> string",
        "!doc": "For documentation of this method, see java.sql.Clob#getSubString(long, int)."
      },
      "length": {
        "!type": "fn() -> number",
        "!doc": "For documentation of this method, see java.sql.Clob#length()."
      },
      "position": {
        "!type": "fn(search: Jdbc.JdbcClob, start: number) -> number",
        "!doc": "For documentation of this method, see java.sql.Clob#position(java.sql.Clob, long)."
      },
      "position ": {
        "!type": "fn(search: string, start: number) -> number",
        "!doc": "For documentation of this method, see java.sql.Clob#position(String, long)."
      },
      "setString": {
        "!type": "fn(position: number, blobSource: BlobSource) -> number",
        "!doc": "Convenience method for BlobSources."
      },
      "setString ": {
        "!type": "fn(position: number, blobSource: BlobSource, offset: number, len: number) -> number",
        "!doc": "Convenience method for BlobSources."
      },
      "setString  ": {
        "!type": "fn(position: number, value: string) -> number",
        "!doc": "For documentation of this method, see java.sql.Clob#setString(long, String)."
      },
      "setString   ": {
        "!type": "fn(position: number, value: string, offset: number, len: number) -> number",
        "!doc": "For documentation of this method, see java.sql.Clob#setString(long, String, int, int)."
      },
      "truncate": {
        "!type": "fn(length: number)",
        "!doc": "For documentation of this method, see java.sql.Clob#truncate(long)."
      }
    },
    "Jdbc.JdbcConnection": {
      "TRANSACTION_NONE": {
        "!type": "number"
      },
      "TRANSACTION_READ_COMMITTED": {
        "!type": "number"
      },
      "TRANSACTION_READ_UNCOMMITTED": {
        "!type": "number"
      },
      "TRANSACTION_REPEATABLE_READ": {
        "!type": "number"
      },
      "TRANSACTION_SERIALIZABLE": {
        "!type": "number"
      },
      "clearWarnings": {
        "!type": "fn()",
        "!doc": "For documentation of this method, see java.sql.Connection#clearWarnings()."
      },
      "close": {
        "!type": "fn()",
        "!doc": "Release the JdbcConnection's database and all associated resources.\n\n \n \n var conn = Jdbc.getConnection(&quot;jdbc:mysql://&lt;host&gt;:&lt;port&gt;/&lt;instance&gt;&quot;, &quot;user&quot;, &quot;password&quot;);\n conn.close();\n "
      },
      "commit": {
        "!type": "fn()",
        "!doc": "Makes all pending changes permanent, releases database locks held by this JdbcConnection.\n\n \n \n var conn = Jdbc.getConnection(&quot;jdbc:mysql://&lt;host&gt;:&lt;port&gt;/&lt;instance&gt;&quot;, &quot;user&quot;, &quot;password&quot;);\n conn.setAutoCommit(false);\n var stmt = conn.prepareStatement(&quot;insert into person (lname,fname) values (?,?)&quot;);\n var start = new Date();\n for (var i = 0; i &lt; 5000; i++) {\n   // Objects are accessed using 1-based indexing\n   stmt.setObject(1, &#39;firstName&#39; + i);\n   stmt.setObject(2, &#39;lastName&#39; + i);\n   stmt.addBatch();\n }\n var res = stmt.executeBatch();\n conn.commit(); // When this returns, this is when changes are actually commited\n conn.close();\n "
      },
      "createArrayOf": {
        "!type": "fn(typeName: string, elements: [object]) -> Jdbc.JdbcArray",
        "!doc": "For documentation of this method, see\n java.sql.Connection#createArrayOf(String, Object[])."
      },
      "createBlob": {
        "!type": "fn() -> Jdbc.JdbcBlob",
        "!doc": "Constructs a JdbcBlob instance\n\n The object returned initially contains no data. The setBytes methods of JdbcBlob may\n be used to set the data it should contain. Note that the blob used here is not the same\n as the blob created with\n Utilities.newBlob(data). To\n convert between the two formats, use the defined getBytes() and setBytes() methods.\n Alternatively, both JdbcBlob and JdbcClob provide a getAppsScriptBlob()\n convenience method for converting to a format that can be used by Apps Script."
      },
      "createClob": {
        "!type": "fn() -> Jdbc.JdbcClob",
        "!doc": "For documentation of this method, see java.sql.Connection#createClob()."
      },
      "createNClob": {
        "!type": "fn() -> Jdbc.JdbcClob",
        "!doc": "For documentation of this method, see java.sql.Connection#createNClob()."
      },
      "createSQLXML": {
        "!type": "fn() -> Jdbc.JdbcSQLXML",
        "!doc": "For documentation of this method, see java.sql.Connection#createSQLXML()."
      },
      "createStatement": {
        "!type": "fn() -> Jdbc.JdbcStatement",
        "!doc": "Creates a JdbcStatement object for sending SQL statements to the database.\n\n \n \n // This sample code assumes authentication is off\n var conn = Jdbc.getConnection(&quot;jdbc:mysql://&lt;host&gt;:3306/&lt;instance&gt;&quot;)\n var stmt = conn.createStatement();\n\n stmt.setMaxRows(100);\n var rs = stmt.execute(&quot;select * from person&quot;);\n\n while(rs.next()) {\n   // Do something\n }\n\n rs.close();\n stmt.close();\n conn.close();\n"
      },
      "createStatement ": {
        "!type": "fn(resultSetType: number, resultSetConcurrency: number) -> Jdbc.JdbcStatement",
        "!doc": "Creates a JdbcStatement object for sending SQL statements to the database.\n\n This version allows the result set type and concurrency to be overridden.\n\n \n \n // This sample code assumes authentication is off\n // For more information about this method, see documentation here:\n //  http://docs.oracle.com/javase/6/docs/api/java/sql/Connection.html#createStatement(int, int)\n var conn = Jdbc.getConnection(&quot;jdbc:mysql://&lt;host&gt;:3306/&lt;instance&gt;&quot;)\n var stmt = conn.createStatement(Jdbc.ResultSet.TYPE_FORWARD_ONLY,\n                                 Jdbc.ResultSet.CONCUR_READ_ONLY);\n\n stmt.setMaxRows(100);\n var rs = stmt.execute(&quot;select * from person&quot;);\n\n while(rs.next()) {\n   // Do something\n }\n\n rs.close();\n stmt.close();\n conn.close();\n"
      },
      "createStatement  ": {
        "!type": "fn(resultSetType: number, resultSetConcurrency: number, resultSetHoldability: number) -> Jdbc.JdbcStatement",
        "!doc": "Creates a JdbcStatement object for sending SQL statements to the database.\n\n This version allows the result set type, concurrency and holdability to be overridden.\n\n \n \n // This sample code assumes authentication is off\n // For more information about this method, see documentation here:\n //  http://docs.oracle.com/javase/6/docs/api/java/sql/Connection.html#createStatement(int, int)\n var conn = Jdbc.getConnection(&quot;jdbc:mysql://&lt;host&gt;:3306/&lt;instance&gt;&quot;)\n var stmt = conn.createStatement(Jdbc.ResultSet.TYPE_FORWARD_ONLY,\n                                 Jdbc.ResultSet.CONCUR_READ_ONLY,\n                                 Jdbc.ResultSet.HOLD_CURSORS_OVER_COMMIT);\n\n stmt.setMaxRows(100);\n var rs = stmt.execute(&quot;select * from person&quot;);\n\n while(rs.next()) {\n   // Do something\n }\n\n rs.close();\n stmt.close();\n conn.close();\n"
      },
      "createStruct": {
        "!type": "fn(typeName: string, attributes: [object]) -> Jdbc.JdbcStruct",
        "!doc": "For documentation of this method, see\n java.sql.Connection#createStruct(String, Object[])."
      },
      "getAutoCommit": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see java.sql.Connection#getAutoCommit()."
      },
      "getCatalog": {
        "!type": "fn() -> string",
        "!doc": "For documentation of this method, see java.sql.Connection#getCatalog()."
      },
      "getHoldability": {
        "!type": "fn() -> number",
        "!doc": "For documentation of this method, see java.sql.Connection#getHoldability()."
      },
      "getMetaData": {
        "!type": "fn() -> Jdbc.JdbcDatabaseMetaData",
        "!doc": "For documentation of this method, see java.sql.Connection#getMetaData()."
      },
      "getTransactionIsolation": {
        "!type": "fn() -> number",
        "!doc": "For documentation of this method, see java.sql.Connection#getTransactionIsolation()."
      },
      "getWarnings": {
        "!type": "fn() -> [string]",
        "!doc": "For documentation of this method, see java.sql.Connection#getWarnings()."
      },
      "isClosed": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see java.sql.Connection#isClosed()."
      },
      "isReadOnly": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see java.sql.Connection#isReadOnly()."
      },
      "isValid": {
        "!type": "fn(timeout: number) -> bool",
        "!doc": "For documentation of this method, see java.sql.Connection#isValid(int)."
      },
      "nativeSQL": {
        "!type": "fn(sql: string) -> string",
        "!doc": "For documentation of this method, see java.sql.Connection#nativeSQL(String)."
      },
      "prepareCall": {
        "!type": "fn(sql: string) -> Jdbc.JdbcCallableStatement",
        "!doc": "For documentation of this method, see java.sql.Connection#prepareCall(String)."
      },
      "prepareCall ": {
        "!type": "fn(sql: string, resultSetType: number, resultSetConcurrency: number) -> Jdbc.JdbcCallableStatement",
        "!doc": "For documentation of this method, see\n java.sql.Connection#prepareCall(String, int, int)."
      },
      "prepareCall  ": {
        "!type": "fn(sql: string, resultSetType: number, resultSetConcurrency: number, resultSetHoldability: number) -> Jdbc.JdbcCallableStatement",
        "!doc": "For documentation of this method, see\n java.sql.Connection#prepareCall(String, int, int, int)."
      },
      "prepareStatement": {
        "!type": "fn(sql: string) -> Jdbc.JdbcPreparedStatement",
        "!doc": "For documentation of this method, see java.sql.Connection#prepareStatement(String)."
      },
      "prepareStatement ": {
        "!type": "fn(sql: string, autoGeneratedKeys: number) -> Jdbc.JdbcPreparedStatement",
        "!doc": "For documentation of this method, see\n java.sql.Connection#prepareStatement(String, int)."
      },
      "prepareStatement  ": {
        "!type": "fn(sql: string, resultSetType: number, resultSetConcurrency: number) -> Jdbc.JdbcPreparedStatement",
        "!doc": "For documentation of this method, see\n java.sql.Connection#prepareStatement(String, int, int)."
      },
      "prepareStatement   ": {
        "!type": "fn(sql: string, resultSetType: number, resultSetConcurrency: number, resultSetHoldability: number) -> Jdbc.JdbcPreparedStatement",
        "!doc": "For documentation of this method, see\n java.sql.Connection#prepareStatement(String, int, int, int)."
      },
      "prepareStatementByIndex": {
        "!type": "fn(sql: string, indices: [number]) -> Jdbc.JdbcPreparedStatement",
        "!doc": "For documentation of this method, see\n java.sql.Connection#prepareStatement(String, int[])."
      },
      "prepareStatementByName": {
        "!type": "fn(sql: string, columnNames: [string]) -> Jdbc.JdbcPreparedStatement",
        "!doc": "For documentation of this method, see\n java.sql.Connection#prepareStatement(String, String[])."
      },
      "releaseSavepoint": {
        "!type": "fn(savepoint: Jdbc.JdbcSavepoint)",
        "!doc": "For documentation of this method, see\n java.sql.Connection#releaseSavepoint(java.sql.Savepoint)."
      },
      "rollback": {
        "!type": "fn()",
        "!doc": "For documentation of this method, see java.sql.Connection#rollback()."
      },
      "rollback ": {
        "!type": "fn(savepoint: Jdbc.JdbcSavepoint)",
        "!doc": "For documentation of this method, see\n java.sql.Connection#rollback(java.sql.Savepoint)."
      },
      "setAutoCommit": {
        "!type": "fn(autoCommit: bool)",
        "!doc": "For documentation of this method, see java.sql.Connection#setAutoCommit(boolean)."
      },
      "setCatalog": {
        "!type": "fn(catalog: string)",
        "!doc": "For documentation of this method, see java.sql.Connection#setCatalog(String)."
      },
      "setHoldability": {
        "!type": "fn(holdability: number)",
        "!doc": "For documentation of this method, see java.sql.Connection#setHoldability(int)."
      },
      "setReadOnly": {
        "!type": "fn(readOnly: bool)",
        "!doc": "For documentation of this method, see java.sql.Connection#setReadOnly(boolean)."
      },
      "setSavepoint": {
        "!type": "fn() -> Jdbc.JdbcSavepoint",
        "!doc": "For documentation of this method, see java.sql.Connection#setSavepoint()."
      },
      "setSavepoint ": {
        "!type": "fn(name: string) -> Jdbc.JdbcSavepoint",
        "!doc": "For documentation of this method, see java.sql.Connection#setSavepoint(String)."
      },
      "setTransactionIsolation": {
        "!type": "fn(level: number)",
        "!doc": "For documentation of this method, see\n java.sql.Connection#setTransactionIsolation(int)."
      }
    },
    "Jdbc.JdbcDatabaseMetaData": {
      "attributeNoNulls": {
        "!type": "number"
      },
      "attributeNullable": {
        "!type": "number"
      },
      "attributeNullableUnknown": {
        "!type": "number"
      },
      "bestRowNotPseudo": {
        "!type": "number"
      },
      "bestRowPseudo": {
        "!type": "number"
      },
      "bestRowSession": {
        "!type": "number"
      },
      "bestRowTemporary": {
        "!type": "number"
      },
      "bestRowTransaction": {
        "!type": "number"
      },
      "bestRowUnknown": {
        "!type": "number"
      },
      "columnNoNulls": {
        "!type": "number"
      },
      "columnNullable": {
        "!type": "number"
      },
      "columnNullableUnknown": {
        "!type": "number"
      },
      "functionColumnIn": {
        "!type": "number"
      },
      "functionColumnInOut": {
        "!type": "number"
      },
      "functionColumnOut": {
        "!type": "number"
      },
      "functionColumnResult": {
        "!type": "number"
      },
      "functionColumnUnknown": {
        "!type": "number"
      },
      "functionNoNulls": {
        "!type": "number"
      },
      "functionNoTable": {
        "!type": "number"
      },
      "functionNullable": {
        "!type": "number"
      },
      "functionNullableUnknown": {
        "!type": "number"
      },
      "functionResultUnknown": {
        "!type": "number"
      },
      "functionReturn": {
        "!type": "number"
      },
      "functionReturnsTable": {
        "!type": "number"
      },
      "importedKeyCascade": {
        "!type": "number"
      },
      "importedKeyInitiallyDeferred": {
        "!type": "number"
      },
      "importedKeyInitiallyImmediate": {
        "!type": "number"
      },
      "importedKeyNoAction": {
        "!type": "number"
      },
      "importedKeyNotDeferrable": {
        "!type": "number"
      },
      "importedKeyRestrict": {
        "!type": "number"
      },
      "importedKeySetDefault": {
        "!type": "number"
      },
      "importedKeySetNull": {
        "!type": "number"
      },
      "procedureColumnIn": {
        "!type": "number"
      },
      "procedureColumnInOut": {
        "!type": "number"
      },
      "procedureColumnOut": {
        "!type": "number"
      },
      "procedureColumnResult": {
        "!type": "number"
      },
      "procedureColumnReturn": {
        "!type": "number"
      },
      "procedureColumnUnknown": {
        "!type": "number"
      },
      "procedureNoNulls": {
        "!type": "number"
      },
      "procedureNullable": {
        "!type": "number"
      },
      "procedureNullableUnknown": {
        "!type": "number"
      },
      "sqlStateSQL": {
        "!type": "number"
      },
      "sqlStateSQL99": {
        "!type": "number"
      },
      "sqlStateXOpen": {
        "!type": "number"
      },
      "tableIndexClustered": {
        "!type": "number"
      },
      "tableIndexHashed": {
        "!type": "number"
      },
      "tableIndexOther": {
        "!type": "number"
      },
      "tableIndexStatistic": {
        "!type": "number"
      },
      "typeNoNulls": {
        "!type": "number"
      },
      "typeNullable": {
        "!type": "number"
      },
      "typeNullableUnknown": {
        "!type": "number"
      },
      "typePredBasic": {
        "!type": "number"
      },
      "typePredChar": {
        "!type": "number"
      },
      "typePredNone": {
        "!type": "number"
      },
      "typeSearchable": {
        "!type": "number"
      },
      "versionColumnNotPseudo": {
        "!type": "number"
      },
      "versionColumnPseudo": {
        "!type": "number"
      },
      "versionColumnUnknown": {
        "!type": "number"
      },
      "allProceduresAreCallable": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#allProceduresAreCallable()."
      },
      "allTablesAreSelectable": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#allTablesAreSelectable()."
      },
      "autoCommitFailureClosesAllResultSets": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#autoCommitFailureClosesAllResultSets()."
      },
      "dataDefinitionCausesTransactionCommit": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#dataDefinitionCausesTransactionCommit()."
      },
      "dataDefinitionIgnoredInTransactions": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#dataDefinitionIgnoredInTransactions()."
      },
      "deletesAreDetected": {
        "!type": "fn(type: number) -> bool",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#deletesAreDetected(int)."
      },
      "doesMaxRowSizeIncludeBlobs": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#doesMaxRowSizeIncludeBlobs()."
      },
      "getAttributes": {
        "!type": "fn(catalog: string, schemaPattern: string, typeNamePattern: string, attributeNamePattern: string) -> Jdbc.JdbcResultSet",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#getAttributes(String, String, String, String)."
      },
      "getBestRowIdentifier": {
        "!type": "fn(catalog: string, schema: string, table: string, scope: number, nullable: bool) -> Jdbc.JdbcResultSet",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#getBestRowIdentifier(String, String, String, int, boolean)."
      },
      "getCatalogSeparator": {
        "!type": "fn() -> string",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#getCatalogSeparator()."
      },
      "getCatalogTerm": {
        "!type": "fn() -> string",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#getCatalogTerm()."
      },
      "getCatalogs": {
        "!type": "fn() -> Jdbc.JdbcResultSet",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#getCatalogs()."
      },
      "getClientInfoProperties": {
        "!type": "fn() -> Jdbc.JdbcResultSet",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#getClientInfoProperties()."
      },
      "getColumnPrivileges": {
        "!type": "fn(catalog: string, schema: string, table: string, columnNamePattern: string) -> Jdbc.JdbcResultSet",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#getColumnPrivileges(String, String, String, String)."
      },
      "getColumns": {
        "!type": "fn(catalog: string, schemaPattern: string, tableNamePattern: string, columnNamePattern: string) -> Jdbc.JdbcResultSet",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#getColumns(String, String, String, String)."
      },
      "getConnection": {
        "!type": "fn() -> Jdbc.JdbcConnection",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#getConnection()."
      },
      "getCrossReference": {
        "!type": "fn(parentCatalog: string, parentSchema: string, parentTable: string, foreignCatalog: string, foreignSchema: string, foreignTable: string) -> Jdbc.JdbcResultSet",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#getCrossReference(String, String, String, String, String,\n String)."
      },
      "getDatabaseMajorVersion": {
        "!type": "fn() -> number",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#getDatabaseMajorVersion()."
      },
      "getDatabaseMinorVersion": {
        "!type": "fn() -> number",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#getDatabaseMinorVersion()."
      },
      "getDatabaseProductName": {
        "!type": "fn() -> string",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#getDatabaseProductName()."
      },
      "getDatabaseProductVersion": {
        "!type": "fn() -> string",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#getDatabaseProductVersion()."
      },
      "getDefaultTransactionIsolation": {
        "!type": "fn() -> number",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#getDefaultTransactionIsolation()."
      },
      "getDriverMajorVersion": {
        "!type": "fn() -> number",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#getDriverMajorVersion()."
      },
      "getDriverMinorVersion": {
        "!type": "fn() -> number",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#getDriverMinorVersion()."
      },
      "getDriverName": {
        "!type": "fn() -> string",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#getDriverName()."
      },
      "getDriverVersion": {
        "!type": "fn() -> string",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#getDriverVersion()."
      },
      "getExportedKeys": {
        "!type": "fn(catalog: string, schema: string, table: string) -> Jdbc.JdbcResultSet",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#getExportedKeys(String, String, String)."
      },
      "getExtraNameCharacters": {
        "!type": "fn() -> string",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#getExtraNameCharacters()."
      },
      "getFunctionColumns": {
        "!type": "fn(catalog: string, schemaPattern: string, functionNamePattern: string, columnNamePattern: string) -> Jdbc.JdbcResultSet",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#getFunctionColumns(String, String, String, String)."
      },
      "getFunctions": {
        "!type": "fn(catalog: string, schemaPattern: string, functionNamePattern: string) -> Jdbc.JdbcResultSet",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#getFunctions(String, String, String)."
      },
      "getIdentifierQuoteString": {
        "!type": "fn() -> string",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#getIdentifierQuoteString()."
      },
      "getImportedKeys": {
        "!type": "fn(catalog: string, schema: string, table: string) -> Jdbc.JdbcResultSet",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#getImportedKeys(String, String, String)."
      },
      "getIndexInfo": {
        "!type": "fn(catalog: string, schema: string, table: string, unique: bool, approximate: bool) -> Jdbc.JdbcResultSet",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#getIndexInfo(String, String, String, boolean, boolean)."
      },
      "getJDBCMajorVersion": {
        "!type": "fn() -> number",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#getJDBCMajorVersion()."
      },
      "getJDBCMinorVersion": {
        "!type": "fn() -> number",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#getJDBCMinorVersion()."
      },
      "getMaxBinaryLiteralLength": {
        "!type": "fn() -> number",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#getMaxBinaryLiteralLength()."
      },
      "getMaxCatalogNameLength": {
        "!type": "fn() -> number",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#getMaxCatalogNameLength()."
      },
      "getMaxCharLiteralLength": {
        "!type": "fn() -> number",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#getMaxCharLiteralLength()."
      },
      "getMaxColumnNameLength": {
        "!type": "fn() -> number",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#getMaxColumnNameLength()."
      },
      "getMaxColumnsInGroupBy": {
        "!type": "fn() -> number",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#getMaxColumnsInGroupBy()."
      },
      "getMaxColumnsInIndex": {
        "!type": "fn() -> number",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#getMaxColumnsInIndex()."
      },
      "getMaxColumnsInOrderBy": {
        "!type": "fn() -> number",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#getMaxColumnsInOrderBy()."
      },
      "getMaxColumnsInSelect": {
        "!type": "fn() -> number",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#getMaxColumnsInSelect()."
      },
      "getMaxColumnsInTable": {
        "!type": "fn() -> number",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#getMaxColumnsInTable()."
      },
      "getMaxConnections": {
        "!type": "fn() -> number",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#getMaxConnections()."
      },
      "getMaxCursorNameLength": {
        "!type": "fn() -> number",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#getMaxCursorNameLength()."
      },
      "getMaxIndexLength": {
        "!type": "fn() -> number",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#getMaxIndexLength()."
      },
      "getMaxProcedureNameLength": {
        "!type": "fn() -> number",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#getMaxProcedureNameLength()."
      },
      "getMaxRowSize": {
        "!type": "fn() -> number",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#getMaxRowSize()."
      },
      "getMaxSchemaNameLength": {
        "!type": "fn() -> number",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#getMaxSchemaNameLength()."
      },
      "getMaxStatementLength": {
        "!type": "fn() -> number",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#getMaxStatementLength()."
      },
      "getMaxStatements": {
        "!type": "fn() -> number",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#getMaxStatements()."
      },
      "getMaxTableNameLength": {
        "!type": "fn() -> number",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#getMaxTableNameLength()."
      },
      "getMaxTablesInSelect": {
        "!type": "fn() -> number",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#getMaxTablesInSelect()."
      },
      "getMaxUserNameLength": {
        "!type": "fn() -> number",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#getMaxUserNameLength()."
      },
      "getNumericFunctions": {
        "!type": "fn() -> string",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#getNumericFunctions()."
      },
      "getPrimaryKeys": {
        "!type": "fn(catalog: string, schema: string, table: string) -> Jdbc.JdbcResultSet",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#getPrimaryKeys(String, String, String)."
      },
      "getProcedureColumns": {
        "!type": "fn(catalog: string, schemaPattern: string, procedureNamePattern: string, columnNamePattern: string) -> Jdbc.JdbcResultSet",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#getProcedureColumns(String, String, String, String)."
      },
      "getProcedureTerm": {
        "!type": "fn() -> string",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#getProcedureTerm()."
      },
      "getProcedures": {
        "!type": "fn(catalog: string, schemaPattern: string, procedureNamePattern: string) -> Jdbc.JdbcResultSet",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#getProcedures(String, String, String)."
      },
      "getResultSetHoldability": {
        "!type": "fn() -> number",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#getResultSetHoldability()."
      },
      "getRowIdLifetime": {
        "!type": "fn() -> number",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#getRowIdLifetime()."
      },
      "getSQLKeywords": {
        "!type": "fn() -> string",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#getSQLKeywords()."
      },
      "getSQLStateType": {
        "!type": "fn() -> number",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#getSQLStateType()."
      },
      "getSchemaTerm": {
        "!type": "fn() -> string",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#getSchemaTerm()."
      },
      "getSchemas": {
        "!type": "fn() -> Jdbc.JdbcResultSet",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#getSchemas()."
      },
      "getSchemas ": {
        "!type": "fn(catalog: string, schemaPattern: string) -> Jdbc.JdbcResultSet",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#getSchemas(String, String)."
      },
      "getSearchStringEscape": {
        "!type": "fn() -> string",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#getSearchStringEscape()."
      },
      "getStringFunctions": {
        "!type": "fn() -> string",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#getStringFunctions()."
      },
      "getSuperTables": {
        "!type": "fn(catalog: string, schemaPattern: string, tableNamePattern: string) -> Jdbc.JdbcResultSet",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#getSuperTables(String, String, String)."
      },
      "getSuperTypes": {
        "!type": "fn(catalog: string, schemaPattern: string, typeNamePattern: string) -> Jdbc.JdbcResultSet",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#getSuperTypes(String, String, String)."
      },
      "getSystemFunctions": {
        "!type": "fn() -> string",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#getSystemFunctions()."
      },
      "getTablePrivileges": {
        "!type": "fn(catalog: string, schemaPattern: string, tableNamePattern: string) -> Jdbc.JdbcResultSet",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#getTablePrivileges(String, String, String)."
      },
      "getTableTypes": {
        "!type": "fn() -> Jdbc.JdbcResultSet",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#getTableTypes()."
      },
      "getTables": {
        "!type": "fn(catalog: string, schemaPattern: string, tableNamePattern: string, types: [string]) -> Jdbc.JdbcResultSet",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#getTables(String, String, String, String[])."
      },
      "getTimeDateFunctions": {
        "!type": "fn() -> string",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#getTimeDateFunctions()."
      },
      "getTypeInfo": {
        "!type": "fn() -> Jdbc.JdbcResultSet",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#getTypeInfo()."
      },
      "getUDTs": {
        "!type": "fn(catalog: string, schemaPattern: string, typeNamePattern: string, types: [number]) -> Jdbc.JdbcResultSet",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#getUDTs(String, String, String, int[])."
      },
      "getURL": {
        "!type": "fn() -> string",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#getURL()."
      },
      "getUserName": {
        "!type": "fn() -> string",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#getUserName()."
      },
      "getVersionColumns": {
        "!type": "fn(catalog: string, schema: string, table: string) -> Jdbc.JdbcResultSet",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#getVersionColumns(String, String, String)."
      },
      "insertsAreDetected": {
        "!type": "fn(type: number) -> bool",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#insertsAreDetected(int)."
      },
      "isCatalogAtStart": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#isCatalogAtStart()."
      },
      "isReadOnly": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#isReadOnly()."
      },
      "locatorsUpdateCopy": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#locatorsUpdateCopy()."
      },
      "nullPlusNonNullIsNull": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#nullPlusNonNullIsNull()."
      },
      "nullsAreSortedAtEnd": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#nullsAreSortedAtEnd()."
      },
      "nullsAreSortedAtStart": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#nullsAreSortedAtStart()."
      },
      "nullsAreSortedHigh": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#nullsAreSortedHigh()."
      },
      "nullsAreSortedLow": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#nullsAreSortedLow()."
      },
      "othersDeletesAreVisible": {
        "!type": "fn(type: number) -> bool",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#othersDeletesAreVisible(int)."
      },
      "othersInsertsAreVisible": {
        "!type": "fn(type: number) -> bool",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#othersInsertsAreVisible(int)."
      },
      "othersUpdatesAreVisible": {
        "!type": "fn(type: number) -> bool",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#othersUpdatesAreVisible(int)."
      },
      "ownDeletesAreVisible": {
        "!type": "fn(type: number) -> bool",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#ownDeletesAreVisible(int)."
      },
      "ownInsertsAreVisible": {
        "!type": "fn(type: number) -> bool",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#ownInsertsAreVisible(int)."
      },
      "ownUpdatesAreVisible": {
        "!type": "fn(type: number) -> bool",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#ownUpdatesAreVisible(int)."
      },
      "storesLowerCaseIdentifiers": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#storesLowerCaseIdentifiers()."
      },
      "storesLowerCaseQuotedIdentifiers": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#storesLowerCaseQuotedIdentifiers()."
      },
      "storesMixedCaseIdentifiers": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#storesMixedCaseIdentifiers()."
      },
      "storesMixedCaseQuotedIdentifiers": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#storesMixedCaseQuotedIdentifiers()."
      },
      "storesUpperCaseIdentifiers": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#storesUpperCaseIdentifiers()."
      },
      "storesUpperCaseQuotedIdentifiers": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#storesUpperCaseQuotedIdentifiers()."
      },
      "supportsANSI92EntryLevelSQL": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#supportsANSI92EntryLevelSQL()."
      },
      "supportsANSI92FullSQL": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#supportsANSI92FullSQL()."
      },
      "supportsANSI92IntermediateSQL": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#supportsANSI92IntermediateSQL()."
      },
      "supportsAlterTableWithAddColumn": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#supportsAlterTableWithAddColumn()."
      },
      "supportsAlterTableWithDropColumn": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#supportsAlterTableWithDropColumn()."
      },
      "supportsBatchUpdates": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#supportsBatchUpdates()."
      },
      "supportsCatalogsInDataManipulation": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#supportsCatalogsInDataManipulation()."
      },
      "supportsCatalogsInIndexDefinitions": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#supportsCatalogsInIndexDefinitions()."
      },
      "supportsCatalogsInPrivilegeDefinitions": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#supportsCatalogsInPrivilegeDefinitions()."
      },
      "supportsCatalogsInProcedureCalls": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#supportsCatalogsInProcedureCalls()."
      },
      "supportsCatalogsInTableDefinitions": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#supportsCatalogsInTableDefinitions()."
      },
      "supportsColumnAliasing": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#supportsColumnAliasing()."
      },
      "supportsConvert": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#supportsConvert()."
      },
      "supportsConvert ": {
        "!type": "fn(fromType: number, toType: number) -> bool",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#supportsConvert(int, int)."
      },
      "supportsCoreSQLGrammar": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#supportsCoreSQLGrammar()."
      },
      "supportsCorrelatedSubqueries": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#supportsCorrelatedSubqueries()."
      },
      "supportsDataDefinitionAndDataManipulationTransactions": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#supportsDataDefinitionAndDataManipulationTransactions()."
      },
      "supportsDataManipulationTransactionsOnly": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#supportsDataManipulationTransactionsOnly()."
      },
      "supportsDifferentTableCorrelationNames": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#supportsDifferentTableCorrelationNames()."
      },
      "supportsExpressionsInOrderBy": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#supportsExpressionsInOrderBy()."
      },
      "supportsExtendedSQLGrammar": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#supportsExtendedSQLGrammar()."
      },
      "supportsFullOuterJoins": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#supportsFullOuterJoins()."
      },
      "supportsGetGeneratedKeys": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#supportsGetGeneratedKeys()."
      },
      "supportsGroupBy": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#supportsGroupBy()."
      },
      "supportsGroupByBeyondSelect": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#supportsGroupByBeyondSelect()."
      },
      "supportsGroupByUnrelated": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#supportsGroupByUnrelated()."
      },
      "supportsIntegrityEnhancementFacility": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#supportsIntegrityEnhancementFacility()."
      },
      "supportsLikeEscapeClause": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#supportsLikeEscapeClause()."
      },
      "supportsLimitedOuterJoins": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#supportsLimitedOuterJoins()."
      },
      "supportsMinimumSQLGrammar": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#supportsMinimumSQLGrammar()."
      },
      "supportsMixedCaseIdentifiers": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#supportsMixedCaseIdentifiers()."
      },
      "supportsMixedCaseQuotedIdentifiers": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#supportsMixedCaseQuotedIdentifiers()."
      },
      "supportsMultipleOpenResults": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#supportsMultipleOpenResults()."
      },
      "supportsMultipleResultSets": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#supportsMultipleResultSets()."
      },
      "supportsMultipleTransactions": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#supportsMultipleTransactions()."
      },
      "supportsNamedParameters": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#supportsNamedParameters()."
      },
      "supportsNonNullableColumns": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#supportsNonNullableColumns()."
      },
      "supportsOpenCursorsAcrossCommit": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#supportsOpenCursorsAcrossCommit()."
      },
      "supportsOpenCursorsAcrossRollback": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#supportsOpenCursorsAcrossRollback()."
      },
      "supportsOpenStatementsAcrossCommit": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#supportsOpenStatementsAcrossCommit()."
      },
      "supportsOpenStatementsAcrossRollback": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#supportsOpenStatementsAcrossRollback()."
      },
      "supportsOrderByUnrelated": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#supportsOrderByUnrelated()."
      },
      "supportsOuterJoins": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#supportsOuterJoins()."
      },
      "supportsPositionedDelete": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#supportsPositionedDelete()."
      },
      "supportsPositionedUpdate": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#supportsPositionedUpdate()."
      },
      "supportsResultSetConcurrency": {
        "!type": "fn(type: number, concurrency: number) -> bool",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#supportsResultSetConcurrency(int, int)."
      },
      "supportsResultSetHoldability": {
        "!type": "fn(holdability: number) -> bool",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#supportsResultSetHoldability(int)."
      },
      "supportsResultSetType": {
        "!type": "fn(type: number) -> bool",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#supportsResultSetType(int)."
      },
      "supportsSavepoints": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#supportsSavepoints()."
      },
      "supportsSchemasInDataManipulation": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#supportsSchemasInDataManipulation()."
      },
      "supportsSchemasInIndexDefinitions": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#supportsSchemasInIndexDefinitions()."
      },
      "supportsSchemasInPrivilegeDefinitions": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#supportsSchemasInPrivilegeDefinitions()."
      },
      "supportsSchemasInProcedureCalls": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#supportsSchemasInProcedureCalls()."
      },
      "supportsSchemasInTableDefinitions": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#supportsSchemasInTableDefinitions()."
      },
      "supportsSelectForUpdate": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#supportsSelectForUpdate()."
      },
      "supportsStatementPooling": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#supportsStatementPooling()."
      },
      "supportsStoredFunctionsUsingCallSyntax": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#supportsStoredFunctionsUsingCallSyntax()."
      },
      "supportsStoredProcedures": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#supportsStoredProcedures()."
      },
      "supportsSubqueriesInComparisons": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#supportsSubqueriesInComparisons()."
      },
      "supportsSubqueriesInExists": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#supportsSubqueriesInExists()."
      },
      "supportsSubqueriesInIns": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#supportsSubqueriesInIns()."
      },
      "supportsSubqueriesInQuantifieds": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#supportsSubqueriesInQuantifieds()."
      },
      "supportsTableCorrelationNames": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#supportsTableCorrelationNames()."
      },
      "supportsTransactionIsolationLevel": {
        "!type": "fn(level: number) -> bool",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#supportsTransactionIsolationLevel(int)."
      },
      "supportsTransactions": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#supportsTransactions()."
      },
      "supportsUnion": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#supportsUnion()."
      },
      "supportsUnionAll": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#supportsUnionAll()."
      },
      "updatesAreDetected": {
        "!type": "fn(type: number) -> bool",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#updatesAreDetected(int)."
      },
      "usesLocalFilePerTable": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#usesLocalFilePerTable()."
      },
      "usesLocalFiles": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see\n java.sql.DatabaseMetaData#usesLocalFiles()."
      }
    },
    "Jdbc.JdbcDate": {
      "after": {
        "!type": "fn(when: Jdbc.JdbcDate) -> bool",
        "!doc": "For documentation of this method, see java.sql.Date#after(java.util.Date)."
      },
      "before": {
        "!type": "fn(when: Jdbc.JdbcDate) -> bool",
        "!doc": "For documentation of this method, see java.sql.Date#before(java.util.Date)."
      },
      "getDate": {
        "!type": "fn() -> number",
        "!doc": "For documentation of this method, see java.sql.Date#getDate()."
      },
      "getMonth": {
        "!type": "fn() -> number",
        "!doc": "For documentation of this method, see java.sql.Date#getMonth()."
      },
      "getTime": {
        "!type": "fn() -> number",
        "!doc": "For documentation of this method, see java.sql.Date#getTime()."
      },
      "getYear": {
        "!type": "fn() -> number",
        "!doc": "For documentation of this method, see java.sql.Date#getYear()."
      },
      "setDate": {
        "!type": "fn(date: number)",
        "!doc": "For documentation of this method, see java.sql.Date#setDate(int)."
      },
      "setMonth": {
        "!type": "fn(month: number)",
        "!doc": "For documentation of this method, see java.sql.Date#setMonth(int)."
      },
      "setTime": {
        "!type": "fn(milliseconds: number)",
        "!doc": "For documentation of this method, see java.sql.Date#setTime(long)."
      },
      "setYear": {
        "!type": "fn(year: number)",
        "!doc": "For documentation of this method, see java.sql.Date#setYear(int)."
      }
    },
    "Jdbc.JdbcParameterMetaData": {
      "parameterModeIn": {
        "!type": "number"
      },
      "parameterModeInOut": {
        "!type": "number"
      },
      "parameterModeOut": {
        "!type": "number"
      },
      "parameterModeUnknown": {
        "!type": "number"
      },
      "parameterNoNulls": {
        "!type": "number"
      },
      "parameterNullable": {
        "!type": "number"
      },
      "parameterNullableUnknown": {
        "!type": "number"
      },
      "getParameterClassName": {
        "!type": "fn(param: number) -> string",
        "!doc": "For documentation of this method, see\n java.sql.ParameterMetaData#getParameterClassName(int)."
      },
      "getParameterCount": {
        "!type": "fn() -> number",
        "!doc": "For documentation of this method, see java.sql.ParameterMetaData#getParameterCount()."
      },
      "getParameterMode": {
        "!type": "fn(param: number) -> number",
        "!doc": "For documentation of this method, see\n java.sql.ParameterMetaData#getParameterMode(int)."
      },
      "getParameterType": {
        "!type": "fn(param: number) -> number",
        "!doc": "For documentation of this method, see\n java.sql.ParameterMetaData#getParameterType(int)."
      },
      "getParameterTypeName": {
        "!type": "fn(param: number) -> string",
        "!doc": "For documentation of this method, see\n java.sql.ParameterMetaData#getParameterTypeName(int)."
      },
      "getPrecision": {
        "!type": "fn(param: number) -> number",
        "!doc": "For documentation of this method, see java.sql.ParameterMetaData#getPrecision(int)."
      },
      "getScale": {
        "!type": "fn(param: number) -> number",
        "!doc": "For documentation of this method, see java.sql.ParameterMetaData#getScale(int)."
      },
      "isNullable": {
        "!type": "fn(param: number) -> number",
        "!doc": "For documentation of this method, see java.sql.ParameterMetaData#isNullable(int)."
      },
      "isSigned": {
        "!type": "fn(param: number) -> bool",
        "!doc": "For documentation of this method, see java.sql.ParameterMetaData#isSigned(int)."
      }
    },
    "Jdbc.JdbcPreparedStatement": {
      "addBatch": {
        "!type": "fn()",
        "!doc": "For documentation of this method, see java.sql.PreparedStatement#addBatch()."
      },
      "addBatch ": {
        "!type": "fn(sql: string)",
        "!doc": "For documentation of this method, see java.sql.Statement#addBatch(String)."
      },
      "cancel": {
        "!type": "fn()",
        "!doc": "For documentation of this method, see java.sql.Statement#cancel()."
      },
      "clearBatch": {
        "!type": "fn()",
        "!doc": "For documentation of this method, see java.sql.Statement#clearBatch()."
      },
      "clearParameters": {
        "!type": "fn()",
        "!doc": "For documentation of this method, see java.sql.PreparedStatement#clearParameters()."
      },
      "clearWarnings": {
        "!type": "fn()",
        "!doc": "For documentation of this method, see java.sql.Statement#clearWarnings()."
      },
      "close": {
        "!type": "fn()",
        "!doc": "For documentation of this method, see java.sql.Statement#close()."
      },
      "execute": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see java.sql.PreparedStatement#execute()."
      },
      "execute ": {
        "!type": "fn(sql: string) -> bool",
        "!doc": "For documentation of this method, see java.sql.Statement#execute(String)."
      },
      "execute  ": {
        "!type": "fn(sql: string, autoGeneratedKeys: number) -> bool",
        "!doc": "For documentation of this method, see java.sql.Statement#execute(String, int)."
      },
      "execute   ": {
        "!type": "fn(sql: string, columnIndexes: [number]) -> bool",
        "!doc": "For documentation of this method, see java.sql.Statement#execute(String, int[])."
      },
      "execute    ": {
        "!type": "fn(sql: string, columnNames: [string]) -> bool",
        "!doc": "For documentation of this method, see java.sql.Statement#execute(String, String[])."
      },
      "executeBatch": {
        "!type": "fn() -> [number]",
        "!doc": "For documentation of this method, see java.sql.Statement#executeBatch()."
      },
      "executeQuery": {
        "!type": "fn() -> Jdbc.JdbcResultSet",
        "!doc": "For documentation of this method, see java.sql.PreparedStatement#executeQuery()."
      },
      "executeQuery ": {
        "!type": "fn(sql: string) -> Jdbc.JdbcResultSet",
        "!doc": "For documentation of this method, see java.sql.Statement#executeQuery(String)."
      },
      "executeUpdate": {
        "!type": "fn() -> number",
        "!doc": "For documentation of this method, see java.sql.PreparedStatement#executeUpdate()."
      },
      "executeUpdate ": {
        "!type": "fn(sql: string) -> number",
        "!doc": "For documentation of this method, see java.sql.Statement#executeUpdate(String)."
      },
      "executeUpdate  ": {
        "!type": "fn(sql: string, autoGeneratedKeys: number) -> number",
        "!doc": "For documentation of this method, see java.sql.Statement#executeUpdate(String, int)."
      },
      "executeUpdate   ": {
        "!type": "fn(sql: string, columnIndexes: [number]) -> number",
        "!doc": "For documentation of this method, see java.sql.Statement#executeUpdate(String, int)."
      },
      "executeUpdate    ": {
        "!type": "fn(sql: string, columnNames: [string]) -> number",
        "!doc": "For documentation of this method, see\n java.sql.Statement#executeUpdate(String, String[])."
      },
      "getConnection": {
        "!type": "fn() -> Jdbc.JdbcConnection",
        "!doc": "For documentation of this method, see java.sql.Statement#getConnection()."
      },
      "getFetchDirection": {
        "!type": "fn() -> number",
        "!doc": "For documentation of this method, see java.sql.Statement#getFetchDirection()."
      },
      "getFetchSize": {
        "!type": "fn() -> number",
        "!doc": "For documentation of this method, see java.sql.Statement#getFetchSize()."
      },
      "getGeneratedKeys": {
        "!type": "fn() -> Jdbc.JdbcResultSet",
        "!doc": "For documentation of this method, see java.sql.Statement#getGeneratedKeys()."
      },
      "getMaxFieldSize": {
        "!type": "fn() -> number",
        "!doc": "For documentation of this method, see java.sql.Statement#getMaxFieldSize()."
      },
      "getMaxRows": {
        "!type": "fn() -> number",
        "!doc": "For documentation of this method, see java.sql.Statement#getMaxRows()."
      },
      "getMetaData": {
        "!type": "fn() -> Jdbc.JdbcResultSetMetaData",
        "!doc": "For documentation of this method, see java.sql.PreparedStatement#getMetaData()."
      },
      "getMoreResults": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see java.sql.Statement#getMoreResults()."
      },
      "getMoreResults ": {
        "!type": "fn(current: number) -> bool",
        "!doc": "For documentation of this method, see java.sql.Statement#getMoreResults(int)."
      },
      "getParameterMetaData": {
        "!type": "fn() -> Jdbc.JdbcParameterMetaData",
        "!doc": "For documentation of this method, see\n java.sql.PreparedStatement#getParameterMetaData()."
      },
      "getQueryTimeout": {
        "!type": "fn() -> number",
        "!doc": "For documentation of this method, see java.sql.Statement#getQueryTimeout()."
      },
      "getResultSet": {
        "!type": "fn() -> Jdbc.JdbcResultSet",
        "!doc": "For documentation of this method, see java.sql.Statement#getResultSet()."
      },
      "getResultSetConcurrency": {
        "!type": "fn() -> number",
        "!doc": "For documentation of this method, see java.sql.Statement#getResultSetConcurrency()."
      },
      "getResultSetHoldability": {
        "!type": "fn() -> number",
        "!doc": "For documentation of this method, see java.sql.Statement#getResultSetHoldability()."
      },
      "getResultSetType": {
        "!type": "fn() -> number",
        "!doc": "For documentation of this method, see java.sql.Statement#getResultSetType()."
      },
      "getUpdateCount": {
        "!type": "fn() -> number",
        "!doc": "For documentation of this method, see java.sql.Statement#getUpdateCount()."
      },
      "getWarnings": {
        "!type": "fn() -> [string]",
        "!doc": "Returns the current set of warnings reported by the driver. For documentation of this method,\n see java.sql.Statement#getWarnings()"
      },
      "isClosed": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see java.sql.Statement#isClosed()."
      },
      "isPoolable": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see java.sql.Statement#isPoolable()."
      },
      "setArray": {
        "!type": "fn(parameterIndex: number, x: Jdbc.JdbcArray)",
        "!doc": "For documentation of this method, see\n java.sql.PreparedStatement#setArray(int, java.sql.Array)."
      },
      "setBigDecimal": {
        "!type": "fn(parameterIndex: number, x: BigNumber)",
        "!doc": "For documentation of this method, see\n java.sql.PreparedStatement#setBigDecimal(int, java.math.BigDecimal)."
      },
      "setBlob": {
        "!type": "fn(parameterIndex: number, x: Jdbc.JdbcBlob)",
        "!doc": "For documentation of this method, see\n java.sql.PreparedStatement#setBlob(int, java.sql.Blob)."
      },
      "setBoolean": {
        "!type": "fn(parameterIndex: number, x: bool)",
        "!doc": "For documentation of this method, see\n java.sql.PreparedStatement#setBoolean(int, boolean)."
      },
      "setByte": {
        "!type": "fn(parameterIndex: number, x: number)",
        "!doc": "For documentation of this method, see java.sql.PreparedStatement#setByte(int, byte)."
      },
      "setBytes": {
        "!type": "fn(parameterIndex: number, x: [number])",
        "!doc": "For documentation of this method, see\n java.sql.PreparedStatement#setBytes(int, byte[])."
      },
      "setClob": {
        "!type": "fn(parameterIndex: number, x: Jdbc.JdbcClob)",
        "!doc": "For documentation of this method, see\n java.sql.PreparedStatement#setClob(int, java.sql.Clob)."
      },
      "setCursorName": {
        "!type": "fn(name: string)",
        "!doc": "For documentation of this method, see java.sql.Statement#setCursorName(String)."
      },
      "setDate": {
        "!type": "fn(parameterIndex: number, x: Jdbc.JdbcDate)",
        "!doc": "For documentation of this method, see\n java.sql.PreparedStatement#setDate(int, java.sql.Date)."
      },
      "setDate ": {
        "!type": "fn(parameterIndex: number, x: Jdbc.JdbcDate, timeZone: string)",
        "!doc": "For documentation of this method, see\n java.sql.PreparedStatement#setDate(int, java.sql.Date, java.util.Calendar)."
      },
      "setDouble": {
        "!type": "fn(parameterIndex: number, x: number)",
        "!doc": "For documentation of this method, see\n java.sql.PreparedStatement#setDouble(int, double)."
      },
      "setEscapeProcessing": {
        "!type": "fn(enable: bool)",
        "!doc": "For documentation of this method, see java.sql.Statement#setEscapeProcessing(boolean)."
      },
      "setFetchDirection": {
        "!type": "fn(direction: number)",
        "!doc": "For documentation of this method, see java.sql.Statement#setFetchDirection(int)."
      },
      "setFetchSize": {
        "!type": "fn(rows: number)",
        "!doc": "For documentation of this method, see java.sql.Statement#setFetchSize(int)."
      },
      "setFloat": {
        "!type": "fn(parameterIndex: number, x: number)",
        "!doc": "For documentation of this method, see java.sql.PreparedStatement#setFloat(int, float)."
      },
      "setInt": {
        "!type": "fn(parameterIndex: number, x: number)",
        "!doc": "For documentation of this method, see java.sql.PreparedStatement#setInt(int, int)."
      },
      "setLong": {
        "!type": "fn(parameterIndex: number, x: number)",
        "!doc": "For documentation of this method, see java.sql.PreparedStatement#setLong(int, long)."
      },
      "setMaxFieldSize": {
        "!type": "fn(max: number)",
        "!doc": "For documentation of this method, see java.sql.Statement#setMaxFieldSize(int)."
      },
      "setMaxRows": {
        "!type": "fn(max: number)",
        "!doc": "For documentation of this method, see java.sql.Statement#setMaxRows(int)."
      },
      "setNClob": {
        "!type": "fn(parameterIndex: number, x: Jdbc.JdbcClob)",
        "!doc": "For documentation of this method, see\n java.sql.PreparedStatement#setNClob(int, java.sql.NClob)."
      },
      "setNString": {
        "!type": "fn(parameterIndex: number, x: string)",
        "!doc": "For documentation of this method, see\n java.sql.PreparedStatement#setNString(int, String)."
      },
      "setNull": {
        "!type": "fn(parameterIndex: number, sqlType: number)",
        "!doc": "For documentation of this method, see java.sql.PreparedStatement#setNull(int, int)."
      },
      "setNull ": {
        "!type": "fn(parameterIndex: number, sqlType: number, typeName: string)",
        "!doc": "For documentation of this method, see\n java.sql.PreparedStatement#setNull(int, int, String)."
      },
      "setObject": {
        "!type": "fn(index: number, x: object)",
        "!doc": "For documentation of this method, see\n java.sql.PreparedStatement#setObject(int, Object)."
      },
      "setObject ": {
        "!type": "fn(parameterIndex: number, x: object, targetSqlType: number)",
        "!doc": "For documentation of this method, see\n java.sql.PreparedStatement#setObject(int, Object, int)."
      },
      "setObject  ": {
        "!type": "fn(parameterIndex: number, x: object, targetSqlType: number, scaleOrLength: number)",
        "!doc": "For documentation of this method, see\n java.sql.PreparedStatement#setObject(int, Object, int, int)."
      },
      "setPoolable": {
        "!type": "fn(poolable: bool)",
        "!doc": "For documentation of this method, see java.sql.Statement#setPoolable(boolean)."
      },
      "setQueryTimeout": {
        "!type": "fn(seconds: number)",
        "!doc": "For documentation of this method, see java.sql.Statement#setQueryTimeout(int)."
      },
      "setRef": {
        "!type": "fn(parameterIndex: number, x: Jdbc.JdbcRef)",
        "!doc": "For documentation of this method, see\n java.sql.PreparedStatement#setRef(int, java.sql.Ref)."
      },
      "setRowId": {
        "!type": "fn(parameterIndex: number, x: Jdbc.JdbcRowId)",
        "!doc": "For documentation of this method, see\n java.sql.PreparedStatement#setRowId(int, java.sql.RowId)."
      },
      "setSQLXML": {
        "!type": "fn(parameterIndex: number, x: Jdbc.JdbcSQLXML)",
        "!doc": "For documentation of this method, see\n java.sql.PreparedStatement#setSQLXML(int, java.sql.SQLXML)."
      },
      "setShort": {
        "!type": "fn(parameterIndex: number, x: number)",
        "!doc": "For documentation of this method, see java.sql.PreparedStatement#setShort(int, short)."
      },
      "setString": {
        "!type": "fn(parameterIndex: number, x: string)",
        "!doc": "For documentation of this method, see\n java.sql.PreparedStatement#setString(int, String)."
      },
      "setTime": {
        "!type": "fn(parameterIndex: number, x: Jdbc.JdbcTime)",
        "!doc": "For documentation of this method, see\n java.sql.PreparedStatement#setTime(int, java.sql.Time)."
      },
      "setTime ": {
        "!type": "fn(parameterIndex: number, x: Jdbc.JdbcTime, timeZone: string)",
        "!doc": "For documentation of this method, see\n java.sql.PreparedStatement#setTime(int, java.sql.Time, java.util.Calendar)."
      },
      "setTimestamp": {
        "!type": "fn(parameterIndex: number, x: Jdbc.JdbcTimestamp)",
        "!doc": "For documentation of this method, see\n java.sql.PreparedStatement#setTimestamp(int, java.sql.Timestamp)."
      },
      "setTimestamp ": {
        "!type": "fn(parameterIndex: number, x: Jdbc.JdbcTimestamp, timeZone: string)",
        "!doc": "For documentation of this method, see\n java.sql.PreparedStatement#setTimestamp(int, java.sql.Timestamp, java.util.Calendar)."
      },
      "setURL": {
        "!type": "fn(parameterIndex: number, x: string)",
        "!doc": "For documentation of this method, see\n java.sql.PreparedStatement#setURL(int, java.net.URL)."
      }
    },
    "Jdbc.JdbcRef": {
      "getBaseTypeName": {
        "!type": "fn() -> string",
        "!doc": "For documentation of this method, see java.sql.Ref#getBaseTypeName()."
      },
      "getObject": {
        "!type": "fn() -> object",
        "!doc": "For documentation of this method, see java.sql.Ref#getObject()."
      },
      "setObject": {
        "!type": "fn(object: object)",
        "!doc": "For documentation of this method, see java.sql.Ref#setObject(Object)."
      }
    },
    "Jdbc.JdbcResultSet": {
      "CLOSE_CURSORS_AT_COMMIT": {
        "!type": "number"
      },
      "CONCUR_READ_ONLY": {
        "!type": "number"
      },
      "CONCUR_UPDATABLE": {
        "!type": "number"
      },
      "FETCH_FORWARD": {
        "!type": "number"
      },
      "FETCH_REVERSE": {
        "!type": "number"
      },
      "FETCH_UNKNOWN": {
        "!type": "number"
      },
      "HOLD_CURSORS_OVER_COMMIT": {
        "!type": "number"
      },
      "TYPE_FORWARD_ONLY": {
        "!type": "number"
      },
      "TYPE_SCROLL_INSENSITIVE": {
        "!type": "number"
      },
      "TYPE_SCROLL_SENSITIVE": {
        "!type": "number"
      },
      "absolute": {
        "!type": "fn(row: number) -> bool",
        "!doc": "For documentation of this method, see java.sql.ResultSet#absolute(int)."
      },
      "afterLast": {
        "!type": "fn()",
        "!doc": "For documentation of this method, see java.sql.ResultSet#afterLast()."
      },
      "beforeFirst": {
        "!type": "fn()",
        "!doc": "For documentation of this method, see java.sql.ResultSet#beforeFirst()."
      },
      "cancelRowUpdates": {
        "!type": "fn()",
        "!doc": "For documentation of this method, see java.sql.ResultSet#cancelRowUpdates()."
      },
      "clearWarnings": {
        "!type": "fn()",
        "!doc": "For documentation of this method, see java.sql.ResultSet#clearWarnings()."
      },
      "close": {
        "!type": "fn()",
        "!doc": "For documentation of this method, see java.sql.ResultSet#close()."
      },
      "deleteRow": {
        "!type": "fn()",
        "!doc": "For documentation of this method, see java.sql.ResultSet#deleteRow()."
      },
      "findColumn": {
        "!type": "fn(columnLabel: string) -> number",
        "!doc": "For documentation of this method, see java.sql.ResultSet#findColumn(String)."
      },
      "first": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see java.sql.ResultSet#first()."
      },
      "getArray": {
        "!type": "fn(columnIndex: number) -> Jdbc.JdbcArray",
        "!doc": "For documentation of this method, see java.sql.ResultSet#getArray(int)."
      },
      "getArray ": {
        "!type": "fn(columnLabel: string) -> Jdbc.JdbcArray",
        "!doc": "For documentation of this method, see java.sql.ResultSet#getArray(String)."
      },
      "getBigDecimal": {
        "!type": "fn(columnIndex: number) -> BigNumber",
        "!doc": "For documentation of this method, see java.sql.ResultSet#getBigDecimal(int)."
      },
      "getBigDecimal ": {
        "!type": "fn(columnLabel: string) -> BigNumber",
        "!doc": "For documentation of this method, see java.sql.ResultSet#getBigDecimal(String)."
      },
      "getBlob": {
        "!type": "fn(columnIndex: number) -> Jdbc.JdbcBlob",
        "!doc": "For documentation of this method, see java.sql.ResultSet#getBlob(int)."
      },
      "getBlob ": {
        "!type": "fn(columnLabel: string) -> Jdbc.JdbcBlob",
        "!doc": "For documentation of this method, see java.sql.ResultSet#getBlob(String)."
      },
      "getBoolean": {
        "!type": "fn(columnIndex: number) -> bool",
        "!doc": "For documentation of this method, see java.sql.ResultSet#getBoolean(int)."
      },
      "getBoolean ": {
        "!type": "fn(columnLabel: string) -> bool",
        "!doc": "For documentation of this method, see java.sql.ResultSet#getBoolean(String)."
      },
      "getByte": {
        "!type": "fn(columnIndex: number) -> number",
        "!doc": "For documentation of this method, see java.sql.ResultSet#getByte(int)."
      },
      "getByte ": {
        "!type": "fn(columnLabel: string) -> number",
        "!doc": "For documentation of this method, see java.sql.ResultSet#getByte(String)."
      },
      "getBytes": {
        "!type": "fn(columnIndex: number) -> [number]",
        "!doc": "For documentation of this method, see java.sql.ResultSet#getBytes(int)."
      },
      "getBytes ": {
        "!type": "fn(columnLabel: string) -> [number]",
        "!doc": "For documentation of this method, see java.sql.ResultSet#getBytes(String)."
      },
      "getClob": {
        "!type": "fn(columnIndex: number) -> Jdbc.JdbcClob",
        "!doc": "For documentation of this method, see java.sql.ResultSet#getClob(int)."
      },
      "getClob ": {
        "!type": "fn(columnLabel: string) -> Jdbc.JdbcClob",
        "!doc": "For documentation of this method, see java.sql.ResultSet#getClob(String)."
      },
      "getConcurrency": {
        "!type": "fn() -> number",
        "!doc": "For documentation of this method, see java.sql.ResultSet#getConcurrency()."
      },
      "getCursorName": {
        "!type": "fn() -> string",
        "!doc": "For documentation of this method, see java.sql.ResultSet#getCursorName()."
      },
      "getDate": {
        "!type": "fn(columnIndex: number) -> Jdbc.JdbcDate",
        "!doc": "For documentation of this method, see java.sql.ResultSet#getDate(int)."
      },
      "getDate ": {
        "!type": "fn(columnIndex: number, timeZone: string) -> Jdbc.JdbcDate",
        "!doc": "For documentation of this method, see\n java.sql.ResultSet#getDate(int, java.util.Calendar)."
      },
      "getDate  ": {
        "!type": "fn(columnLabel: string) -> Jdbc.JdbcDate",
        "!doc": "For documentation of this method, see java.sql.ResultSet#getDate(String)."
      },
      "getDate   ": {
        "!type": "fn(columnLabel: string, timeZone: string) -> Jdbc.JdbcDate",
        "!doc": "For documentation of this method, see\n java.sql.ResultSet#getDate(String, java.util.Calendar)."
      },
      "getDouble": {
        "!type": "fn(columnIndex: number) -> number",
        "!doc": "For documentation of this method, see java.sql.ResultSet#getDouble(int)."
      },
      "getDouble ": {
        "!type": "fn(columnLabel: string) -> number",
        "!doc": "For documentation of this method, see java.sql.ResultSet#getDouble(String)."
      },
      "getFetchDirection": {
        "!type": "fn() -> number",
        "!doc": "For documentation of this method, see java.sql.ResultSet#getFetchDirection()."
      },
      "getFetchSize": {
        "!type": "fn() -> number",
        "!doc": "For documentation of this method, see java.sql.ResultSet#getFetchSize()."
      },
      "getFloat": {
        "!type": "fn(columnIndex: number) -> number",
        "!doc": "For documentation of this method, see java.sql.ResultSet#getFloat(int)."
      },
      "getFloat ": {
        "!type": "fn(columnLabel: string) -> number",
        "!doc": "For documentation of this method, see java.sql.ResultSet#getFloat(String)."
      },
      "getHoldability": {
        "!type": "fn() -> number",
        "!doc": "For documentation of this method, see java.sql.ResultSet#getHoldability()."
      },
      "getInt": {
        "!type": "fn(columnIndex: number) -> number",
        "!doc": "For documentation of this method, see java.sql.ResultSet#getInt(int)."
      },
      "getInt ": {
        "!type": "fn(columnLabel: string) -> number",
        "!doc": "For documentation of this method, see java.sql.ResultSet#getInt(String)."
      },
      "getLong": {
        "!type": "fn(columnIndex: number) -> number",
        "!doc": "For documentation of this method, see java.sql.ResultSet#getLong(int)."
      },
      "getLong ": {
        "!type": "fn(columnLabel: string) -> number",
        "!doc": "For documentation of this method, see java.sql.ResultSet#getLong(String)."
      },
      "getMetaData": {
        "!type": "fn() -> Jdbc.JdbcResultSetMetaData",
        "!doc": "For documentation of this method, see java.sql.ResultSet#getMetaData()."
      },
      "getNClob": {
        "!type": "fn(columnIndex: number) -> Jdbc.JdbcClob",
        "!doc": "For documentation of this method, see java.sql.ResultSet#getNClob(int)."
      },
      "getNClob ": {
        "!type": "fn(columnLabel: string) -> Jdbc.JdbcClob",
        "!doc": "For documentation of this method, see java.sql.ResultSet#getNClob(String)."
      },
      "getNString": {
        "!type": "fn(columnIndex: number) -> string",
        "!doc": "For documentation of this method, see java.sql.ResultSet#getNString(int)."
      },
      "getNString ": {
        "!type": "fn(columnLabel: string) -> string",
        "!doc": "For documentation of this method, see java.sql.ResultSet#getNString(String)."
      },
      "getObject": {
        "!type": "fn(columnIndex: number) -> object",
        "!doc": "For documentation of this method, see java.sql.ResultSet#getObject(int)."
      },
      "getObject ": {
        "!type": "fn(columnLabel: string) -> object",
        "!doc": "For documentation of this method, see java.sql.ResultSet#getObject(String)."
      },
      "getRef": {
        "!type": "fn(columnIndex: number) -> Jdbc.JdbcRef",
        "!doc": "For documentation of this method, see java.sql.ResultSet#getRef(int)."
      },
      "getRef ": {
        "!type": "fn(columnLabel: string) -> Jdbc.JdbcRef",
        "!doc": "For documentation of this method, see java.sql.ResultSet#getRef(String)."
      },
      "getRow": {
        "!type": "fn() -> number",
        "!doc": "For documentation of this method, see java.sql.ResultSet#getRow()."
      },
      "getRowId": {
        "!type": "fn(columnIndex: number) -> Jdbc.JdbcRowId",
        "!doc": "For documentation of this method, see java.sql.ResultSet#getRowId(int)."
      },
      "getRowId ": {
        "!type": "fn(columnLabel: string) -> Jdbc.JdbcRowId",
        "!doc": "For documentation of this method, see java.sql.ResultSet#getRowId(String)."
      },
      "getSQLXML": {
        "!type": "fn(columnIndex: number) -> Jdbc.JdbcSQLXML",
        "!doc": "For documentation of this method, see java.sql.ResultSet#getSQLXML(int)."
      },
      "getSQLXML ": {
        "!type": "fn(columnLabel: string) -> Jdbc.JdbcSQLXML",
        "!doc": "For documentation of this method, see java.sql.ResultSet#getSQLXML(String)."
      },
      "getShort": {
        "!type": "fn(columnIndex: number) -> number",
        "!doc": "For documentation of this method, see java.sql.ResultSet#getShort(int)."
      },
      "getShort ": {
        "!type": "fn(columnLabel: string) -> number",
        "!doc": "For documentation of this method, see java.sql.ResultSet#getShort(String)."
      },
      "getStatement": {
        "!type": "fn() -> Jdbc.JdbcStatement",
        "!doc": "For documentation of this method, see java.sql.ResultSet#getStatement()."
      },
      "getString": {
        "!type": "fn(columnIndex: number) -> string",
        "!doc": "For documentation of this method, see java.sql.ResultSet#getString(int)."
      },
      "getString ": {
        "!type": "fn(columnLabel: string) -> string",
        "!doc": "For documentation of this method, see java.sql.ResultSet#getString(String)."
      },
      "getTime": {
        "!type": "fn(columnIndex: number) -> Jdbc.JdbcTime",
        "!doc": "For documentation of this method, see java.sql.ResultSet#getTime(int)."
      },
      "getTime ": {
        "!type": "fn(columnIndex: number, timeZone: string) -> Jdbc.JdbcTime",
        "!doc": "For documentation of this method, see\n java.sql.ResultSet#getTime(int, java.util.Calendar)."
      },
      "getTime  ": {
        "!type": "fn(columnLabel: string) -> Jdbc.JdbcTime",
        "!doc": "For documentation of this method, see java.sql.ResultSet#getTime(String)."
      },
      "getTime   ": {
        "!type": "fn(columnLabel: string, timeZone: string) -> Jdbc.JdbcTime",
        "!doc": "For documentation of this method, see\n java.sql.ResultSet#getTime(String, java.util.Calendar)."
      },
      "getTimestamp": {
        "!type": "fn(columnIndex: number) -> Jdbc.JdbcTimestamp",
        "!doc": "For documentation of this method, see java.sql.ResultSet#getTimestamp(int)."
      },
      "getTimestamp ": {
        "!type": "fn(columnIndex: number, timeZone: string) -> Jdbc.JdbcTimestamp",
        "!doc": "For documentation of this method, see\n java.sql.ResultSet#getTimestamp(int, java.util.Calendar)."
      },
      "getTimestamp  ": {
        "!type": "fn(columnLabel: string) -> Jdbc.JdbcTimestamp",
        "!doc": "For documentation of this method, see java.sql.ResultSet#getTimestamp(String)."
      },
      "getTimestamp   ": {
        "!type": "fn(columnLabel: string, timeZone: string) -> Jdbc.JdbcTimestamp",
        "!doc": "For documentation of this method, see\n java.sql.ResultSet#getTimestamp(String, java.util.Calendar)."
      },
      "getType": {
        "!type": "fn() -> number",
        "!doc": "For documentation of this method, see java.sql.ResultSet#getType()."
      },
      "getURL": {
        "!type": "fn(columnIndex: number) -> string",
        "!doc": "For documentation of this method, see java.sql.ResultSet#getURL(int)."
      },
      "getURL ": {
        "!type": "fn(columnLabel: string) -> string",
        "!doc": "For documentation of this method, see java.sql.ResultSet#getURL(String)."
      },
      "getWarnings": {
        "!type": "fn() -> [string]",
        "!doc": "Returns the current set of warnings reported by the driver."
      },
      "insertRow": {
        "!type": "fn()",
        "!doc": "For documentation of this method, see java.sql.ResultSet#insertRow()."
      },
      "isAfterLast": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see java.sql.ResultSet#isAfterLast()."
      },
      "isBeforeFirst": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see java.sql.ResultSet#isBeforeFirst()."
      },
      "isClosed": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see java.sql.ResultSet#isClosed()."
      },
      "isFirst": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see java.sql.ResultSet#isFirst()."
      },
      "isLast": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see java.sql.ResultSet#isLast()."
      },
      "last": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see java.sql.ResultSet#last()."
      },
      "moveToCurrentRow": {
        "!type": "fn()",
        "!doc": "For documentation of this method, see java.sql.ResultSet#moveToCurrentRow()."
      },
      "moveToInsertRow": {
        "!type": "fn()",
        "!doc": "For documentation of this method, see java.sql.ResultSet#moveToInsertRow()."
      },
      "next": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see java.sql.ResultSet#next()."
      },
      "previous": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see java.sql.ResultSet#previous()."
      },
      "refreshRow": {
        "!type": "fn()",
        "!doc": "For documentation of this method, see java.sql.ResultSet#refreshRow()."
      },
      "relative": {
        "!type": "fn(rows: number) -> bool",
        "!doc": "For documentation of this method, see java.sql.ResultSet#relative(int)."
      },
      "rowDeleted": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see java.sql.ResultSet#rowDeleted()."
      },
      "rowInserted": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see java.sql.ResultSet#rowInserted()."
      },
      "rowUpdated": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see java.sql.ResultSet#rowUpdated()."
      },
      "setFetchDirection": {
        "!type": "fn(direction: number)",
        "!doc": "For documentation of this method, see java.sql.ResultSet#setFetchDirection(int)."
      },
      "setFetchSize": {
        "!type": "fn(rows: number)",
        "!doc": "For documentation of this method, see java.sql.ResultSet#setFetchSize(int)."
      },
      "updateArray": {
        "!type": "fn(columnIndex: number, x: Jdbc.JdbcArray)",
        "!doc": "For documentation of this method, see\n java.sql.ResultSet#updateArray(int, java.sql.Array)."
      },
      "updateArray ": {
        "!type": "fn(columnLabel: string, x: Jdbc.JdbcArray)",
        "!doc": "For documentation of this method, see\n java.sql.ResultSet#updateArray(String, java.sql.Array)."
      },
      "updateBigDecimal": {
        "!type": "fn(columnIndex: number, x: BigNumber)",
        "!doc": "For documentation of this method, see\n java.sql.ResultSet#updateBigDecimal(int, java.math.BigDecimal)."
      },
      "updateBigDecimal ": {
        "!type": "fn(columnLabel: string, x: BigNumber)",
        "!doc": "For documentation of this method, see\n java.sql.ResultSet#updateBigDecimal(String, java.math.BigDecimal)."
      },
      "updateBlob": {
        "!type": "fn(columnIndex: number, x: Jdbc.JdbcBlob)",
        "!doc": "For documentation of this method, see\n java.sql.ResultSet#updateBlob(int, java.sql.Blob)."
      },
      "updateBlob ": {
        "!type": "fn(columnLabel: string, x: Jdbc.JdbcBlob)",
        "!doc": "For documentation of this method, see\n java.sql.ResultSet#updateBlob(String, java.sql.Blob)."
      },
      "updateBoolean": {
        "!type": "fn(columnIndex: number, x: bool)",
        "!doc": "For documentation of this method, see java.sql.ResultSet#updateBoolean(int, boolean)."
      },
      "updateBoolean ": {
        "!type": "fn(columnLabel: string, x: bool)",
        "!doc": "For documentation of this method, see\n java.sql.ResultSet#updateBoolean(String, boolean)."
      },
      "updateByte": {
        "!type": "fn(columnIndex: number, x: number)",
        "!doc": "For documentation of this method, see java.sql.ResultSet#updateByte(int, byte)."
      },
      "updateByte ": {
        "!type": "fn(columnLabel: string, x: number)",
        "!doc": "For documentation of this method, see java.sql.ResultSet#updateByte(String, byte)."
      },
      "updateBytes": {
        "!type": "fn(columnIndex: number, x: [number])",
        "!doc": "For documentation of this method, see java.sql.ResultSet#updateBytes(int, byte[])."
      },
      "updateBytes ": {
        "!type": "fn(columnLabel: string, x: [number])",
        "!doc": "For documentation of this method, see java.sql.ResultSet#updateBytes(String, byte[])."
      },
      "updateClob": {
        "!type": "fn(columnIndex: number, x: Jdbc.JdbcClob)",
        "!doc": "For documentation of this method, see\n java.sql.ResultSet#updateClob(int, java.sql.Clob)."
      },
      "updateClob ": {
        "!type": "fn(columnLabel: string, x: Jdbc.JdbcClob)",
        "!doc": "For documentation of this method, see\n java.sql.ResultSet#updateClob(String, java.sql.Clob)."
      },
      "updateDate": {
        "!type": "fn(columnIndex: number, x: Jdbc.JdbcDate)",
        "!doc": "For documentation of this method, see\n java.sql.ResultSet#updateDate(int, java.sql.Date)."
      },
      "updateDate ": {
        "!type": "fn(columnLabel: string, x: Jdbc.JdbcDate)",
        "!doc": "For documentation of this method, see\n java.sql.ResultSet#updateDate(String, java.sql.Date)."
      },
      "updateDouble": {
        "!type": "fn(columnIndex: number, x: number)",
        "!doc": "For documentation of this method, see java.sql.ResultSet#updateDouble(int, double)."
      },
      "updateDouble ": {
        "!type": "fn(columnLabel: string, x: number)",
        "!doc": "For documentation of this method, see java.sql.ResultSet#updateDouble(String, double)."
      },
      "updateFloat": {
        "!type": "fn(columnIndex: number, x: number)",
        "!doc": "For documentation of this method, see java.sql.ResultSet#updateFloat(int, float)."
      },
      "updateFloat ": {
        "!type": "fn(columnLabel: string, x: number)",
        "!doc": "For documentation of this method, see java.sql.ResultSet#updateFloat(String, float)."
      },
      "updateInt": {
        "!type": "fn(columnIndex: number, x: number)",
        "!doc": "For documentation of this method, see java.sql.ResultSet#updateInt(int, int)."
      },
      "updateInt ": {
        "!type": "fn(columnLabel: string, x: number)",
        "!doc": "For documentation of this method, see java.sql.ResultSet#updateInt(String, int)."
      },
      "updateLong": {
        "!type": "fn(columnIndex: number, x: number)",
        "!doc": "For documentation of this method, see java.sql.ResultSet#updateLong(int, long)."
      },
      "updateLong ": {
        "!type": "fn(columnLabel: string, x: number)",
        "!doc": "For documentation of this method, see java.sql.ResultSet#updateLong(String, long)."
      },
      "updateNClob": {
        "!type": "fn(columnIndex: number, x: Jdbc.JdbcClob)",
        "!doc": "For documentation of this method, see\n java.sql.ResultSet#updateNClob(int, java.sql.NClob)."
      },
      "updateNClob ": {
        "!type": "fn(columnLabel: string, x: Jdbc.JdbcClob)",
        "!doc": "For documentation of this method, see\n java.sql.ResultSet#updateNClob(String, java.sql.NClob)."
      },
      "updateNString": {
        "!type": "fn(columnIndex: number, x: string)",
        "!doc": "For documentation of this method, see java.sql.ResultSet#updateNString(int, String)."
      },
      "updateNString ": {
        "!type": "fn(columnLabel: string, x: string)",
        "!doc": "For documentation of this method, see\n java.sql.ResultSet#updateNString(String, String)."
      },
      "updateNull": {
        "!type": "fn(columnIndex: number)",
        "!doc": "For documentation of this method, see java.sql.ResultSet#updateNull(int)."
      },
      "updateNull ": {
        "!type": "fn(columnLabel: string)",
        "!doc": "For documentation of this method, see java.sql.ResultSet#updateNull(String)."
      },
      "updateObject": {
        "!type": "fn(columnIndex: number, x: object)",
        "!doc": "For documentation of this method, see java.sql.ResultSet#updateObject(int, Object)."
      },
      "updateObject ": {
        "!type": "fn(columnIndex: number, x: object, scaleOrLength: number)",
        "!doc": "For documentation of this method, see\n java.sql.ResultSet#updateObject(int, Object, int)."
      },
      "updateObject  ": {
        "!type": "fn(columnLabel: string, x: object)",
        "!doc": "For documentation of this method, see\n java.sql.ResultSet#updateObject(String, Object)."
      },
      "updateObject   ": {
        "!type": "fn(columnLabel: string, x: object, scaleOrLength: number)",
        "!doc": "For documentation of this method, see\n java.sql.ResultSet#updateObject(String, Object, int)."
      },
      "updateRef": {
        "!type": "fn(columnIndex: number, x: Jdbc.JdbcRef)",
        "!doc": "For documentation of this method, see java.sql.ResultSet#updateRef(int, java.sql.Ref)."
      },
      "updateRef ": {
        "!type": "fn(columnLabel: string, x: Jdbc.JdbcRef)",
        "!doc": "For documentation of this method, see\n java.sql.ResultSet#updateRef(String, java.sql.Ref)."
      },
      "updateRow": {
        "!type": "fn()",
        "!doc": "For documentation of this method, see java.sql.ResultSet#updateRow()."
      },
      "updateRowId": {
        "!type": "fn(columnIndex: number, x: Jdbc.JdbcRowId)",
        "!doc": "For documentation of this method, see\n java.sql.ResultSet#updateRowId(int, java.sql.RowId)."
      },
      "updateRowId ": {
        "!type": "fn(columnLabel: string, x: Jdbc.JdbcRowId)",
        "!doc": "For documentation of this method, see\n java.sql.ResultSet#updateRowId(String, java.sql.RowId)."
      },
      "updateSQLXML": {
        "!type": "fn(columnIndex: number, x: Jdbc.JdbcSQLXML)",
        "!doc": "For documentation of this method, see\n java.sql.ResultSet#updateSQLXML(int, java.sql.SQLXML)."
      },
      "updateSQLXML ": {
        "!type": "fn(columnLabel: string, x: Jdbc.JdbcSQLXML)",
        "!doc": "For documentation of this method, see\n java.sql.ResultSet#updateSQLXML(String, java.sql.SQLXML)."
      },
      "updateShort": {
        "!type": "fn(columnIndex: number, x: number)",
        "!doc": "For documentation of this method, see java.sql.ResultSet#updateShort(int, short)."
      },
      "updateShort ": {
        "!type": "fn(columnLabel: string, x: number)",
        "!doc": "For documentation of this method, see java.sql.ResultSet#updateShort(String, short)."
      },
      "updateString": {
        "!type": "fn(columnIndex: number, x: string)",
        "!doc": "For documentation of this method, see java.sql.ResultSet#updateString(int, String)."
      },
      "updateString ": {
        "!type": "fn(columnLabel: string, x: string)",
        "!doc": "For documentation of this method, see java.sql.ResultSet#updateString(String, String)."
      },
      "updateTime": {
        "!type": "fn(columnIndex: number, x: Jdbc.JdbcTime)",
        "!doc": "For documentation of this method, see\n java.sql.ResultSet#updateTime(int, java.sql.Time)."
      },
      "updateTime ": {
        "!type": "fn(columnLabel: string, x: Jdbc.JdbcTime)",
        "!doc": "For documentation of this method, see\n java.sql.ResultSet#updateTime(String, java.sql.Time)."
      },
      "updateTimestamp": {
        "!type": "fn(columnIndex: number, x: Jdbc.JdbcTimestamp)",
        "!doc": "For documentation of this method, see\n java.sql.ResultSet#updateTimestamp(int, java.sql.Timestamp)."
      },
      "updateTimestamp ": {
        "!type": "fn(columnLabel: string, x: Jdbc.JdbcTimestamp)",
        "!doc": "For documentation of this method, see\n java.sql.ResultSet#updateTimestamp(String, java.sql.Timestamp)."
      },
      "wasNull": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see java.sql.ResultSet#wasNull()."
      }
    },
    "Jdbc.JdbcResultSetMetaData": {
      "columnNoNulls": {
        "!type": "number"
      },
      "columnNullable": {
        "!type": "number"
      },
      "columnNullableUnknown": {
        "!type": "number"
      },
      "getCatalogName": {
        "!type": "fn(column: number) -> string",
        "!doc": "For documentation of this method, see java.sql.ResultSetMetaData#getCatalogName(int)."
      },
      "getColumnClassName": {
        "!type": "fn(column: number) -> string",
        "!doc": "For documentation of this method, see\n java.sql.ResultSetMetaData#getColumnClassName(int)."
      },
      "getColumnCount": {
        "!type": "fn() -> number",
        "!doc": "For documentation of this method, see java.sql.ResultSetMetaData#getColumnCount()."
      },
      "getColumnDisplaySize": {
        "!type": "fn(column: number) -> number",
        "!doc": "For documentation of this method, see\n java.sql.ResultSetMetaData#getColumnDisplaySize(int)."
      },
      "getColumnLabel": {
        "!type": "fn(column: number) -> string",
        "!doc": "For documentation of this method, see java.sql.ResultSetMetaData#getColumnLabel(int)."
      },
      "getColumnName": {
        "!type": "fn(column: number) -> string",
        "!doc": "For documentation of this method, see java.sql.ResultSetMetaData#getColumnName(int)."
      },
      "getColumnType": {
        "!type": "fn(column: number) -> number",
        "!doc": "For documentation of this method, see java.sql.ResultSetMetaData#getColumnType(int)."
      },
      "getColumnTypeName": {
        "!type": "fn(column: number) -> string",
        "!doc": "For documentation of this method, see\n java.sql.ResultSetMetaData#getColumnTypeName(int)."
      },
      "getPrecision": {
        "!type": "fn(column: number) -> number",
        "!doc": "For documentation of this method, see java.sql.ResultSetMetaData#getPrecision(int)."
      },
      "getScale": {
        "!type": "fn(column: number) -> number",
        "!doc": "For documentation of this method, see java.sql.ResultSetMetaData#getScale(int)."
      },
      "getSchemaName": {
        "!type": "fn(column: number) -> string",
        "!doc": "For documentation of this method, see java.sql.ResultSetMetaData#getSchemaName(int)."
      },
      "getTableName": {
        "!type": "fn(column: number) -> string",
        "!doc": "For documentation of this method, see java.sql.ResultSetMetaData#getTableName(int)."
      },
      "isAutoIncrement": {
        "!type": "fn(column: number) -> bool",
        "!doc": "For documentation of this method, see java.sql.ResultSetMetaData#isAutoIncrement(int)."
      },
      "isCaseSensitive": {
        "!type": "fn(column: number) -> bool",
        "!doc": "For documentation of this method, see java.sql.ResultSetMetaData#isCaseSensitive(int)."
      },
      "isCurrency": {
        "!type": "fn(column: number) -> bool",
        "!doc": "For documentation of this method, see java.sql.ResultSetMetaData#isCurrency(int)."
      },
      "isDefinitelyWritable": {
        "!type": "fn(column: number) -> bool",
        "!doc": "For documentation of this method, see\n java.sql.ResultSetMetaData#isDefinitelyWritable(int)."
      },
      "isNullable": {
        "!type": "fn(column: number) -> number",
        "!doc": "For documentation of this method, see java.sql.ResultSetMetaData#isNullable(int)."
      },
      "isReadOnly": {
        "!type": "fn(column: number) -> bool",
        "!doc": "For documentation of this method, see java.sql.ResultSetMetaData#isReadOnly(int)."
      },
      "isSearchable": {
        "!type": "fn(column: number) -> bool",
        "!doc": "For documentation of this method, see java.sql.ResultSetMetaData#isSearchable(int)."
      },
      "isSigned": {
        "!type": "fn(column: number) -> bool",
        "!doc": "For documentation of this method, see java.sql.ResultSetMetaData#isSigned(int)."
      },
      "isWritable": {
        "!type": "fn(column: number) -> bool",
        "!doc": "For documentation of this method, see java.sql.ResultSetMetaData#isWritable(int)."
      }
    },
    "Jdbc.JdbcRowId": {
      "getBytes": {
        "!type": "fn() -> [number]",
        "!doc": "For documentation of this method, see java.sql.RowId#getBytes()."
      }
    },
    "Jdbc.JdbcRowIdLifetime": {
      "ROWID_UNSUPPORTED": {
        "!type": "number"
      },
      "ROWID_VALID_FOREVER": {
        "!type": "number"
      },
      "ROWID_VALID_OTHER": {
        "!type": "number"
      },
      "ROWID_VALID_SESSION": {
        "!type": "number"
      },
      "ROWID_VALID_TRANSACTION": {
        "!type": "number"
      }
    },
    "Jdbc.JdbcSQLXML": {
      "free": {
        "!type": "fn()",
        "!doc": "For documentation of this method, see java.sql.SQLXML#free()."
      },
      "getString": {
        "!type": "fn() -> string",
        "!doc": "For documentation of this method, see java.sql.SQLXML#getString()."
      },
      "setString": {
        "!type": "fn(value: string)",
        "!doc": "For documentation of this method, see java.sql.SQLXML#setString(String)."
      }
    },
    "Jdbc.JdbcSavepoint": {
      "getSavepointId": {
        "!type": "fn() -> number",
        "!doc": "For documentation of this method, see java.sql.Savepoint#getSavepointId()."
      },
      "getSavepointName": {
        "!type": "fn() -> string",
        "!doc": "For documentation of this method, see java.sql.Savepoint#getSavepointName()."
      }
    },
    "Jdbc.JdbcStatement": {
      "addBatch": {
        "!type": "fn(sql: string)",
        "!doc": "For documentation of this method, see java.sql.Statement#addBatch(String)."
      },
      "cancel": {
        "!type": "fn()",
        "!doc": "For documentation of this method, see java.sql.Statement#cancel()."
      },
      "clearBatch": {
        "!type": "fn()",
        "!doc": "For documentation of this method, see java.sql.Statement#clearBatch()."
      },
      "clearWarnings": {
        "!type": "fn()",
        "!doc": "For documentation of this method, see java.sql.Statement#clearWarnings()."
      },
      "close": {
        "!type": "fn()",
        "!doc": "For documentation of this method, see java.sql.Statement#close()."
      },
      "execute": {
        "!type": "fn(sql: string) -> bool",
        "!doc": "For documentation of this method, see java.sql.Statement#execute(String)."
      },
      "execute ": {
        "!type": "fn(sql: string, autoGeneratedKeys: number) -> bool",
        "!doc": "For documentation of this method, see java.sql.Statement#execute(String, int)."
      },
      "execute  ": {
        "!type": "fn(sql: string, columnIndexes: [number]) -> bool",
        "!doc": "For documentation of this method, see java.sql.Statement#execute(String, int[])."
      },
      "execute   ": {
        "!type": "fn(sql: string, columnNames: [string]) -> bool",
        "!doc": "For documentation of this method, see java.sql.Statement#execute(String, String[])."
      },
      "executeBatch": {
        "!type": "fn() -> [number]",
        "!doc": "For documentation of this method, see java.sql.Statement#executeBatch()."
      },
      "executeQuery": {
        "!type": "fn(sql: string) -> Jdbc.JdbcResultSet",
        "!doc": "For documentation of this method, see java.sql.Statement#executeQuery(String)."
      },
      "executeUpdate": {
        "!type": "fn(sql: string) -> number",
        "!doc": "For documentation of this method, see java.sql.Statement#executeUpdate(String)."
      },
      "executeUpdate ": {
        "!type": "fn(sql: string, autoGeneratedKeys: number) -> number",
        "!doc": "For documentation of this method, see java.sql.Statement#executeUpdate(String, int)."
      },
      "executeUpdate  ": {
        "!type": "fn(sql: string, columnIndexes: [number]) -> number",
        "!doc": "For documentation of this method, see java.sql.Statement#executeUpdate(String, int)."
      },
      "executeUpdate   ": {
        "!type": "fn(sql: string, columnNames: [string]) -> number",
        "!doc": "For documentation of this method, see\n java.sql.Statement#executeUpdate(String, String[])."
      },
      "getConnection": {
        "!type": "fn() -> Jdbc.JdbcConnection",
        "!doc": "For documentation of this method, see java.sql.Statement#getConnection()."
      },
      "getFetchDirection": {
        "!type": "fn() -> number",
        "!doc": "For documentation of this method, see java.sql.Statement#getFetchDirection()."
      },
      "getFetchSize": {
        "!type": "fn() -> number",
        "!doc": "For documentation of this method, see java.sql.Statement#getFetchSize()."
      },
      "getGeneratedKeys": {
        "!type": "fn() -> Jdbc.JdbcResultSet",
        "!doc": "For documentation of this method, see java.sql.Statement#getGeneratedKeys()."
      },
      "getMaxFieldSize": {
        "!type": "fn() -> number",
        "!doc": "For documentation of this method, see java.sql.Statement#getMaxFieldSize()."
      },
      "getMaxRows": {
        "!type": "fn() -> number",
        "!doc": "For documentation of this method, see java.sql.Statement#getMaxRows()."
      },
      "getMoreResults": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see java.sql.Statement#getMoreResults()."
      },
      "getMoreResults ": {
        "!type": "fn(current: number) -> bool",
        "!doc": "For documentation of this method, see java.sql.Statement#getMoreResults(int)."
      },
      "getQueryTimeout": {
        "!type": "fn() -> number",
        "!doc": "For documentation of this method, see java.sql.Statement#getQueryTimeout()."
      },
      "getResultSet": {
        "!type": "fn() -> Jdbc.JdbcResultSet",
        "!doc": "For documentation of this method, see java.sql.Statement#getResultSet()."
      },
      "getResultSetConcurrency": {
        "!type": "fn() -> number",
        "!doc": "For documentation of this method, see java.sql.Statement#getResultSetConcurrency()."
      },
      "getResultSetHoldability": {
        "!type": "fn() -> number",
        "!doc": "For documentation of this method, see java.sql.Statement#getResultSetHoldability()."
      },
      "getResultSetType": {
        "!type": "fn() -> number",
        "!doc": "For documentation of this method, see java.sql.Statement#getResultSetType()."
      },
      "getUpdateCount": {
        "!type": "fn() -> number",
        "!doc": "For documentation of this method, see java.sql.Statement#getUpdateCount()."
      },
      "getWarnings": {
        "!type": "fn() -> [string]",
        "!doc": "Returns the current set of warnings reported by the driver. For documentation of this method,\n see java.sql.Statement#getWarnings()"
      },
      "isClosed": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see java.sql.Statement#isClosed()."
      },
      "isPoolable": {
        "!type": "fn() -> bool",
        "!doc": "For documentation of this method, see java.sql.Statement#isPoolable()."
      },
      "setCursorName": {
        "!type": "fn(name: string)",
        "!doc": "For documentation of this method, see java.sql.Statement#setCursorName(String)."
      },
      "setEscapeProcessing": {
        "!type": "fn(enable: bool)",
        "!doc": "For documentation of this method, see java.sql.Statement#setEscapeProcessing(boolean)."
      },
      "setFetchDirection": {
        "!type": "fn(direction: number)",
        "!doc": "For documentation of this method, see java.sql.Statement#setFetchDirection(int)."
      },
      "setFetchSize": {
        "!type": "fn(rows: number)",
        "!doc": "For documentation of this method, see java.sql.Statement#setFetchSize(int)."
      },
      "setMaxFieldSize": {
        "!type": "fn(max: number)",
        "!doc": "For documentation of this method, see java.sql.Statement#setMaxFieldSize(int)."
      },
      "setMaxRows": {
        "!type": "fn(max: number)",
        "!doc": "For documentation of this method, see java.sql.Statement#setMaxRows(int)."
      },
      "setPoolable": {
        "!type": "fn(poolable: bool)",
        "!doc": "For documentation of this method, see java.sql.Statement#setPoolable(boolean)."
      },
      "setQueryTimeout": {
        "!type": "fn(seconds: number)",
        "!doc": "For documentation of this method, see java.sql.Statement#setQueryTimeout(int)."
      }
    },
    "Jdbc.JdbcStatment": {
      "CLOSE_ALL_RESULTS": {
        "!type": "number"
      },
      "CLOSE_CURRENT_RESULT": {
        "!type": "number"
      },
      "EXECUTE_FAILED": {
        "!type": "number"
      },
      "KEEP_CURRENT_RESULT": {
        "!type": "number"
      },
      "NO_GENERATED_KEYS": {
        "!type": "number"
      },
      "RETURN_GENERATED_KEYS": {
        "!type": "number"
      },
      "SUCCESS_NO_INFO": {
        "!type": "number"
      }
    },
    "Jdbc.JdbcStruct": {
      "getAttributes": {
        "!type": "fn() -> [object]",
        "!doc": "For documentation of this method, see java.sql.Struct#getAttributes()."
      },
      "getSQLTypeName": {
        "!type": "fn() -> string",
        "!doc": "For documentation of this method, see java.sql.Struct#getSQLTypeName()."
      }
    },
    "Jdbc.JdbcTime": {
      "after": {
        "!type": "fn(when: Jdbc.JdbcTime) -> bool",
        "!doc": "For documentation of this method, see java.sql.Time#after(java.util.Date)."
      },
      "before": {
        "!type": "fn(when: Jdbc.JdbcTime) -> bool",
        "!doc": "For documentation of this method, see java.sql.Time#before(java.util.Date)."
      },
      "getHours": {
        "!type": "fn() -> number",
        "!doc": "For documentation of this method, see java.sql.Time#getHours()."
      },
      "getMinutes": {
        "!type": "fn() -> number",
        "!doc": "For documentation of this method, see java.sql.Time#getMinutes()."
      },
      "getSeconds": {
        "!type": "fn() -> number",
        "!doc": "For documentation of this method, see java.sql.Time#getSeconds()."
      },
      "getTime": {
        "!type": "fn() -> number",
        "!doc": "For documentation of this method, see java.sql.Time#getTime()."
      },
      "setHours": {
        "!type": "fn(hours: number)",
        "!doc": "For documentation of this method, see java.sql.Time#setHours(int)."
      },
      "setMinutes": {
        "!type": "fn(minutes: number)",
        "!doc": "For documentation of this method, see java.sql.Time#setMinutes(int)."
      },
      "setSeconds": {
        "!type": "fn(seconds: number)",
        "!doc": "For documentation of this method, see java.sql.Time#setSeconds(int)."
      },
      "setTime": {
        "!type": "fn(milliseconds: number)",
        "!doc": "For documentation of this method, see java.sql.Time#setTime(long)."
      }
    },
    "Jdbc.JdbcTimestamp": {
      "after": {
        "!type": "fn(when: Jdbc.JdbcTimestamp) -> bool",
        "!doc": "For documentation of this method, see java.sql.Timestamp#after(java.sql.Timestamp)."
      },
      "before": {
        "!type": "fn(when: Jdbc.JdbcTimestamp) -> bool",
        "!doc": "For documentation of this method, see java.sql.Timestamp#before(java.sql.Timestamp)."
      },
      "getDate": {
        "!type": "fn() -> number",
        "!doc": "For documentation of this method, see java.sql.Timestamp#getDate()."
      },
      "getHours": {
        "!type": "fn() -> number",
        "!doc": "For documentation of this method, see java.sql.Timestamp#getHours()."
      },
      "getMinutes": {
        "!type": "fn() -> number",
        "!doc": "For documentation of this method, see java.sql.Timestamp#getMinutes()."
      },
      "getMonth": {
        "!type": "fn() -> number",
        "!doc": "For documentation of this method, see java.sql.Timestamp#getMonth()."
      },
      "getNanos": {
        "!type": "fn() -> number",
        "!doc": "For documentation of this method, see java.sql.Timestamp#getNanos()."
      },
      "getSeconds": {
        "!type": "fn() -> number",
        "!doc": "For documentation of this method, see java.sql.Timestamp#getSeconds()."
      },
      "getTime": {
        "!type": "fn() -> number",
        "!doc": "For documentation of this method, see java.sql.Timestamp#getTime()."
      },
      "getYear": {
        "!type": "fn() -> number",
        "!doc": "For documentation of this method, see java.sql.Timestamp#getYear()."
      },
      "setDate": {
        "!type": "fn(date: number)",
        "!doc": "For documentation of this method, see java.sql.Timestamp#setDate(int)."
      },
      "setHours": {
        "!type": "fn(hours: number)",
        "!doc": "For documentation of this method, see java.sql.Timestamp#setHours(int)."
      },
      "setMinutes": {
        "!type": "fn(minutes: number)",
        "!doc": "For documentation of this method, see java.sql.Timestamp#setMinutes(int)."
      },
      "setMonth": {
        "!type": "fn(month: number)",
        "!doc": "For documentation of this method, see java.sql.Timestamp#setMonth(int)."
      },
      "setNanos": {
        "!type": "fn(nanoseconds: number)",
        "!doc": "For documentation of this method, see java.sql.Timestamp#setNanos(int)."
      },
      "setSeconds": {
        "!type": "fn(seconds: number)",
        "!doc": "For documentation of this method, see java.sql.Timestamp#setSeconds(int)."
      },
      "setTime": {
        "!type": "fn(milliseconds: number)",
        "!doc": "For documentation of this method, see java.sql.Timestamp#setTime(long)."
      },
      "setYear": {
        "!type": "fn(year: number)",
        "!doc": "For documentation of this method, see java.sql.Timestamp#setYear(int)."
      }
    },
    "Jdbc.JdbcTypes": {
      "ARRAY": {
        "!type": "number"
      },
      "BIGINT": {
        "!type": "number"
      },
      "BINARY": {
        "!type": "number"
      },
      "BIT": {
        "!type": "number"
      },
      "BLOB": {
        "!type": "number"
      },
      "BOOLEAN": {
        "!type": "number"
      },
      "CHAR": {
        "!type": "number"
      },
      "CLOB": {
        "!type": "number"
      },
      "DATALINK": {
        "!type": "number"
      },
      "DATE": {
        "!type": "number"
      },
      "DECIMAL": {
        "!type": "number"
      },
      "DISTINCT": {
        "!type": "number"
      },
      "DOUBLE": {
        "!type": "number"
      },
      "FLOAT": {
        "!type": "number"
      },
      "INTEGER": {
        "!type": "number"
      },
      "JAVA_OBJECT": {
        "!type": "number"
      },
      "LONGNVARCHAR": {
        "!type": "number"
      },
      "LONGVARBINARY": {
        "!type": "number"
      },
      "LONGVARCHAR": {
        "!type": "number"
      },
      "NCHAR": {
        "!type": "number"
      },
      "NCLOB": {
        "!type": "number"
      },
      "NULL": {
        "!type": "number"
      },
      "NUMERIC": {
        "!type": "number"
      },
      "NVARCHAR": {
        "!type": "number"
      },
      "OTHER": {
        "!type": "number"
      },
      "REAL": {
        "!type": "number"
      },
      "REF": {
        "!type": "number"
      },
      "ROWID": {
        "!type": "number"
      },
      "SMALLINT": {
        "!type": "number"
      },
      "SQLXML": {
        "!type": "number"
      },
      "STRUCT": {
        "!type": "number"
      },
      "TIME": {
        "!type": "number"
      },
      "TIMESTAMP": {
        "!type": "number"
      },
      "TINYINT": {
        "!type": "number"
      },
      "VARBINARY": {
        "!type": "number"
      },
      "VARCHAR": {
        "!type": "number"
      }
    },
    "SpreadsheetApp.ContainerInfo": {
      "getAnchorColumn": {
        "!type": "fn() -> number",
        "!doc": "The chart's left side will be anchored in this column."
      },
      "getAnchorRow": {
        "!type": "fn() -> number",
        "!doc": "The chart's top side will be anchored in this row."
      },
      "getOffsetX": {
        "!type": "fn() -> number",
        "!doc": "The chart's upper left hand corner will be offset from the anchor column by this many pixels."
      },
      "getOffsetY": {
        "!type": "fn() -> number",
        "!doc": "Chart's upper left hand corner will be offset from the anchor row by this many pixels."
      }
    },
    "SpreadsheetApp.DataValidation": {
      "copy": {
        "!type": "fn() -> SpreadsheetApp.DataValidationBuilder",
        "!doc": "Creates a builder for a data-validation rule based on this rule's settings. \n\n \n // Change existing data-validation rules that require a date in 2013 to require a date in 2014.\n var oldDates = [new Date(&#39;1/1/2013&#39;), new Date(&#39;12/31/2013&#39;)];\n var newDates = [new Date(&#39;1/1/2014&#39;), new Date(&#39;12/31/2014&#39;)];\n var sheet = SpreadsheetApp.getActiveSheet();\n var range = sheet.getRange(1, 1, sheet.getMaxRows(), sheet.getMaxColumns());\n var rules = range.getDataValidations();\n\n for (var i = 0; i &lt; rules.length; i++) {\n   for (var j = 0; j &lt; rules[i].length; j++) {\n     var rule = rules[i][j];\n\n     if (rule != null) {\n       var criteria = rule.getCriteriaType();\n       var args = rule.getCriteriaValues();\n \n       if (criteria == SpreadsheetApp.DataValidationCriteria.DATE_BETWEEN\n           &amp;&amp; args[0].getTime() == oldDates[0].getTime()\n           &amp;&amp; args[1].getTime() == oldDates[1].getTime()) {\n         // Create a builder from the existing rule, then change the dates.\n         rules[i][j] = rule.copy().withCriteria(criteria, newDates).build();\n       }\n     }\n   }\n }\n range.setDataValidations(rules);\n "
      },
      "getAllowInvalid": {
        "!type": "fn() -> bool",
        "!doc": "Returns true if the rule shows a warning when input fails data validation, or\n false if it rejects the input entirely. The default for new data-validation rules is\n true."
      },
      "getCriteriaType": {
        "!type": "fn() -> SpreadsheetApp.DataValidationCriteria",
        "!doc": "Gets the rule's criteria type as defined in the DataValidationCriteria enum. To get the\n arguments for the criteria, use getCriteriaValues(). To use these values to create or\n modify a data-validation rule, see\n DataValidationBuilder.withCriteria(criteria, args).\n\n \n // Log information about the data-validation rule for cell A1.\n var cell = SpreadsheetApp.getActive().getRange('A1');\n var rule = cell.getDataValidation();\n if (rule != null) {\n   var criteria = rule.getCriteriaType();\n   var args = rule.getCriteriaValues();\n   Logger.log('The data-validation rule is %s %s', criteria, args);\n } else {\n   Logger.log('The cell does not have a data-validation rule.')\n }\n "
      },
      "getCriteriaValues": {
        "!type": "fn() -> [object]",
        "!doc": "Gets an array of arguments for the rule's criteria. To get the criteria type, use\n getCriteriaType(). To use these values to create or modify a data-validation rule, see\n DataValidationBuilder.withCriteria(criteria, args).\n\n \n // Log information about the data-validation rule for cell A1.\n var cell = SpreadsheetApp.getActive().getRange('A1');\n var rule = cell.getDataValidation();\n if (rule != null) {\n   var criteria = rule.getCriteriaType();\n   var args = rule.getCriteriaValues();\n   Logger.log('The data-validation rule is %s %s', criteria, args);\n } else {\n   Logger.log('The cell does not have a data-validation rule.')\n }\n "
      },
      "getHelpText": {
        "!type": "fn() -> string",
        "!doc": "Gets the rule's help text, or null if no help text is set."
      }
    },
    "SpreadsheetApp.DataValidationBuilder": {
      "build": {
        "!type": "fn() -> SpreadsheetApp.DataValidation",
        "!doc": "Constructs a data-validation rule from the settings applied to the builder."
      },
      "copy": {
        "!type": "fn() -> SpreadsheetApp.DataValidationBuilder",
        "!doc": "Creates a builder for a data-validation rule based on this rule's settings. \n\n \n // Change existing data-validation rules that require a date in 2013 to require a date in 2014.\n var oldDates = [new Date(&#39;1/1/2013&#39;), new Date(&#39;12/31/2013&#39;)];\n var newDates = [new Date(&#39;1/1/2014&#39;), new Date(&#39;12/31/2014&#39;)];\n var sheet = SpreadsheetApp.getActiveSheet();\n var range = sheet.getRange(1, 1, sheet.getMaxRows(), sheet.getMaxColumns());\n var rules = range.getDataValidations();\n\n for (var i = 0; i &lt; rules.length; i++) {\n   for (var j = 0; j &lt; rules[i].length; j++) {\n     var rule = rules[i][j];\n\n     if (rule != null) {\n       var criteria = rule.getCriteriaType();\n       var args = rule.getCriteriaValues();\n \n       if (criteria == SpreadsheetApp.DataValidationCriteria.DATE_BETWEEN\n           &amp;&amp; args[0].getTime() == oldDates[0].getTime()\n           &amp;&amp; args[1].getTime() == oldDates[1].getTime()) {\n         // Create a builder from the existing rule, then change the dates.\n         rules[i][j] = rule.copy().withCriteria(criteria, newDates).build();\n       }\n     }\n   }\n }\n range.setDataValidations(rules);\n "
      },
      "getAllowInvalid": {
        "!type": "fn() -> bool",
        "!doc": "Returns true if the rule shows a warning when input fails data validation, or\n false if it rejects the input entirely. The default for new data-validation rules is\n true."
      },
      "getCriteriaType": {
        "!type": "fn() -> SpreadsheetApp.DataValidationCriteria",
        "!doc": "Gets the rule's criteria type as defined in the DataValidationCriteria enum. To get the\n arguments for the criteria, use getCriteriaValues(). To use these values to create or\n modify a data-validation rule, see\n withCriteria(criteria, args).\n\n \n // Log information about the data-validation rule for cell A1.\n var cell = SpreadsheetApp.getActive().getRange('A1');\n var rule = cell.getDataValidation();\n if (rule != null) {\n   var criteria = rule.getCriteriaType();\n   var args = rule.getCriteriaValues();\n   Logger.log('The data-validation rule is %s %s', criteria, args);\n } else {\n   Logger.log('The cell does not have a data-validation rule.')\n }\n "
      },
      "getCriteriaValues": {
        "!type": "fn() -> [object]",
        "!doc": "Gets an array of arguments for the rule's criteria. To get the criteria type, use\n getCriteriaType(). To use these values to create or modify a data-validation rule, see\n withCriteria(criteria, args).\n\n \n // Log information about the data-validation rule for cell A1.\n var cell = SpreadsheetApp.getActive().getRange('A1');\n var rule = cell.getDataValidation();\n if (rule != null) {\n   var criteria = rule.getCriteriaType();\n   var args = rule.getCriteriaValues();\n   Logger.log('The data-validation rule is %s %s', criteria, args);\n } else {\n   Logger.log('The cell does not have a data-validation rule.')\n }\n "
      },
      "getHelpText": {
        "!type": "fn() -> string",
        "!doc": "Gets the rule's help text, or null if no help text is set."
      },
      "requireDate": {
        "!type": "fn() -> SpreadsheetApp.DataValidationBuilder",
        "!doc": "Sets the data-validation rule to require a date.\n\n \n // Set the data validation for cell A1 to require a date.\n var cell = SpreadsheetApp.getActive().getRange('A1');\n var rule = SpreadsheetApp.newDataValidation().requireDate().build();\n cell.setDataValidation(rule);\n "
      },
      "requireDateAfter": {
        "!type": "fn(date: Date) -> SpreadsheetApp.DataValidationBuilder",
        "!doc": "Sets the data-validation rule to require a date after the given value. The time fields of the\n Date object are ignored; only the day, month, and year fields are used.\n\n \n // Set the data validation for cell A1 to require a date after January 1, 2013.\n var cell = SpreadsheetApp.getActive().getRange('A1');\n var rule = SpreadsheetApp.newDataValidation().requireDateAfter(new Date('1/1/2013')).build();\n cell.setDataValidation(rule);\n "
      },
      "requireDateBefore": {
        "!type": "fn(date: Date) -> SpreadsheetApp.DataValidationBuilder",
        "!doc": "Sets the data-validation rule to require a date before the given value. The time fields of the\n Date object are ignored; only the day, month, and year fields are used.\n\n \n // Set the data validation for cell A1 to require a date before January 1, 2013.\n var cell = SpreadsheetApp.getActive().getRange('A1');\n var rule = SpreadsheetApp.newDataValidation().requireDateBefore(new Date('1/1/2013')).build();\n cell.setDataValidation(rule);\n "
      },
      "requireDateBetween": {
        "!type": "fn(start: Date, end: Date) -> SpreadsheetApp.DataValidationBuilder",
        "!doc": "Sets the data-validation rule to require a date between the given values, inclusive of the\n values themselves. The time fields of the Date objects are ignored; only the day,\n month, and year fields are used.\n\n \n // Set the data validation for cell A1 to require a date in 2013.\n var cell = SpreadsheetApp.getActive().getRange('A1');\n var rule = SpreadsheetApp.newDataValidation()\n     .requireDateBetween(new Date('1/1/2013'), new Date('12/31/2013')).build();\n cell.setDataValidation(rule);\n "
      },
      "requireDateEqualTo": {
        "!type": "fn(date: Date) -> SpreadsheetApp.DataValidationBuilder",
        "!doc": "Sets the data-validation rule to require a date equal to the given value. The time fields of\n the Date object are ignored; only the day, month, and year fields are used.\n\n \n // Set the data validation for cell A1 to require a date equal to January 1, 2013.\n var cell = SpreadsheetApp.getActive().getRange('A1');\n var rule = SpreadsheetApp.newDataValidation().requireDateEqualTo(new Date('1/1/2013'))\n     .build();\n cell.setDataValidation(rule);\n "
      },
      "requireDateNotBetween": {
        "!type": "fn(start: Date, end: Date) -> SpreadsheetApp.DataValidationBuilder",
        "!doc": "Sets the data-validation rule to require a date not between the given values, inclusive of the\n values themselves. The time fields of the Date objects are ignored; only the day,\n month, and year fields are used.\n\n \n // Set the data validation for cell A1 to require a date not in 2013.\n var cell = SpreadsheetApp.getActive().getRange('A1');\n var rule = SpreadsheetApp.newDataValidation()\n     .requireDateNotBetween(new Date('1/1/2013'), new Date('12/31/2013')).build();\n cell.setDataValidation(rule);\n "
      },
      "requireDateOnOrAfter": {
        "!type": "fn(date: Date) -> SpreadsheetApp.DataValidationBuilder",
        "!doc": "Sets the data-validation rule to require a date on or after the given value. The time fields of\n the Date object are ignored; only the day, month, and year fields are used.\n\n \n // Set the data validation for cell A1 to require a date on or after January 1, 2013.\n var cell = SpreadsheetApp.getActive().getRange('A1');\n var rule = SpreadsheetApp.newDataValidation()\n     .requireDateOnOrAfter(new Date('1/1/2013')).build();\n cell.setDataValidation(rule);\n "
      },
      "requireDateOnOrBefore": {
        "!type": "fn(date: Date) -> SpreadsheetApp.DataValidationBuilder",
        "!doc": "Sets the data-validation rule to require a date on or before the given value. The time fields\n of the Date object are ignored; only the day, month, and year fields are used.\n\n \n // Set the data validation for cell A1 to require a date on or before January 1, 2013.\n var cell = SpreadsheetApp.getActive().getRange('A1');\n var rule = SpreadsheetApp.newDataValidation()\n     .requireDateOnOrBefore(new Date('1/1/2013')).build();\n cell.setDataValidation(rule);\n "
      },
      "requireFormulaSatisfied": {
        "!type": "fn(formula: string) -> SpreadsheetApp.DataValidationBuilder",
        "!doc": "Sets the data-validation rule to require that the given formula evaluates to true. This\n method is only available in the\n new version of Google Sheets.\n\n \n // Set the data validation for cell A1 to equal B1 with a custom formula.\n var cell = SpreadsheetApp.getActive().getRange('A1');\n var rule = SpreadsheetApp.newDataValidation().requireFormulaSatisfied('=EQ(A1,B1)').build();\n cell.setDataValidation(rule);\n "
      },
      "requireNumberBetween": {
        "!type": "fn(start: number, end: number) -> SpreadsheetApp.DataValidationBuilder",
        "!doc": "Sets the data-validation rule to require a number between the given values, inclusive of the\n values themselves.\n\n \n // Set the data validation for cell A1 to require a number between 1 and 10.\n var cell = SpreadsheetApp.getActive().getRange('A1');\n var rule = SpreadsheetApp.newDataValidation().requireNumberBetween(1, 10).build();\n cell.setDataValidation(rule);\n "
      },
      "requireNumberEqualTo": {
        "!type": "fn(number: number) -> SpreadsheetApp.DataValidationBuilder",
        "!doc": "Sets the data-validation rule to require a number equal to the given value.\n\n \n // Set the data validation for cell A1 to require a number equal to 3.1415926536.\n var cell = SpreadsheetApp.getActive().getRange('A1');\n var rule = SpreadsheetApp.newDataValidation().requireNumberEqualTo(3.1415926536).build();\n cell.setDataValidation(rule);\n "
      },
      "requireNumberGreaterThan": {
        "!type": "fn(number: number) -> SpreadsheetApp.DataValidationBuilder",
        "!doc": "Sets the data-validation rule to require a number greater than the given value.\n\n \n // Set the data validation for cell A1 to require a number greater than 0.\n var cell = SpreadsheetApp.getActive().getRange('A1');\n var rule = SpreadsheetApp.newDataValidation().requireNumberGreaterThan(0).build();\n cell.setDataValidation(rule);\n "
      },
      "requireNumberGreaterThanOrEqualTo": {
        "!type": "fn(number: number) -> SpreadsheetApp.DataValidationBuilder",
        "!doc": "Sets the data-validation rule to require a number greater than or equal to the given value.\n\n \n // Set the data validation for cell A1 to require a number greater than or equal to 0.\n var cell = SpreadsheetApp.getActive().getRange('A1');\n var rule = SpreadsheetApp.newDataValidation().requireNumberGreaterThanOrEqualTo(0).build();\n cell.setDataValidation(rule);\n "
      },
      "requireNumberLessThan": {
        "!type": "fn(number: number) -> SpreadsheetApp.DataValidationBuilder",
        "!doc": "Sets the data-validation rule to require a number less than the given value.\n\n \n // Set the data validation for cell A1 to require a number less than 0.\n var cell = SpreadsheetApp.getActive().getRange('A1');\n var rule = SpreadsheetApp.newDataValidation().requireNumberLessThan(0).build();\n cell.setDataValidation(rule);\n "
      },
      "requireNumberLessThanOrEqualTo": {
        "!type": "fn(number: number) -> SpreadsheetApp.DataValidationBuilder",
        "!doc": "Sets the data-validation rule to require a number less than or equal to the given value.\n\n \n // Set the data validation for cell A1 to require a number less than or equal to 0.\n var cell = SpreadsheetApp.getActive().getRange('A1');\n var rule = SpreadsheetApp.newDataValidation().requireNumberLessThanOrEqualTo(0).build();\n cell.setDataValidation(rule);\n "
      },
      "requireNumberNotBetween": {
        "!type": "fn(start: number, end: number) -> SpreadsheetApp.DataValidationBuilder",
        "!doc": "Sets the data-validation rule to require a number not between the given values, inclusive of\n the values themselves.\n\n \n // Set the data validation for cell A1 to require a number not between 1 and 10.\n var cell = SpreadsheetApp.getActive().getRange('A1');\n var rule = SpreadsheetApp.newDataValidation().requireNumberNotBetween(1, 10).build();\n cell.setDataValidation(rule);\n "
      },
      "requireNumberNotEqualTo": {
        "!type": "fn(number: number) -> SpreadsheetApp.DataValidationBuilder",
        "!doc": "Sets the data-validation rule to require a number not equal to the given value.\n\n \n // Set the data validation for cell A1 to require a number not equal to 0.\n var cell = SpreadsheetApp.getActive().getRange('A1');\n var rule = SpreadsheetApp.newDataValidation().requireNumberNotEqualTo(0).build();\n cell.setDataValidation(rule);\n "
      },
      "requireTextContains": {
        "!type": "fn(text: string) -> SpreadsheetApp.DataValidationBuilder",
        "!doc": "Sets the data-validation rule to require that the input contains the given value.\n\n \n // Set the data validation for cell A1 to require any value that includes \"Google\".\n var cell = SpreadsheetApp.getActive().getRange('A1');\n var rule = SpreadsheetApp.newDataValidation().requireTextContains('Google').build();\n cell.setDataValidation(rule);\n "
      },
      "requireTextDoesNotContain": {
        "!type": "fn(text: string) -> SpreadsheetApp.DataValidationBuilder",
        "!doc": "Sets the data-validation rule to require that the input does not contain the given value.\n\n \n // Set the data validation for cell A1 to require any value that does not include \"@\".\n var cell = SpreadsheetApp.getActive().getRange('A1');\n var rule = SpreadsheetApp.newDataValidation().requireTextDoesNotContain('@').build();\n cell.setDataValidation(rule);\n "
      },
      "requireTextEqualTo": {
        "!type": "fn(text: string) -> SpreadsheetApp.DataValidationBuilder",
        "!doc": "Sets the data-validation rule to require that the input is equal to the given value.\n\n \n // Set the data validation for cell A1 to require \"Yes\".\n var cell = SpreadsheetApp.getActive().getRange('A1');\n var rule = SpreadsheetApp.newDataValidation().requireTextEqualTo('Yes').build();\n cell.setDataValidation(rule);\n "
      },
      "requireTextIsEmail": {
        "!type": "fn() -> SpreadsheetApp.DataValidationBuilder",
        "!doc": "Sets the data-validation rule to require that the input is in the form of an email address.\n\n \n // Set the data validation for cell A1 to require text in the form of an email address.\n var cell = SpreadsheetApp.getActive().getRange('A1');\n var rule = SpreadsheetApp.newDataValidation().requireTextIsEmail().build();\n cell.setDataValidation(rule);\n "
      },
      "requireTextIsUrl": {
        "!type": "fn() -> SpreadsheetApp.DataValidationBuilder",
        "!doc": "Sets the data-validation rule to require that the input is in the form of a URL.\n\n \n // Set the data validation for cell A1 to require text in the form of a URL.\n var cell = SpreadsheetApp.getActive().getRange('A1');\n var rule = SpreadsheetApp.newDataValidation().requireTextIsUrl().build();\n cell.setDataValidation(rule);\n "
      },
      "requireValueInList": {
        "!type": "fn(values: [string]) -> SpreadsheetApp.DataValidationBuilder",
        "!doc": "Sets the data-validation rule to require that the input is equal to one of the given values.\n\n \n // Set the data validation for cell A1 to require \"Yes\" or \"No\", with a dropdown menu.\n var cell = SpreadsheetApp.getActive().getRange('A1');\n var rule = SpreadsheetApp.newDataValidation().requireValueInList(['Yes', 'No']).build();\n cell.setDataValidation(rule);\n "
      },
      "requireValueInList ": {
        "!type": "fn(values: [string], showDropdown: bool) -> SpreadsheetApp.DataValidationBuilder",
        "!doc": "Sets the data-validation rule to require that the input is equal to one of the given values,\n with an option to hide the dropdown menu.\n\n \n // Set the data validation for cell A1 to require \"Yes\" or \"No\", with no dropdown menu.\n var cell = SpreadsheetApp.getActive().getRange('A1');\n var rule = SpreadsheetApp.newDataValidation().requireValueInList(['Yes', 'No'], false).build();\n cell.setDataValidation(rule);\n "
      },
      "requireValueInRange": {
        "!type": "fn(range: SpreadsheetApp.Range) -> SpreadsheetApp.DataValidationBuilder",
        "!doc": "Sets the data-validation rule to require that the input is equal to a value in the given range.\n\n \n // Set the data validation for cell A1 to require a value from B1:B10, with a dropdown menu.\n var cell = SpreadsheetApp.getActive().getRange('A1');\n var range = SpreadsheetApp.getActive().getRange('B1:B10');\n var rule = SpreadsheetApp.newDataValidation().requireValueInRange(range).build();\n cell.setDataValidation(rule);\n "
      },
      "requireValueInRange ": {
        "!type": "fn(range: SpreadsheetApp.Range, showDropdown: bool) -> SpreadsheetApp.DataValidationBuilder",
        "!doc": "Sets the data-validation rule to require that the input is equal to a value in the given range,\n with an option to hide the dropdown menu.\n\n \n // Set the data validation for cell A1 to require value from B1:B10, with no dropdown menu.\n var cell = SpreadsheetApp.getActive().getRange('A1');\n var range = SpreadsheetApp.getActive().getRange('B1:B10');\n var rule = SpreadsheetApp.newDataValidation().requireValueInRange(range, false).build();\n cell.setDataValidation(rule);\n "
      },
      "setAllowInvalid": {
        "!type": "fn(allowInvalidData: bool) -> SpreadsheetApp.DataValidationBuilder",
        "!doc": "Sets whether to show a warning when input fails data validation or whether to reject the input\n entirely. The default for new data-validation rules is true."
      },
      "setHelpText": {
        "!type": "fn(helpText: string) -> SpreadsheetApp.DataValidationBuilder",
        "!doc": "Sets the help text shown when the user hovers over the cell on which data-validation is set."
      },
      "withCriteria": {
        "!type": "fn(criteria: SpreadsheetApp.DataValidationCriteria, args: [object]) -> SpreadsheetApp.DataValidationBuilder",
        "!doc": "Sets the data-validation rule to require criteria defined in the DataValidationCriteria\n enum. This is an advanced method used primarily to create a new data-validation rule based on\n the criteria and\n arguments of an existing rule; in most other\n cases, the require...() methods are easier to use.\n\n \n // Change existing data-validation rules that require a date in 2013 to require a date in 2014.\n var oldDates = [new Date(&#39;1/1/2013&#39;), new Date(&#39;12/31/2013&#39;)];\n var newDates = [new Date(&#39;1/1/2014&#39;), new Date(&#39;12/31/2014&#39;)];\n var sheet = SpreadsheetApp.getActiveSheet();\n var range = sheet.getRange(1, 1, sheet.getMaxRows(), sheet.getMaxColumns());\n var rules = range.getDataValidations();\n\n for (var i = 0; i &lt; rules.length; i++) {\n   for (var j = 0; j &lt; rules[i].length; j++) {\n     var rule = rules[i][j];\n\n     if (rule != null) {\n       var criteria = rule.getCriteriaType();\n       var args = rule.getCriteriaValues();\n \n       if (criteria == SpreadsheetApp.DataValidationCriteria.DATE_BETWEEN\n           &amp;&amp; args[0].getTime() == oldDates[0].getTime()\n           &amp;&amp; args[1].getTime() == oldDates[1].getTime()) {\n         // Create a builder from the existing rule, then change the dates.\n         rules[i][j] = rule.copy().withCriteria(criteria, newDates).build();\n       }\n     }\n   }\n }\n range.setDataValidations(rules);\n "
      }
    },
    "SpreadsheetApp.DataValidationCriteria": {
      "CUSTOM_FORMULA": {
        "!type": "SpreadsheetApp.DataValidationCriteria",
        "!doc": "Requires that the input makes the given formula evaluate to true."
      },
      "DATE_AFTER": {
        "!type": "SpreadsheetApp.DataValidationCriteria",
        "!doc": "Requires a date that is after the given value."
      },
      "DATE_BEFORE": {
        "!type": "SpreadsheetApp.DataValidationCriteria",
        "!doc": "Requires a date that is before the given value."
      },
      "DATE_BETWEEN": {
        "!type": "SpreadsheetApp.DataValidationCriteria",
        "!doc": "Requires a date that is between the given values."
      },
      "DATE_EQUAL_TO": {
        "!type": "SpreadsheetApp.DataValidationCriteria",
        "!doc": "Requires a date that is equal to the given value."
      },
      "DATE_IS_VALID_DATE": {
        "!type": "SpreadsheetApp.DataValidationCriteria",
        "!doc": "Requires a date."
      },
      "DATE_NOT_BETWEEN": {
        "!type": "SpreadsheetApp.DataValidationCriteria",
        "!doc": "Requires a date that is not between the given values."
      },
      "DATE_ON_OR_AFTER": {
        "!type": "SpreadsheetApp.DataValidationCriteria",
        "!doc": "Require a date that is on or after the given value."
      },
      "DATE_ON_OR_BEFORE": {
        "!type": "SpreadsheetApp.DataValidationCriteria",
        "!doc": "Requires a date that is on or before the given value."
      },
      "NUMBER_BETWEEN": {
        "!type": "SpreadsheetApp.DataValidationCriteria",
        "!doc": "Requires a number that is between the given values."
      },
      "NUMBER_EQUAL_TO": {
        "!type": "SpreadsheetApp.DataValidationCriteria",
        "!doc": "Requires a number that is equal to the given value."
      },
      "NUMBER_GREATER_THAN": {
        "!type": "SpreadsheetApp.DataValidationCriteria",
        "!doc": "Require a number that is greater than the given value."
      },
      "NUMBER_GREATER_THAN_OR_EQUAL_TO": {
        "!type": "SpreadsheetApp.DataValidationCriteria",
        "!doc": "Requires a number that is greater than or equal to the given value."
      },
      "NUMBER_LESS_THAN": {
        "!type": "SpreadsheetApp.DataValidationCriteria",
        "!doc": "Requires a number that is less than the given value."
      },
      "NUMBER_LESS_THAN_OR_EQUAL_TO": {
        "!type": "SpreadsheetApp.DataValidationCriteria",
        "!doc": "Requires a number that is less than or equal to the given value."
      },
      "NUMBER_NOT_BETWEEN": {
        "!type": "SpreadsheetApp.DataValidationCriteria",
        "!doc": "Requires a number that is not between the given values."
      },
      "NUMBER_NOT_EQUAL_TO": {
        "!type": "SpreadsheetApp.DataValidationCriteria",
        "!doc": "Requires a number that is not equal to the given value."
      },
      "TEXT_CONTAINS": {
        "!type": "SpreadsheetApp.DataValidationCriteria",
        "!doc": "Requires that the input contains the given value."
      },
      "TEXT_DOES_NOT_CONTAIN": {
        "!type": "SpreadsheetApp.DataValidationCriteria",
        "!doc": "Requires that the input does not contain the given value."
      },
      "TEXT_EQUAL_TO": {
        "!type": "SpreadsheetApp.DataValidationCriteria",
        "!doc": "Requires that the input is equal to the given value."
      },
      "TEXT_IS_VALID_EMAIL": {
        "!type": "SpreadsheetApp.DataValidationCriteria",
        "!doc": "Requires that the input is in the form of an email address."
      },
      "TEXT_IS_VALID_URL": {
        "!type": "SpreadsheetApp.DataValidationCriteria",
        "!doc": "Requires that the input is in the form of a URL."
      },
      "VALUE_IN_LIST": {
        "!type": "SpreadsheetApp.DataValidationCriteria",
        "!doc": "Requires that the input is equal to one of the given values."
      },
      "VALUE_IN_RANGE": {
        "!type": "SpreadsheetApp.DataValidationCriteria",
        "!doc": "Requires that the input is equal to a value in the given range."
      }
    },
    "SpreadsheetApp.EmbeddedAreaChartBuilder": {
      "addRange": {
        "!type": "fn(range: SpreadsheetApp.Range) -> SpreadsheetApp.EmbeddedChartBuilder",
        "!doc": "Adds a Range to the chart represented by this builder. Will not add the Range\n if it has already been added to the chart.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var chart = sheet.newChart()\n     .setChartType(Charts.ChartType.BAR)\n     .addRange(sheet.getRange(&quot;A1:B8&quot;))\n     .setPosition(5, 5, 0, 0)\n     .build();\n\n sheet.insertChart(chart);\n "
      },
      "asAreaChart": {
        "!type": "fn() -> SpreadsheetApp.EmbeddedAreaChartBuilder",
        "!doc": "Sets the chart type to AreaChart and returns an EmbeddedAreaChartBuilder."
      },
      "asBarChart": {
        "!type": "fn() -> SpreadsheetApp.EmbeddedBarChartBuilder",
        "!doc": "Sets the chart type to BarChart and returns an EmbeddedBarChartBuilder."
      },
      "asColumnChart": {
        "!type": "fn() -> SpreadsheetApp.EmbeddedColumnChartBuilder",
        "!doc": "Sets the chart type to ColumnChart and returns an EmbeddedColumnChartBuilder."
      },
      "asLineChart": {
        "!type": "fn() -> SpreadsheetApp.EmbeddedLineChartBuilder",
        "!doc": "Sets the chart type to LineChart and returns an EmbeddedLineChartBuilder."
      },
      "asPieChart": {
        "!type": "fn() -> SpreadsheetApp.EmbeddedPieChartBuilder",
        "!doc": "Sets the chart type to PieChart and returns an EmbeddedPieChartBuilder."
      },
      "asScatterChart": {
        "!type": "fn() -> SpreadsheetApp.EmbeddedScatterChartBuilder",
        "!doc": "Sets the chart type to ScatterChart and returns an EmbeddedScatterChartBuilder."
      },
      "asTableChart": {
        "!type": "fn() -> SpreadsheetApp.EmbeddedTableChartBuilder",
        "!doc": "Sets the chart type to TableChart and returns an EmbeddedTableChartBuilder."
      },
      "build": {
        "!type": "fn() -> SpreadsheetApp.EmbeddedChart",
        "!doc": "Builds the chart to reflect all changes made to it.\n\n This method will not automatically draw the chart on top of the spreadsheet. A new chart\n must be inserted via sheet.insertChart(chart), and an existing chart should be updated via\n sheet.update(chart);\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var range = sheet.getRange(&quot;A1:B5&quot;);\n var chart = sheet.newChart()\n     .setChartType(Charts.ChartType.BAR)\n     .addRange(range)\n     .setPosition(5, 5, 0, 0)\n     .build()\n\n sheet.insertChart(chart);\n "
      },
      "getChartType": {
        "!type": "fn() -> Charts.ChartType",
        "!doc": "Returns the current chart type."
      },
      "getContainer": {
        "!type": "fn() -> SpreadsheetApp.ContainerInfo",
        "!doc": "Return the ContainerInfo, which encapsulates where the chart appears on the sheet.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var chartBuilder = sheet.newChart()\n     .setChartType(Charts.ChartType.BAR)\n     .addRange(sheet.getRange(&quot;A1:B8&quot;))\n     .setPosition(5, 5, 0, 0);\n\n // This method returns the exact same data as Chart#getContainerInfo()\n var containerInfo = chartBuilder.getContainer();\n\n // Logs the values we used in setPosition()\n Logger.log(&quot;Anchor Column: %s\\r\\nAnchor Row %s\\r\\nOffset X %s\\r\\nOffset Y %s&quot;,\n           containerInfo.getAnchorColumn(),\n           containerInfo.getAnchorRow(),\n           containerInfo.getOffsetX(),\n           containerInfo.getOffsetY());\n "
      },
      "getRanges": {
        "!type": "fn() -> [SpreadsheetApp.Range]",
        "!doc": "Returns a copy of the list of ranges currently providing data for this chart. Use addRange and\n removeRange to modify this list.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var chartBuilder = sheet.newChart()\n     .setChartType(Charts.ChartType.BAR)\n     .addRange(sheet.getRange(&quot;A1:B8&quot;))\n     .setPosition(5, 5, 0, 0)\n\n var ranges = chartBuilder.getRanges();\n\n // There&#39;s only one range as a data source for this chart,\n // so this logs &quot;A1:B8&quot;\n for (var i in ranges) {\n   var range = ranges[i];\n   Logger.log(range.getA1Notation());\n }\n "
      },
      "removeRange": {
        "!type": "fn(range: SpreadsheetApp.Range) -> SpreadsheetApp.EmbeddedChartBuilder",
        "!doc": "Removes the specified Range from the chart represented by this builder. Will not throw an error\n if the Range is not in this chart.\n\n The range removed must match up with a range added via addRange(range), or it will\n not be removed, and it will not throw an exception. This method cannot be used to partially\n remove values from a range.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var firstRange = sheet.getRange(&quot;A1:B5&quot;);\n var secondRange = sheet.getRange(&quot;A6:B8&quot;);\n\n var chartBuilder = sheet.newChart()\n     .setChartType(Charts.ChartType.BAR)\n     .addRange(firstRange)\n     // This range will render in a different color\n     .addRange(secondRange)\n     .setPosition(5, 5, 0, 0);\n\n // Note that you can use either of these two formats, but the range\n // MUST match up with a range that was added via addRange(), or it\n // will not be removed, and will not throw an exception\n chartBuilder.removeRange(firstRange);\n chartBuilder.removeRange(sheet.getRange(&quot;A6:B8&quot;));\n\n var chart = chartBuilder.build();\n\n sheet.insertChart(chart);\n  "
      },
      "reverseCategories": {
        "!type": "fn() -> SpreadsheetApp.EmbeddedAreaChartBuilder",
        "!doc": "Reverses the drawing of series in the domain axis.  For vertical-range charts (such as line,\n area or column charts), this means the horizontal axis is drawn from right to left.  For\n horizontal-range charts (such as bar charts), this means the vertical axis is drawn from top\n to bottom.  For pie charts, this means the slices are drawn counterclockwise.\n\n \n \n // Creates a pie chart builder and sets drawing of the slices in a counter-clockwise manner.\n var builder = Charts.newPieChart();\n builder.reverseCategories();\n "
      },
      "setBackgroundColor": {
        "!type": "fn(cssValue: string) -> SpreadsheetApp.EmbeddedAreaChartBuilder",
        "!doc": "Sets the background color for the chart.\n\n \n \n // Creates a line chart builder and sets the background color to gray\n var builder = Charts.newLineChart();\n builder.setBackgroundColor(&quot;gray&quot;);\n "
      },
      "setChartType": {
        "!type": "fn(type: Charts.ChartType) -> SpreadsheetApp.EmbeddedChartBuilder",
        "!doc": "Changes the type of chart. Not all embedded chart types are currently supported. See\n ChartType.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var range = sheet.getRange(&quot;A1:B5&quot;);\n var chart = sheet.newChart()\n     .setChartType(Charts.ChartType.BAR)\n     .addRange(range)\n     .setPosition(5, 5, 0, 0)\n     .build()\n\n sheet.insertChart(chart);\n "
      },
      "setColors": {
        "!type": "fn(cssValues: [string]) -> SpreadsheetApp.EmbeddedAreaChartBuilder",
        "!doc": "Sets the colors for the lines in the chart.\n\n \n \n // Creates a line chart builder and sets the first two lines to be drawn in green and red,\n // respectively.\n var builder = Charts.newLineChart();\n builder.setColors([&quot;green&quot;, &quot;red&quot;]);\n "
      },
      "setLegendPosition": {
        "!type": "fn(position: Charts.Position) -> SpreadsheetApp.EmbeddedAreaChartBuilder",
        "!doc": "Sets the position of the legend with respect to the chart.  By default, there will be no\n legend.\n\n \n \n // Creates a line chart builder and sets the legend position to right.\n var builder = Charts.newLineChart();\n builder.setLegendPosition(Charts.Position.RIGHT);\n "
      },
      "setLegendTextStyle": {
        "!type": "fn(textStyle: Charts.TextStyle) -> SpreadsheetApp.EmbeddedAreaChartBuilder",
        "!doc": "Sets the text style of the chart legend.\n\n \n \n // Creates a line chart builder and sets it up for a  blue, 26-point legend.\n var textStyleBuilder = Charts.newTextStyle().setColor(&#39;#0000FF&#39;).setFontSize(26);\n var style = textStyleBuilder.build();\n var builder = Charts.newLineChart();\n builder.setLegendTextStyle(style);\n "
      },
      "setOption": {
        "!type": "fn(option: string, value: object) -> SpreadsheetApp.EmbeddedChartBuilder",
        "!doc": "Sets advanced options for this chart. See\n \n https://developers.google.com/chart/interactive/docs/reference for what\n options are available.\n\n This method will NOT validate the option you specify is valid for this\n chart type nor if the value is of the correct format/structure.\n\n This example shows how to change the animation duration to 1 second and\n set a legend.\n\n \n \n builder.setOption(&#39;title&#39;, &#39;Earnings projections&#39;);\n builder.setOption(&#39;animation.duration&#39;, 1000);\n builder.setOption(&#39;legend&#39;, {position: &#39;top&#39;, textStyle: {color: &#39;blue&#39;, fontSize: 16}});\n "
      },
      "setPointStyle": {
        "!type": "fn(style: Charts.PointStyle) -> SpreadsheetApp.EmbeddedAreaChartBuilder",
        "!doc": "Sets the style for points in the line.  By default, points will have no particular styles,\n and only the line will be visible.\n\n \n \n // Creates a line chart builder and sets large point style.\n var builder = Charts.newLineChart();\n builder.setPointStyle(Charts.PointStyle.LARGE);\n "
      },
      "setPosition": {
        "!type": "fn(anchorRowPos: number, anchorColPos: number, offsetX: number, offsetY: number) -> SpreadsheetApp.EmbeddedChartBuilder",
        "!doc": "Sets the position, changing where the chart appears on the sheet. AnchorRowPos and AnchorColPos\n are 1-indexed.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var range = sheet.getRange(&quot;A1:B5&quot;);\n var chart = sheet.newChart()\n     .setChartType(Charts.ChartType.BAR)\n     .addRange(range)\n     .setPosition(5, 5, 0, 0)\n     .build()\n\n sheet.insertChart(chart);\n "
      },
      "setRange": {
        "!type": "fn(start: number, end: number) -> SpreadsheetApp.EmbeddedAreaChartBuilder",
        "!doc": "Sets the range for the chart.\n \n If any data points fall outside the range, the range will be expanded to include those data\n points."
      },
      "setStacked": {
        "!type": "fn() -> SpreadsheetApp.EmbeddedAreaChartBuilder",
        "!doc": "Uses stacked lines, meaning that line and bar values are stacked (accumulated).  By default,\n there is no stacking."
      },
      "setTitle": {
        "!type": "fn(chartTitle: string) -> SpreadsheetApp.EmbeddedAreaChartBuilder",
        "!doc": "Sets the title of the chart.  The title will be displayed centered above the chart.\n\n \n \n // Creates a line chart builder and title to &#39;My Line Chart&#39;.\n var builder = Charts.newLineChart();\n builder.setTitle(&#39;My Line Chart&#39;)\n "
      },
      "setTitleTextStyle": {
        "!type": "fn(textStyle: Charts.TextStyle) -> SpreadsheetApp.EmbeddedAreaChartBuilder",
        "!doc": "Sets the text style of the chart title.\n\n \n \n // Creates a line chart builder and sets it up for a  blue, 26-point title.\n var textStyleBuilder = Charts.newTextStyle().setColor(&#39;#0000FF&#39;).setFontSize(26);\n var style = textStyleBuilder.build();\n var builder = Charts.newLineChart();\n builder.setTitleTextStyle(style);\n "
      },
      "setXAxisTextStyle": {
        "!type": "fn(textStyle: Charts.TextStyle) -> SpreadsheetApp.EmbeddedAreaChartBuilder",
        "!doc": "Sets the horizontal axis text style.\n\n \n \n // Creates a line chart builder and sets the X-axis text style to blue, 18-point font.\n var textStyle = Charts.newTextStyle().setColor(&#39;blue&#39;).setFontSize(18).build();\n var builder = Charts.newLineChart();\n builder.setXAxisTextStyle(textStyle);\n "
      },
      "setXAxisTitle": {
        "!type": "fn(title: string) -> SpreadsheetApp.EmbeddedAreaChartBuilder",
        "!doc": "Adds a title to the horizontal axis.  The title will be centered and will appear below\n the axis value labels.\n\n \n \n // Creates a line chart builder and sets the X-axis title.\n var builder = Charts.newLineChart();\n builder.setTitle(&#39;X-axis Title&#39;)\n "
      },
      "setXAxisTitleTextStyle": {
        "!type": "fn(textStyle: Charts.TextStyle) -> SpreadsheetApp.EmbeddedAreaChartBuilder",
        "!doc": "Sets the horizontal axis title text style.\n\n \n \n // Creates a line chart builder and sets the X-axis title text style to blue, 18-point font.\n var textStyle = Charts.newTextStyle().setColor(&#39;blue&#39;).setFontSize(18).build();\n var builder = Charts.newLineChart();\n builder.setXAxisTitleTextStyle(textStyle);\n "
      },
      "setYAxisTextStyle": {
        "!type": "fn(textStyle: Charts.TextStyle) -> SpreadsheetApp.EmbeddedAreaChartBuilder",
        "!doc": "Sets the vertical axis text style.\n\n \n \n // Creates a line chart builder and sets the Y-axis text style to blue, 18-point font.\n var textStyle = Charts.newTextStyle().setColor(&#39;blue&#39;).setFontSize(18).build();\n var builder = Charts.newLineChart();\n builder.setYAxisTextStyle(textStyle);\n "
      },
      "setYAxisTitle": {
        "!type": "fn(title: string) -> SpreadsheetApp.EmbeddedAreaChartBuilder",
        "!doc": "Adds a title to the vertical axis.  The title will be centered and will appear to the\n left of the value labels.\n\n \n \n // Creates a line chart builder and sets the Y-axis title.\n var builder = Charts.newLineChart();\n builder.setYAxisTitle(&#39;Y-axis Title&#39;)\n "
      },
      "setYAxisTitleTextStyle": {
        "!type": "fn(textStyle: Charts.TextStyle) -> SpreadsheetApp.EmbeddedAreaChartBuilder",
        "!doc": "Sets the vertical axis title text style.\n\n \n \n // Creates a line chart builder and sets the Y-axis title text style to blue, 18-point font.\n var textStyle = Charts.newTextStyle().setColor(&#39;blue&#39;).setFontSize(18).build();\n var builder = Charts.newLineChart();\n builder.setYAxisTitleTextStyle(textStyle);\n "
      },
      "useLogScale": {
        "!type": "fn() -> SpreadsheetApp.EmbeddedAreaChartBuilder",
        "!doc": "Makes the range axis into a logarithmic scale (requires all values to be positive).  The range\n axis will be the vertical axis for vertical charts (line, area, column, etc.) and the\n horizontal axis for horizontal charts (bar, etc.)"
      }
    },
    "SpreadsheetApp.EmbeddedBarChartBuilder": {
      "addRange": {
        "!type": "fn(range: SpreadsheetApp.Range) -> SpreadsheetApp.EmbeddedChartBuilder",
        "!doc": "Adds a Range to the chart represented by this builder. Will not add the Range\n if it has already been added to the chart.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var chart = sheet.newChart()\n     .setChartType(Charts.ChartType.BAR)\n     .addRange(sheet.getRange(&quot;A1:B8&quot;))\n     .setPosition(5, 5, 0, 0)\n     .build();\n\n sheet.insertChart(chart);\n "
      },
      "asAreaChart": {
        "!type": "fn() -> SpreadsheetApp.EmbeddedAreaChartBuilder",
        "!doc": "Sets the chart type to AreaChart and returns an EmbeddedAreaChartBuilder."
      },
      "asBarChart": {
        "!type": "fn() -> SpreadsheetApp.EmbeddedBarChartBuilder",
        "!doc": "Sets the chart type to BarChart and returns an EmbeddedBarChartBuilder."
      },
      "asColumnChart": {
        "!type": "fn() -> SpreadsheetApp.EmbeddedColumnChartBuilder",
        "!doc": "Sets the chart type to ColumnChart and returns an EmbeddedColumnChartBuilder."
      },
      "asLineChart": {
        "!type": "fn() -> SpreadsheetApp.EmbeddedLineChartBuilder",
        "!doc": "Sets the chart type to LineChart and returns an EmbeddedLineChartBuilder."
      },
      "asPieChart": {
        "!type": "fn() -> SpreadsheetApp.EmbeddedPieChartBuilder",
        "!doc": "Sets the chart type to PieChart and returns an EmbeddedPieChartBuilder."
      },
      "asScatterChart": {
        "!type": "fn() -> SpreadsheetApp.EmbeddedScatterChartBuilder",
        "!doc": "Sets the chart type to ScatterChart and returns an EmbeddedScatterChartBuilder."
      },
      "asTableChart": {
        "!type": "fn() -> SpreadsheetApp.EmbeddedTableChartBuilder",
        "!doc": "Sets the chart type to TableChart and returns an EmbeddedTableChartBuilder."
      },
      "build": {
        "!type": "fn() -> SpreadsheetApp.EmbeddedChart",
        "!doc": "Builds the chart to reflect all changes made to it.\n\n This method will not automatically draw the chart on top of the spreadsheet. A new chart\n must be inserted via sheet.insertChart(chart), and an existing chart should be updated via\n sheet.update(chart);\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var range = sheet.getRange(&quot;A1:B5&quot;);\n var chart = sheet.newChart()\n     .setChartType(Charts.ChartType.BAR)\n     .addRange(range)\n     .setPosition(5, 5, 0, 0)\n     .build()\n\n sheet.insertChart(chart);\n "
      },
      "getChartType": {
        "!type": "fn() -> Charts.ChartType",
        "!doc": "Returns the current chart type."
      },
      "getContainer": {
        "!type": "fn() -> SpreadsheetApp.ContainerInfo",
        "!doc": "Return the ContainerInfo, which encapsulates where the chart appears on the sheet.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var chartBuilder = sheet.newChart()\n     .setChartType(Charts.ChartType.BAR)\n     .addRange(sheet.getRange(&quot;A1:B8&quot;))\n     .setPosition(5, 5, 0, 0);\n\n // This method returns the exact same data as Chart#getContainerInfo()\n var containerInfo = chartBuilder.getContainer();\n\n // Logs the values we used in setPosition()\n Logger.log(&quot;Anchor Column: %s\\r\\nAnchor Row %s\\r\\nOffset X %s\\r\\nOffset Y %s&quot;,\n           containerInfo.getAnchorColumn(),\n           containerInfo.getAnchorRow(),\n           containerInfo.getOffsetX(),\n           containerInfo.getOffsetY());\n "
      },
      "getRanges": {
        "!type": "fn() -> [SpreadsheetApp.Range]",
        "!doc": "Returns a copy of the list of ranges currently providing data for this chart. Use addRange and\n removeRange to modify this list.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var chartBuilder = sheet.newChart()\n     .setChartType(Charts.ChartType.BAR)\n     .addRange(sheet.getRange(&quot;A1:B8&quot;))\n     .setPosition(5, 5, 0, 0)\n\n var ranges = chartBuilder.getRanges();\n\n // There&#39;s only one range as a data source for this chart,\n // so this logs &quot;A1:B8&quot;\n for (var i in ranges) {\n   var range = ranges[i];\n   Logger.log(range.getA1Notation());\n }\n "
      },
      "removeRange": {
        "!type": "fn(range: SpreadsheetApp.Range) -> SpreadsheetApp.EmbeddedChartBuilder",
        "!doc": "Removes the specified Range from the chart represented by this builder. Will not throw an error\n if the Range is not in this chart.\n\n The range removed must match up with a range added via addRange(range), or it will\n not be removed, and it will not throw an exception. This method cannot be used to partially\n remove values from a range.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var firstRange = sheet.getRange(&quot;A1:B5&quot;);\n var secondRange = sheet.getRange(&quot;A6:B8&quot;);\n\n var chartBuilder = sheet.newChart()\n     .setChartType(Charts.ChartType.BAR)\n     .addRange(firstRange)\n     // This range will render in a different color\n     .addRange(secondRange)\n     .setPosition(5, 5, 0, 0);\n\n // Note that you can use either of these two formats, but the range\n // MUST match up with a range that was added via addRange(), or it\n // will not be removed, and will not throw an exception\n chartBuilder.removeRange(firstRange);\n chartBuilder.removeRange(sheet.getRange(&quot;A6:B8&quot;));\n\n var chart = chartBuilder.build();\n\n sheet.insertChart(chart);\n  "
      },
      "reverseCategories": {
        "!type": "fn() -> SpreadsheetApp.EmbeddedBarChartBuilder",
        "!doc": "Reverses the drawing of series in the domain axis.  For vertical-range charts (such as line,\n area or column charts), this means the horizontal axis is drawn from right to left.  For\n horizontal-range charts (such as bar charts), this means the vertical axis is drawn from top\n to bottom.  For pie charts, this means the slices are drawn counterclockwise.\n\n \n \n // Creates a pie chart builder and sets drawing of the slices in a counter-clockwise manner.\n var builder = Charts.newPieChart();\n builder.reverseCategories();\n "
      },
      "reverseDirection": {
        "!type": "fn() -> SpreadsheetApp.EmbeddedBarChartBuilder",
        "!doc": "Reverses the direction in which the bars grow along the horizontal axis.  By default, values\n grow from left to right.  Calling this method will cause them to grow from right to left."
      },
      "setBackgroundColor": {
        "!type": "fn(cssValue: string) -> SpreadsheetApp.EmbeddedBarChartBuilder",
        "!doc": "Sets the background color for the chart.\n\n \n \n // Creates a line chart builder and sets the background color to gray\n var builder = Charts.newLineChart();\n builder.setBackgroundColor(&quot;gray&quot;);\n "
      },
      "setChartType": {
        "!type": "fn(type: Charts.ChartType) -> SpreadsheetApp.EmbeddedChartBuilder",
        "!doc": "Changes the type of chart. Not all embedded chart types are currently supported. See\n ChartType.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var range = sheet.getRange(&quot;A1:B5&quot;);\n var chart = sheet.newChart()\n     .setChartType(Charts.ChartType.BAR)\n     .addRange(range)\n     .setPosition(5, 5, 0, 0)\n     .build()\n\n sheet.insertChart(chart);\n "
      },
      "setColors": {
        "!type": "fn(cssValues: [string]) -> SpreadsheetApp.EmbeddedBarChartBuilder",
        "!doc": "Sets the colors for the lines in the chart.\n\n \n \n // Creates a line chart builder and sets the first two lines to be drawn in green and red,\n // respectively.\n var builder = Charts.newLineChart();\n builder.setColors([&quot;green&quot;, &quot;red&quot;]);\n "
      },
      "setLegendPosition": {
        "!type": "fn(position: Charts.Position) -> SpreadsheetApp.EmbeddedBarChartBuilder",
        "!doc": "Sets the position of the legend with respect to the chart.  By default, there will be no\n legend.\n\n \n \n // Creates a line chart builder and sets the legend position to right.\n var builder = Charts.newLineChart();\n builder.setLegendPosition(Charts.Position.RIGHT);\n "
      },
      "setLegendTextStyle": {
        "!type": "fn(textStyle: Charts.TextStyle) -> SpreadsheetApp.EmbeddedBarChartBuilder",
        "!doc": "Sets the text style of the chart legend.\n\n \n \n // Creates a line chart builder and sets it up for a  blue, 26-point legend.\n var textStyleBuilder = Charts.newTextStyle().setColor(&#39;#0000FF&#39;).setFontSize(26);\n var style = textStyleBuilder.build();\n var builder = Charts.newLineChart();\n builder.setLegendTextStyle(style);\n "
      },
      "setOption": {
        "!type": "fn(option: string, value: object) -> SpreadsheetApp.EmbeddedChartBuilder",
        "!doc": "Sets advanced options for this chart. See\n \n https://developers.google.com/chart/interactive/docs/reference for what\n options are available.\n\n This method will NOT validate the option you specify is valid for this\n chart type nor if the value is of the correct format/structure.\n\n This example shows how to change the animation duration to 1 second and\n set a legend.\n\n \n \n builder.setOption(&#39;title&#39;, &#39;Earnings projections&#39;);\n builder.setOption(&#39;animation.duration&#39;, 1000);\n builder.setOption(&#39;legend&#39;, {position: &#39;top&#39;, textStyle: {color: &#39;blue&#39;, fontSize: 16}});\n "
      },
      "setPosition": {
        "!type": "fn(anchorRowPos: number, anchorColPos: number, offsetX: number, offsetY: number) -> SpreadsheetApp.EmbeddedChartBuilder",
        "!doc": "Sets the position, changing where the chart appears on the sheet. AnchorRowPos and AnchorColPos\n are 1-indexed.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var range = sheet.getRange(&quot;A1:B5&quot;);\n var chart = sheet.newChart()\n     .setChartType(Charts.ChartType.BAR)\n     .addRange(range)\n     .setPosition(5, 5, 0, 0)\n     .build()\n\n sheet.insertChart(chart);\n "
      },
      "setRange": {
        "!type": "fn(start: number, end: number) -> SpreadsheetApp.EmbeddedBarChartBuilder",
        "!doc": "Sets the range for the chart.\n \n If any data points fall outside the range, the range will be expanded to include those data\n points."
      },
      "setStacked": {
        "!type": "fn() -> SpreadsheetApp.EmbeddedBarChartBuilder",
        "!doc": "Uses stacked lines, meaning that line and bar values are stacked (accumulated).  By default,\n there is no stacking."
      },
      "setTitle": {
        "!type": "fn(chartTitle: string) -> SpreadsheetApp.EmbeddedBarChartBuilder",
        "!doc": "Sets the title of the chart.  The title will be displayed centered above the chart.\n\n \n \n // Creates a line chart builder and title to &#39;My Line Chart&#39;.\n var builder = Charts.newLineChart();\n builder.setTitle(&#39;My Line Chart&#39;)\n "
      },
      "setTitleTextStyle": {
        "!type": "fn(textStyle: Charts.TextStyle) -> SpreadsheetApp.EmbeddedBarChartBuilder",
        "!doc": "Sets the text style of the chart title.\n\n \n \n // Creates a line chart builder and sets it up for a  blue, 26-point title.\n var textStyleBuilder = Charts.newTextStyle().setColor(&#39;#0000FF&#39;).setFontSize(26);\n var style = textStyleBuilder.build();\n var builder = Charts.newLineChart();\n builder.setTitleTextStyle(style);\n "
      },
      "setXAxisTextStyle": {
        "!type": "fn(textStyle: Charts.TextStyle) -> SpreadsheetApp.EmbeddedBarChartBuilder",
        "!doc": "Sets the horizontal axis text style.\n\n \n \n // Creates a line chart builder and sets the X-axis text style to blue, 18-point font.\n var textStyle = Charts.newTextStyle().setColor(&#39;blue&#39;).setFontSize(18).build();\n var builder = Charts.newLineChart();\n builder.setXAxisTextStyle(textStyle);\n "
      },
      "setXAxisTitle": {
        "!type": "fn(title: string) -> SpreadsheetApp.EmbeddedBarChartBuilder",
        "!doc": "Adds a title to the horizontal axis.  The title will be centered and will appear below\n the axis value labels.\n\n \n \n // Creates a line chart builder and sets the X-axis title.\n var builder = Charts.newLineChart();\n builder.setTitle(&#39;X-axis Title&#39;)\n "
      },
      "setXAxisTitleTextStyle": {
        "!type": "fn(textStyle: Charts.TextStyle) -> SpreadsheetApp.EmbeddedBarChartBuilder",
        "!doc": "Sets the horizontal axis title text style.\n\n \n \n // Creates a line chart builder and sets the X-axis title text style to blue, 18-point font.\n var textStyle = Charts.newTextStyle().setColor(&#39;blue&#39;).setFontSize(18).build();\n var builder = Charts.newLineChart();\n builder.setXAxisTitleTextStyle(textStyle);\n "
      },
      "setYAxisTextStyle": {
        "!type": "fn(textStyle: Charts.TextStyle) -> SpreadsheetApp.EmbeddedBarChartBuilder",
        "!doc": "Sets the vertical axis text style.\n\n \n \n // Creates a line chart builder and sets the Y-axis text style to blue, 18-point font.\n var textStyle = Charts.newTextStyle().setColor(&#39;blue&#39;).setFontSize(18).build();\n var builder = Charts.newLineChart();\n builder.setYAxisTextStyle(textStyle);\n "
      },
      "setYAxisTitle": {
        "!type": "fn(title: string) -> SpreadsheetApp.EmbeddedBarChartBuilder",
        "!doc": "Adds a title to the vertical axis.  The title will be centered and will appear to the\n left of the value labels.\n\n \n \n // Creates a line chart builder and sets the Y-axis title.\n var builder = Charts.newLineChart();\n builder.setYAxisTitle(&#39;Y-axis Title&#39;)\n "
      },
      "setYAxisTitleTextStyle": {
        "!type": "fn(textStyle: Charts.TextStyle) -> SpreadsheetApp.EmbeddedBarChartBuilder",
        "!doc": "Sets the vertical axis title text style.\n\n \n \n // Creates a line chart builder and sets the Y-axis title text style to blue, 18-point font.\n var textStyle = Charts.newTextStyle().setColor(&#39;blue&#39;).setFontSize(18).build();\n var builder = Charts.newLineChart();\n builder.setYAxisTitleTextStyle(textStyle);\n "
      },
      "useLogScale": {
        "!type": "fn() -> SpreadsheetApp.EmbeddedBarChartBuilder",
        "!doc": "Makes the range axis into a logarithmic scale (requires all values to be positive).  The range\n axis will be the vertical axis for vertical charts (line, area, column, etc.) and the\n horizontal axis for horizontal charts (bar, etc.)"
      }
    },
    "SpreadsheetApp.EmbeddedChart": {
      "getAs": {
        "!type": "fn(contentType: string) -> Blob",
        "!doc": "Return the data inside this object as a blob converted to the specified content type. This\n method adds the appropriate extension to the filename ? for example, \"myfile.pdf\". However, it\n assumes that the part of the filename that follows the last period (if any) is an existing\n extension that should be replaced. Consequently, \"ChristmasList.12.25.2014\" will become\n \"ChristmasList.12.25.pdf\"."
      },
      "getBlob": {
        "!type": "fn() -> Blob",
        "!doc": "Return the data inside this object as a blob."
      },
      "getContainerInfo": {
        "!type": "fn() -> SpreadsheetApp.ContainerInfo",
        "!doc": "Returns information about where the chart is positioned within a sheet.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var chart = sheet.newChart()\n     .setChartType(Charts.ChartType.BAR)\n     .addRange(sheet.getRange(&quot;A1:B8&quot;))\n     .setPosition(5, 5, 0, 0)\n     .build();\n\n var containerInfo = chart.getContainerInfo();\n\n // Logs the values we used in setPosition()\n Logger.log(&quot;Anchor Column: %s\\r\\nAnchor Row %s\\r\\nOffset X %s\\r\\nOffset Y %s&quot;,\n           containerInfo.getAnchorColumn(),\n           containerInfo.getAnchorRow(),\n           containerInfo.getOffsetX(),\n           containerInfo.getOffsetY());\n "
      },
      "getId": {
        "!type": "fn() -> string",
        "!doc": "Returns the id that has been assigned to this object.\n \n This can be used in conjunction with app.getElementById() to retrieve a reference to this\n object."
      },
      "getOptions": {
        "!type": "fn() -> Charts.ChartOptions",
        "!doc": "Returns the options for this chart, such as height, colors, axes, etc.\n \n The returned options are immutable."
      },
      "getRanges": {
        "!type": "fn() -> [SpreadsheetApp.Range]",
        "!doc": "Returns the Ranges that this chart uses as a data source.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var chart = sheet.newChart()\n     .setChartType(Charts.ChartType.BAR)\n     .addRange(sheet.getRange(&quot;A1:B8&quot;))\n     .setPosition(5, 5, 0, 0)\n     .build();\n\n var ranges = chart.getRanges();\n\n // There&#39;s only one range as a data source for this chart,\n // so this logs &quot;A1:B8&quot;\n for (var i in ranges) {\n   var range = ranges[i];\n   Logger.log(range.getA1Notation());\n }\n "
      },
      "getType": {
        "!type": "fn() -> string",
        "!doc": "Gets the type of this object."
      },
      "modify": {
        "!type": "fn() -> SpreadsheetApp.EmbeddedChartBuilder",
        "!doc": "Returns an EmbeddedChartBuilder that can be used to modify this chart. Remember to\n invoke sheet.updateChart(chart) to save your changes.\n\n \n \n var sheet = SpreadsheetApp.getActiveSheet();\n var chart = sheet.getCharts()[0];\n chart = chart.modify()\n     .setOption(&#39;width&#39;, 800)\n     .setOption(&#39;height&#39;, 640)\n     .setPosition(5, 5, 0, 0)\n     .build();\n sheet.updateChart(chart);\n "
      },
      "setId": {
        "!type": "fn(id: string) -> Charts.Chart",
        "!doc": "Sets the id of this EmbeddedChart to be used with UiApp."
      }
    },
    "SpreadsheetApp.EmbeddedChartBuilder": {
      "addRange": {
        "!type": "fn(range: SpreadsheetApp.Range) -> SpreadsheetApp.EmbeddedChartBuilder",
        "!doc": "Adds a Range to the chart represented by this builder. Will not add the Range\n if it has already been added to the chart.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var chart = sheet.newChart()\n     .setChartType(Charts.ChartType.BAR)\n     .addRange(sheet.getRange(&quot;A1:B8&quot;))\n     .setPosition(5, 5, 0, 0)\n     .build();\n\n sheet.insertChart(chart);\n "
      },
      "asAreaChart": {
        "!type": "fn() -> SpreadsheetApp.EmbeddedAreaChartBuilder",
        "!doc": "Sets the chart type to AreaChart and returns an EmbeddedAreaChartBuilder."
      },
      "asBarChart": {
        "!type": "fn() -> SpreadsheetApp.EmbeddedBarChartBuilder",
        "!doc": "Sets the chart type to BarChart and returns an EmbeddedBarChartBuilder."
      },
      "asColumnChart": {
        "!type": "fn() -> SpreadsheetApp.EmbeddedColumnChartBuilder",
        "!doc": "Sets the chart type to ColumnChart and returns an EmbeddedColumnChartBuilder."
      },
      "asLineChart": {
        "!type": "fn() -> SpreadsheetApp.EmbeddedLineChartBuilder",
        "!doc": "Sets the chart type to LineChart and returns an EmbeddedLineChartBuilder."
      },
      "asPieChart": {
        "!type": "fn() -> SpreadsheetApp.EmbeddedPieChartBuilder",
        "!doc": "Sets the chart type to PieChart and returns an EmbeddedPieChartBuilder."
      },
      "asScatterChart": {
        "!type": "fn() -> SpreadsheetApp.EmbeddedScatterChartBuilder",
        "!doc": "Sets the chart type to ScatterChart and returns an EmbeddedScatterChartBuilder."
      },
      "asTableChart": {
        "!type": "fn() -> SpreadsheetApp.EmbeddedTableChartBuilder",
        "!doc": "Sets the chart type to TableChart and returns an EmbeddedTableChartBuilder."
      },
      "build": {
        "!type": "fn() -> SpreadsheetApp.EmbeddedChart",
        "!doc": "Builds the chart to reflect all changes made to it.\n\n This method will not automatically draw the chart on top of the spreadsheet. A new chart\n must be inserted via sheet.insertChart(chart), and an existing chart should be updated via\n sheet.update(chart);\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var range = sheet.getRange(&quot;A1:B5&quot;);\n var chart = sheet.newChart()\n     .setChartType(Charts.ChartType.BAR)\n     .addRange(range)\n     .setPosition(5, 5, 0, 0)\n     .build()\n\n sheet.insertChart(chart);\n "
      },
      "getChartType": {
        "!type": "fn() -> Charts.ChartType",
        "!doc": "Returns the current chart type."
      },
      "getContainer": {
        "!type": "fn() -> SpreadsheetApp.ContainerInfo",
        "!doc": "Return the ContainerInfo, which encapsulates where the chart appears on the sheet.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var chartBuilder = sheet.newChart()\n     .setChartType(Charts.ChartType.BAR)\n     .addRange(sheet.getRange(&quot;A1:B8&quot;))\n     .setPosition(5, 5, 0, 0);\n\n // This method returns the exact same data as Chart#getContainerInfo()\n var containerInfo = chartBuilder.getContainer();\n\n // Logs the values we used in setPosition()\n Logger.log(&quot;Anchor Column: %s\\r\\nAnchor Row %s\\r\\nOffset X %s\\r\\nOffset Y %s&quot;,\n           containerInfo.getAnchorColumn(),\n           containerInfo.getAnchorRow(),\n           containerInfo.getOffsetX(),\n           containerInfo.getOffsetY());\n "
      },
      "getRanges": {
        "!type": "fn() -> [SpreadsheetApp.Range]",
        "!doc": "Returns a copy of the list of ranges currently providing data for this chart. Use addRange and\n removeRange to modify this list.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var chartBuilder = sheet.newChart()\n     .setChartType(Charts.ChartType.BAR)\n     .addRange(sheet.getRange(&quot;A1:B8&quot;))\n     .setPosition(5, 5, 0, 0)\n\n var ranges = chartBuilder.getRanges();\n\n // There&#39;s only one range as a data source for this chart,\n // so this logs &quot;A1:B8&quot;\n for (var i in ranges) {\n   var range = ranges[i];\n   Logger.log(range.getA1Notation());\n }\n "
      },
      "removeRange": {
        "!type": "fn(range: SpreadsheetApp.Range) -> SpreadsheetApp.EmbeddedChartBuilder",
        "!doc": "Removes the specified Range from the chart represented by this builder. Will not throw an error\n if the Range is not in this chart.\n\n The range removed must match up with a range added via addRange(range), or it will\n not be removed, and it will not throw an exception. This method cannot be used to partially\n remove values from a range.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var firstRange = sheet.getRange(&quot;A1:B5&quot;);\n var secondRange = sheet.getRange(&quot;A6:B8&quot;);\n\n var chartBuilder = sheet.newChart()\n     .setChartType(Charts.ChartType.BAR)\n     .addRange(firstRange)\n     // This range will render in a different color\n     .addRange(secondRange)\n     .setPosition(5, 5, 0, 0);\n\n // Note that you can use either of these two formats, but the range\n // MUST match up with a range that was added via addRange(), or it\n // will not be removed, and will not throw an exception\n chartBuilder.removeRange(firstRange);\n chartBuilder.removeRange(sheet.getRange(&quot;A6:B8&quot;));\n\n var chart = chartBuilder.build();\n\n sheet.insertChart(chart);\n  "
      },
      "setChartType": {
        "!type": "fn(type: Charts.ChartType) -> SpreadsheetApp.EmbeddedChartBuilder",
        "!doc": "Changes the type of chart. Not all embedded chart types are currently supported. See\n ChartType.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var range = sheet.getRange(&quot;A1:B5&quot;);\n var chart = sheet.newChart()\n     .setChartType(Charts.ChartType.BAR)\n     .addRange(range)\n     .setPosition(5, 5, 0, 0)\n     .build()\n\n sheet.insertChart(chart);\n "
      },
      "setOption": {
        "!type": "fn(option: string, value: object) -> SpreadsheetApp.EmbeddedChartBuilder",
        "!doc": "Sets advanced options for this chart. See\n \n https://developers.google.com/chart/interactive/docs/reference for what\n options are available.\n\n This method will NOT validate the option you specify is valid for this\n chart type nor if the value is of the correct format/structure.\n\n This example shows how to change the animation duration to 1 second and\n set a legend.\n\n \n \n builder.setOption(&#39;title&#39;, &#39;Earnings projections&#39;);\n builder.setOption(&#39;animation.duration&#39;, 1000);\n builder.setOption(&#39;legend&#39;, {position: &#39;top&#39;, textStyle: {color: &#39;blue&#39;, fontSize: 16}});\n "
      },
      "setPosition": {
        "!type": "fn(anchorRowPos: number, anchorColPos: number, offsetX: number, offsetY: number) -> SpreadsheetApp.EmbeddedChartBuilder",
        "!doc": "Sets the position, changing where the chart appears on the sheet. AnchorRowPos and AnchorColPos\n are 1-indexed.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var range = sheet.getRange(&quot;A1:B5&quot;);\n var chart = sheet.newChart()\n     .setChartType(Charts.ChartType.BAR)\n     .addRange(range)\n     .setPosition(5, 5, 0, 0)\n     .build()\n\n sheet.insertChart(chart);\n "
      }
    },
    "SpreadsheetApp.EmbeddedColumnChartBuilder": {
      "addRange": {
        "!type": "fn(range: SpreadsheetApp.Range) -> SpreadsheetApp.EmbeddedChartBuilder",
        "!doc": "Adds a Range to the chart represented by this builder. Will not add the Range\n if it has already been added to the chart.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var chart = sheet.newChart()\n     .setChartType(Charts.ChartType.BAR)\n     .addRange(sheet.getRange(&quot;A1:B8&quot;))\n     .setPosition(5, 5, 0, 0)\n     .build();\n\n sheet.insertChart(chart);\n "
      },
      "asAreaChart": {
        "!type": "fn() -> SpreadsheetApp.EmbeddedAreaChartBuilder",
        "!doc": "Sets the chart type to AreaChart and returns an EmbeddedAreaChartBuilder."
      },
      "asBarChart": {
        "!type": "fn() -> SpreadsheetApp.EmbeddedBarChartBuilder",
        "!doc": "Sets the chart type to BarChart and returns an EmbeddedBarChartBuilder."
      },
      "asColumnChart": {
        "!type": "fn() -> SpreadsheetApp.EmbeddedColumnChartBuilder",
        "!doc": "Sets the chart type to ColumnChart and returns an EmbeddedColumnChartBuilder."
      },
      "asLineChart": {
        "!type": "fn() -> SpreadsheetApp.EmbeddedLineChartBuilder",
        "!doc": "Sets the chart type to LineChart and returns an EmbeddedLineChartBuilder."
      },
      "asPieChart": {
        "!type": "fn() -> SpreadsheetApp.EmbeddedPieChartBuilder",
        "!doc": "Sets the chart type to PieChart and returns an EmbeddedPieChartBuilder."
      },
      "asScatterChart": {
        "!type": "fn() -> SpreadsheetApp.EmbeddedScatterChartBuilder",
        "!doc": "Sets the chart type to ScatterChart and returns an EmbeddedScatterChartBuilder."
      },
      "asTableChart": {
        "!type": "fn() -> SpreadsheetApp.EmbeddedTableChartBuilder",
        "!doc": "Sets the chart type to TableChart and returns an EmbeddedTableChartBuilder."
      },
      "build": {
        "!type": "fn() -> SpreadsheetApp.EmbeddedChart",
        "!doc": "Builds the chart to reflect all changes made to it.\n\n This method will not automatically draw the chart on top of the spreadsheet. A new chart\n must be inserted via sheet.insertChart(chart), and an existing chart should be updated via\n sheet.update(chart);\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var range = sheet.getRange(&quot;A1:B5&quot;);\n var chart = sheet.newChart()\n     .setChartType(Charts.ChartType.BAR)\n     .addRange(range)\n     .setPosition(5, 5, 0, 0)\n     .build()\n\n sheet.insertChart(chart);\n "
      },
      "getChartType": {
        "!type": "fn() -> Charts.ChartType",
        "!doc": "Returns the current chart type."
      },
      "getContainer": {
        "!type": "fn() -> SpreadsheetApp.ContainerInfo",
        "!doc": "Return the ContainerInfo, which encapsulates where the chart appears on the sheet.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var chartBuilder = sheet.newChart()\n     .setChartType(Charts.ChartType.BAR)\n     .addRange(sheet.getRange(&quot;A1:B8&quot;))\n     .setPosition(5, 5, 0, 0);\n\n // This method returns the exact same data as Chart#getContainerInfo()\n var containerInfo = chartBuilder.getContainer();\n\n // Logs the values we used in setPosition()\n Logger.log(&quot;Anchor Column: %s\\r\\nAnchor Row %s\\r\\nOffset X %s\\r\\nOffset Y %s&quot;,\n           containerInfo.getAnchorColumn(),\n           containerInfo.getAnchorRow(),\n           containerInfo.getOffsetX(),\n           containerInfo.getOffsetY());\n "
      },
      "getRanges": {
        "!type": "fn() -> [SpreadsheetApp.Range]",
        "!doc": "Returns a copy of the list of ranges currently providing data for this chart. Use addRange and\n removeRange to modify this list.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var chartBuilder = sheet.newChart()\n     .setChartType(Charts.ChartType.BAR)\n     .addRange(sheet.getRange(&quot;A1:B8&quot;))\n     .setPosition(5, 5, 0, 0)\n\n var ranges = chartBuilder.getRanges();\n\n // There&#39;s only one range as a data source for this chart,\n // so this logs &quot;A1:B8&quot;\n for (var i in ranges) {\n   var range = ranges[i];\n   Logger.log(range.getA1Notation());\n }\n "
      },
      "removeRange": {
        "!type": "fn(range: SpreadsheetApp.Range) -> SpreadsheetApp.EmbeddedChartBuilder",
        "!doc": "Removes the specified Range from the chart represented by this builder. Will not throw an error\n if the Range is not in this chart.\n\n The range removed must match up with a range added via addRange(range), or it will\n not be removed, and it will not throw an exception. This method cannot be used to partially\n remove values from a range.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var firstRange = sheet.getRange(&quot;A1:B5&quot;);\n var secondRange = sheet.getRange(&quot;A6:B8&quot;);\n\n var chartBuilder = sheet.newChart()\n     .setChartType(Charts.ChartType.BAR)\n     .addRange(firstRange)\n     // This range will render in a different color\n     .addRange(secondRange)\n     .setPosition(5, 5, 0, 0);\n\n // Note that you can use either of these two formats, but the range\n // MUST match up with a range that was added via addRange(), or it\n // will not be removed, and will not throw an exception\n chartBuilder.removeRange(firstRange);\n chartBuilder.removeRange(sheet.getRange(&quot;A6:B8&quot;));\n\n var chart = chartBuilder.build();\n\n sheet.insertChart(chart);\n  "
      },
      "reverseCategories": {
        "!type": "fn() -> SpreadsheetApp.EmbeddedColumnChartBuilder",
        "!doc": "Reverses the drawing of series in the domain axis.  For vertical-range charts (such as line,\n area or column charts), this means the horizontal axis is drawn from right to left.  For\n horizontal-range charts (such as bar charts), this means the vertical axis is drawn from top\n to bottom.  For pie charts, this means the slices are drawn counterclockwise.\n\n \n \n // Creates a pie chart builder and sets drawing of the slices in a counter-clockwise manner.\n var builder = Charts.newPieChart();\n builder.reverseCategories();\n "
      },
      "setBackgroundColor": {
        "!type": "fn(cssValue: string) -> SpreadsheetApp.EmbeddedColumnChartBuilder",
        "!doc": "Sets the background color for the chart.\n\n \n \n // Creates a line chart builder and sets the background color to gray\n var builder = Charts.newLineChart();\n builder.setBackgroundColor(&quot;gray&quot;);\n "
      },
      "setChartType": {
        "!type": "fn(type: Charts.ChartType) -> SpreadsheetApp.EmbeddedChartBuilder",
        "!doc": "Changes the type of chart. Not all embedded chart types are currently supported. See\n ChartType.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var range = sheet.getRange(&quot;A1:B5&quot;);\n var chart = sheet.newChart()\n     .setChartType(Charts.ChartType.BAR)\n     .addRange(range)\n     .setPosition(5, 5, 0, 0)\n     .build()\n\n sheet.insertChart(chart);\n "
      },
      "setColors": {
        "!type": "fn(cssValues: [string]) -> SpreadsheetApp.EmbeddedColumnChartBuilder",
        "!doc": "Sets the colors for the lines in the chart.\n\n \n \n // Creates a line chart builder and sets the first two lines to be drawn in green and red,\n // respectively.\n var builder = Charts.newLineChart();\n builder.setColors([&quot;green&quot;, &quot;red&quot;]);\n "
      },
      "setLegendPosition": {
        "!type": "fn(position: Charts.Position) -> SpreadsheetApp.EmbeddedColumnChartBuilder",
        "!doc": "Sets the position of the legend with respect to the chart.  By default, there will be no\n legend.\n\n \n \n // Creates a line chart builder and sets the legend position to right.\n var builder = Charts.newLineChart();\n builder.setLegendPosition(Charts.Position.RIGHT);\n "
      },
      "setLegendTextStyle": {
        "!type": "fn(textStyle: Charts.TextStyle) -> SpreadsheetApp.EmbeddedColumnChartBuilder",
        "!doc": "Sets the text style of the chart legend.\n\n \n \n // Creates a line chart builder and sets it up for a  blue, 26-point legend.\n var textStyleBuilder = Charts.newTextStyle().setColor(&#39;#0000FF&#39;).setFontSize(26);\n var style = textStyleBuilder.build();\n var builder = Charts.newLineChart();\n builder.setLegendTextStyle(style);\n "
      },
      "setOption": {
        "!type": "fn(option: string, value: object) -> SpreadsheetApp.EmbeddedChartBuilder",
        "!doc": "Sets advanced options for this chart. See\n \n https://developers.google.com/chart/interactive/docs/reference for what\n options are available.\n\n This method will NOT validate the option you specify is valid for this\n chart type nor if the value is of the correct format/structure.\n\n This example shows how to change the animation duration to 1 second and\n set a legend.\n\n \n \n builder.setOption(&#39;title&#39;, &#39;Earnings projections&#39;);\n builder.setOption(&#39;animation.duration&#39;, 1000);\n builder.setOption(&#39;legend&#39;, {position: &#39;top&#39;, textStyle: {color: &#39;blue&#39;, fontSize: 16}});\n "
      },
      "setPosition": {
        "!type": "fn(anchorRowPos: number, anchorColPos: number, offsetX: number, offsetY: number) -> SpreadsheetApp.EmbeddedChartBuilder",
        "!doc": "Sets the position, changing where the chart appears on the sheet. AnchorRowPos and AnchorColPos\n are 1-indexed.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var range = sheet.getRange(&quot;A1:B5&quot;);\n var chart = sheet.newChart()\n     .setChartType(Charts.ChartType.BAR)\n     .addRange(range)\n     .setPosition(5, 5, 0, 0)\n     .build()\n\n sheet.insertChart(chart);\n "
      },
      "setRange": {
        "!type": "fn(start: number, end: number) -> SpreadsheetApp.EmbeddedColumnChartBuilder",
        "!doc": "Sets the range for the chart.\n \n If any data points fall outside the range, the range will be expanded to include those data\n points."
      },
      "setStacked": {
        "!type": "fn() -> SpreadsheetApp.EmbeddedColumnChartBuilder",
        "!doc": "Uses stacked lines, meaning that line and bar values are stacked (accumulated).  By default,\n there is no stacking."
      },
      "setTitle": {
        "!type": "fn(chartTitle: string) -> SpreadsheetApp.EmbeddedColumnChartBuilder",
        "!doc": "Sets the title of the chart.  The title will be displayed centered above the chart.\n\n \n \n // Creates a line chart builder and title to &#39;My Line Chart&#39;.\n var builder = Charts.newLineChart();\n builder.setTitle(&#39;My Line Chart&#39;)\n "
      },
      "setTitleTextStyle": {
        "!type": "fn(textStyle: Charts.TextStyle) -> SpreadsheetApp.EmbeddedColumnChartBuilder",
        "!doc": "Sets the text style of the chart title.\n\n \n \n // Creates a line chart builder and sets it up for a  blue, 26-point title.\n var textStyleBuilder = Charts.newTextStyle().setColor(&#39;#0000FF&#39;).setFontSize(26);\n var style = textStyleBuilder.build();\n var builder = Charts.newLineChart();\n builder.setTitleTextStyle(style);\n "
      },
      "setXAxisTextStyle": {
        "!type": "fn(textStyle: Charts.TextStyle) -> SpreadsheetApp.EmbeddedColumnChartBuilder",
        "!doc": "Sets the horizontal axis text style.\n\n \n \n // Creates a line chart builder and sets the X-axis text style to blue, 18-point font.\n var textStyle = Charts.newTextStyle().setColor(&#39;blue&#39;).setFontSize(18).build();\n var builder = Charts.newLineChart();\n builder.setXAxisTextStyle(textStyle);\n "
      },
      "setXAxisTitle": {
        "!type": "fn(title: string) -> SpreadsheetApp.EmbeddedColumnChartBuilder",
        "!doc": "Adds a title to the horizontal axis.  The title will be centered and will appear below\n the axis value labels.\n\n \n \n // Creates a line chart builder and sets the X-axis title.\n var builder = Charts.newLineChart();\n builder.setTitle(&#39;X-axis Title&#39;)\n "
      },
      "setXAxisTitleTextStyle": {
        "!type": "fn(textStyle: Charts.TextStyle) -> SpreadsheetApp.EmbeddedColumnChartBuilder",
        "!doc": "Sets the horizontal axis title text style.\n\n \n \n // Creates a line chart builder and sets the X-axis title text style to blue, 18-point font.\n var textStyle = Charts.newTextStyle().setColor(&#39;blue&#39;).setFontSize(18).build();\n var builder = Charts.newLineChart();\n builder.setXAxisTitleTextStyle(textStyle);\n "
      },
      "setYAxisTextStyle": {
        "!type": "fn(textStyle: Charts.TextStyle) -> SpreadsheetApp.EmbeddedColumnChartBuilder",
        "!doc": "Sets the vertical axis text style.\n\n \n \n // Creates a line chart builder and sets the Y-axis text style to blue, 18-point font.\n var textStyle = Charts.newTextStyle().setColor(&#39;blue&#39;).setFontSize(18).build();\n var builder = Charts.newLineChart();\n builder.setYAxisTextStyle(textStyle);\n "
      },
      "setYAxisTitle": {
        "!type": "fn(title: string) -> SpreadsheetApp.EmbeddedColumnChartBuilder",
        "!doc": "Adds a title to the vertical axis.  The title will be centered and will appear to the\n left of the value labels.\n\n \n \n // Creates a line chart builder and sets the Y-axis title.\n var builder = Charts.newLineChart();\n builder.setYAxisTitle(&#39;Y-axis Title&#39;)\n "
      },
      "setYAxisTitleTextStyle": {
        "!type": "fn(textStyle: Charts.TextStyle) -> SpreadsheetApp.EmbeddedColumnChartBuilder",
        "!doc": "Sets the vertical axis title text style.\n\n \n \n // Creates a line chart builder and sets the Y-axis title text style to blue, 18-point font.\n var textStyle = Charts.newTextStyle().setColor(&#39;blue&#39;).setFontSize(18).build();\n var builder = Charts.newLineChart();\n builder.setYAxisTitleTextStyle(textStyle);\n "
      },
      "useLogScale": {
        "!type": "fn() -> SpreadsheetApp.EmbeddedColumnChartBuilder",
        "!doc": "Makes the range axis into a logarithmic scale (requires all values to be positive).  The range\n axis will be the vertical axis for vertical charts (line, area, column, etc.) and the\n horizontal axis for horizontal charts (bar, etc.)"
      }
    },
    "SpreadsheetApp.EmbeddedLineChartBuilder": {
      "addRange": {
        "!type": "fn(range: SpreadsheetApp.Range) -> SpreadsheetApp.EmbeddedChartBuilder",
        "!doc": "Adds a Range to the chart represented by this builder. Will not add the Range\n if it has already been added to the chart.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var chart = sheet.newChart()\n     .setChartType(Charts.ChartType.BAR)\n     .addRange(sheet.getRange(&quot;A1:B8&quot;))\n     .setPosition(5, 5, 0, 0)\n     .build();\n\n sheet.insertChart(chart);\n "
      },
      "asAreaChart": {
        "!type": "fn() -> SpreadsheetApp.EmbeddedAreaChartBuilder",
        "!doc": "Sets the chart type to AreaChart and returns an EmbeddedAreaChartBuilder."
      },
      "asBarChart": {
        "!type": "fn() -> SpreadsheetApp.EmbeddedBarChartBuilder",
        "!doc": "Sets the chart type to BarChart and returns an EmbeddedBarChartBuilder."
      },
      "asColumnChart": {
        "!type": "fn() -> SpreadsheetApp.EmbeddedColumnChartBuilder",
        "!doc": "Sets the chart type to ColumnChart and returns an EmbeddedColumnChartBuilder."
      },
      "asLineChart": {
        "!type": "fn() -> SpreadsheetApp.EmbeddedLineChartBuilder",
        "!doc": "Sets the chart type to LineChart and returns an EmbeddedLineChartBuilder."
      },
      "asPieChart": {
        "!type": "fn() -> SpreadsheetApp.EmbeddedPieChartBuilder",
        "!doc": "Sets the chart type to PieChart and returns an EmbeddedPieChartBuilder."
      },
      "asScatterChart": {
        "!type": "fn() -> SpreadsheetApp.EmbeddedScatterChartBuilder",
        "!doc": "Sets the chart type to ScatterChart and returns an EmbeddedScatterChartBuilder."
      },
      "asTableChart": {
        "!type": "fn() -> SpreadsheetApp.EmbeddedTableChartBuilder",
        "!doc": "Sets the chart type to TableChart and returns an EmbeddedTableChartBuilder."
      },
      "build": {
        "!type": "fn() -> SpreadsheetApp.EmbeddedChart",
        "!doc": "Builds the chart to reflect all changes made to it.\n\n This method will not automatically draw the chart on top of the spreadsheet. A new chart\n must be inserted via sheet.insertChart(chart), and an existing chart should be updated via\n sheet.update(chart);\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var range = sheet.getRange(&quot;A1:B5&quot;);\n var chart = sheet.newChart()\n     .setChartType(Charts.ChartType.BAR)\n     .addRange(range)\n     .setPosition(5, 5, 0, 0)\n     .build()\n\n sheet.insertChart(chart);\n "
      },
      "getChartType": {
        "!type": "fn() -> Charts.ChartType",
        "!doc": "Returns the current chart type."
      },
      "getContainer": {
        "!type": "fn() -> SpreadsheetApp.ContainerInfo",
        "!doc": "Return the ContainerInfo, which encapsulates where the chart appears on the sheet.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var chartBuilder = sheet.newChart()\n     .setChartType(Charts.ChartType.BAR)\n     .addRange(sheet.getRange(&quot;A1:B8&quot;))\n     .setPosition(5, 5, 0, 0);\n\n // This method returns the exact same data as Chart#getContainerInfo()\n var containerInfo = chartBuilder.getContainer();\n\n // Logs the values we used in setPosition()\n Logger.log(&quot;Anchor Column: %s\\r\\nAnchor Row %s\\r\\nOffset X %s\\r\\nOffset Y %s&quot;,\n           containerInfo.getAnchorColumn(),\n           containerInfo.getAnchorRow(),\n           containerInfo.getOffsetX(),\n           containerInfo.getOffsetY());\n "
      },
      "getRanges": {
        "!type": "fn() -> [SpreadsheetApp.Range]",
        "!doc": "Returns a copy of the list of ranges currently providing data for this chart. Use addRange and\n removeRange to modify this list.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var chartBuilder = sheet.newChart()\n     .setChartType(Charts.ChartType.BAR)\n     .addRange(sheet.getRange(&quot;A1:B8&quot;))\n     .setPosition(5, 5, 0, 0)\n\n var ranges = chartBuilder.getRanges();\n\n // There&#39;s only one range as a data source for this chart,\n // so this logs &quot;A1:B8&quot;\n for (var i in ranges) {\n   var range = ranges[i];\n   Logger.log(range.getA1Notation());\n }\n "
      },
      "removeRange": {
        "!type": "fn(range: SpreadsheetApp.Range) -> SpreadsheetApp.EmbeddedChartBuilder",
        "!doc": "Removes the specified Range from the chart represented by this builder. Will not throw an error\n if the Range is not in this chart.\n\n The range removed must match up with a range added via addRange(range), or it will\n not be removed, and it will not throw an exception. This method cannot be used to partially\n remove values from a range.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var firstRange = sheet.getRange(&quot;A1:B5&quot;);\n var secondRange = sheet.getRange(&quot;A6:B8&quot;);\n\n var chartBuilder = sheet.newChart()\n     .setChartType(Charts.ChartType.BAR)\n     .addRange(firstRange)\n     // This range will render in a different color\n     .addRange(secondRange)\n     .setPosition(5, 5, 0, 0);\n\n // Note that you can use either of these two formats, but the range\n // MUST match up with a range that was added via addRange(), or it\n // will not be removed, and will not throw an exception\n chartBuilder.removeRange(firstRange);\n chartBuilder.removeRange(sheet.getRange(&quot;A6:B8&quot;));\n\n var chart = chartBuilder.build();\n\n sheet.insertChart(chart);\n  "
      },
      "reverseCategories": {
        "!type": "fn() -> SpreadsheetApp.EmbeddedLineChartBuilder",
        "!doc": "Reverses the drawing of series in the domain axis.  For vertical-range charts (such as line,\n area or column charts), this means the horizontal axis is drawn from right to left.  For\n horizontal-range charts (such as bar charts), this means the vertical axis is drawn from top\n to bottom.  For pie charts, this means the slices are drawn counterclockwise.\n\n \n \n // Creates a pie chart builder and sets drawing of the slices in a counter-clockwise manner.\n var builder = Charts.newPieChart();\n builder.reverseCategories();\n "
      },
      "setBackgroundColor": {
        "!type": "fn(cssValue: string) -> SpreadsheetApp.EmbeddedLineChartBuilder",
        "!doc": "Sets the background color for the chart.\n\n \n \n // Creates a line chart builder and sets the background color to gray\n var builder = Charts.newLineChart();\n builder.setBackgroundColor(&quot;gray&quot;);\n "
      },
      "setChartType": {
        "!type": "fn(type: Charts.ChartType) -> SpreadsheetApp.EmbeddedChartBuilder",
        "!doc": "Changes the type of chart. Not all embedded chart types are currently supported. See\n ChartType.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var range = sheet.getRange(&quot;A1:B5&quot;);\n var chart = sheet.newChart()\n     .setChartType(Charts.ChartType.BAR)\n     .addRange(range)\n     .setPosition(5, 5, 0, 0)\n     .build()\n\n sheet.insertChart(chart);\n "
      },
      "setColors": {
        "!type": "fn(cssValues: [string]) -> SpreadsheetApp.EmbeddedLineChartBuilder",
        "!doc": "Sets the colors for the lines in the chart.\n\n \n \n // Creates a line chart builder and sets the first two lines to be drawn in green and red,\n // respectively.\n var builder = Charts.newLineChart();\n builder.setColors([&quot;green&quot;, &quot;red&quot;]);\n "
      },
      "setCurveStyle": {
        "!type": "fn(style: Charts.CurveStyle) -> SpreadsheetApp.EmbeddedLineChartBuilder",
        "!doc": "Sets the style to use for curves in the chart.  See CurveStyle for allowed curve\n styles.\n\n \n \n // Creates a line chart builder and curves the lines in the chart.\n var builder = Charts.newLineChart();\n builder.setCurveStyle(Charts.CurveStyle.SMOOTH)\n "
      },
      "setLegendPosition": {
        "!type": "fn(position: Charts.Position) -> SpreadsheetApp.EmbeddedLineChartBuilder",
        "!doc": "Sets the position of the legend with respect to the chart.  By default, there will be no\n legend.\n\n \n \n // Creates a line chart builder and sets the legend position to right.\n var builder = Charts.newLineChart();\n builder.setLegendPosition(Charts.Position.RIGHT);\n "
      },
      "setLegendTextStyle": {
        "!type": "fn(textStyle: Charts.TextStyle) -> SpreadsheetApp.EmbeddedLineChartBuilder",
        "!doc": "Sets the text style of the chart legend.\n\n \n \n // Creates a line chart builder and sets it up for a  blue, 26-point legend.\n var textStyleBuilder = Charts.newTextStyle().setColor(&#39;#0000FF&#39;).setFontSize(26);\n var style = textStyleBuilder.build();\n var builder = Charts.newLineChart();\n builder.setLegendTextStyle(style);\n "
      },
      "setOption": {
        "!type": "fn(option: string, value: object) -> SpreadsheetApp.EmbeddedChartBuilder",
        "!doc": "Sets advanced options for this chart. See\n \n https://developers.google.com/chart/interactive/docs/reference for what\n options are available.\n\n This method will NOT validate the option you specify is valid for this\n chart type nor if the value is of the correct format/structure.\n\n This example shows how to change the animation duration to 1 second and\n set a legend.\n\n \n \n builder.setOption(&#39;title&#39;, &#39;Earnings projections&#39;);\n builder.setOption(&#39;animation.duration&#39;, 1000);\n builder.setOption(&#39;legend&#39;, {position: &#39;top&#39;, textStyle: {color: &#39;blue&#39;, fontSize: 16}});\n "
      },
      "setPointStyle": {
        "!type": "fn(style: Charts.PointStyle) -> SpreadsheetApp.EmbeddedLineChartBuilder",
        "!doc": "Sets the style for points in the line.  By default, points will have no particular styles,\n and only the line will be visible.\n\n \n \n // Creates a line chart builder and sets large point style.\n var builder = Charts.newLineChart();\n builder.setPointStyle(Charts.PointStyle.LARGE);\n "
      },
      "setPosition": {
        "!type": "fn(anchorRowPos: number, anchorColPos: number, offsetX: number, offsetY: number) -> SpreadsheetApp.EmbeddedChartBuilder",
        "!doc": "Sets the position, changing where the chart appears on the sheet. AnchorRowPos and AnchorColPos\n are 1-indexed.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var range = sheet.getRange(&quot;A1:B5&quot;);\n var chart = sheet.newChart()\n     .setChartType(Charts.ChartType.BAR)\n     .addRange(range)\n     .setPosition(5, 5, 0, 0)\n     .build()\n\n sheet.insertChart(chart);\n "
      },
      "setRange": {
        "!type": "fn(start: number, end: number) -> SpreadsheetApp.EmbeddedLineChartBuilder",
        "!doc": "Sets the range for the chart.\n \n If any data points fall outside the range, the range will be expanded to include those data\n points."
      },
      "setTitle": {
        "!type": "fn(chartTitle: string) -> SpreadsheetApp.EmbeddedLineChartBuilder",
        "!doc": "Sets the title of the chart.  The title will be displayed centered above the chart.\n\n \n \n // Creates a line chart builder and title to &#39;My Line Chart&#39;.\n var builder = Charts.newLineChart();\n builder.setTitle(&#39;My Line Chart&#39;)\n "
      },
      "setTitleTextStyle": {
        "!type": "fn(textStyle: Charts.TextStyle) -> SpreadsheetApp.EmbeddedLineChartBuilder",
        "!doc": "Sets the text style of the chart title.\n\n \n \n // Creates a line chart builder and sets it up for a  blue, 26-point title.\n var textStyleBuilder = Charts.newTextStyle().setColor(&#39;#0000FF&#39;).setFontSize(26);\n var style = textStyleBuilder.build();\n var builder = Charts.newLineChart();\n builder.setTitleTextStyle(style);\n "
      },
      "setXAxisTextStyle": {
        "!type": "fn(textStyle: Charts.TextStyle) -> SpreadsheetApp.EmbeddedLineChartBuilder",
        "!doc": "Sets the horizontal axis text style.\n\n \n \n // Creates a line chart builder and sets the X-axis text style to blue, 18-point font.\n var textStyle = Charts.newTextStyle().setColor(&#39;blue&#39;).setFontSize(18).build();\n var builder = Charts.newLineChart();\n builder.setXAxisTextStyle(textStyle);\n "
      },
      "setXAxisTitle": {
        "!type": "fn(title: string) -> SpreadsheetApp.EmbeddedLineChartBuilder",
        "!doc": "Adds a title to the horizontal axis.  The title will be centered and will appear below\n the axis value labels.\n\n \n \n // Creates a line chart builder and sets the X-axis title.\n var builder = Charts.newLineChart();\n builder.setTitle(&#39;X-axis Title&#39;)\n "
      },
      "setXAxisTitleTextStyle": {
        "!type": "fn(textStyle: Charts.TextStyle) -> SpreadsheetApp.EmbeddedLineChartBuilder",
        "!doc": "Sets the horizontal axis title text style.\n\n \n \n // Creates a line chart builder and sets the X-axis title text style to blue, 18-point font.\n var textStyle = Charts.newTextStyle().setColor(&#39;blue&#39;).setFontSize(18).build();\n var builder = Charts.newLineChart();\n builder.setXAxisTitleTextStyle(textStyle);\n "
      },
      "setYAxisTextStyle": {
        "!type": "fn(textStyle: Charts.TextStyle) -> SpreadsheetApp.EmbeddedLineChartBuilder",
        "!doc": "Sets the vertical axis text style.\n\n \n \n // Creates a line chart builder and sets the Y-axis text style to blue, 18-point font.\n var textStyle = Charts.newTextStyle().setColor(&#39;blue&#39;).setFontSize(18).build();\n var builder = Charts.newLineChart();\n builder.setYAxisTextStyle(textStyle);\n "
      },
      "setYAxisTitle": {
        "!type": "fn(title: string) -> SpreadsheetApp.EmbeddedLineChartBuilder",
        "!doc": "Adds a title to the vertical axis.  The title will be centered and will appear to the\n left of the value labels.\n\n \n \n // Creates a line chart builder and sets the Y-axis title.\n var builder = Charts.newLineChart();\n builder.setYAxisTitle(&#39;Y-axis Title&#39;)\n "
      },
      "setYAxisTitleTextStyle": {
        "!type": "fn(textStyle: Charts.TextStyle) -> SpreadsheetApp.EmbeddedLineChartBuilder",
        "!doc": "Sets the vertical axis title text style.\n\n \n \n // Creates a line chart builder and sets the Y-axis title text style to blue, 18-point font.\n var textStyle = Charts.newTextStyle().setColor(&#39;blue&#39;).setFontSize(18).build();\n var builder = Charts.newLineChart();\n builder.setYAxisTitleTextStyle(textStyle);\n "
      },
      "useLogScale": {
        "!type": "fn() -> SpreadsheetApp.EmbeddedLineChartBuilder",
        "!doc": "Makes the range axis into a logarithmic scale (requires all values to be positive).  The range\n axis will be the vertical axis for vertical charts (line, area, column, etc.) and the\n horizontal axis for horizontal charts (bar, etc.)"
      }
    },
    "SpreadsheetApp.EmbeddedPieChartBuilder": {
      "addRange": {
        "!type": "fn(range: SpreadsheetApp.Range) -> SpreadsheetApp.EmbeddedChartBuilder",
        "!doc": "Adds a Range to the chart represented by this builder. Will not add the Range\n if it has already been added to the chart.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var chart = sheet.newChart()\n     .setChartType(Charts.ChartType.BAR)\n     .addRange(sheet.getRange(&quot;A1:B8&quot;))\n     .setPosition(5, 5, 0, 0)\n     .build();\n\n sheet.insertChart(chart);\n "
      },
      "asAreaChart": {
        "!type": "fn() -> SpreadsheetApp.EmbeddedAreaChartBuilder",
        "!doc": "Sets the chart type to AreaChart and returns an EmbeddedAreaChartBuilder."
      },
      "asBarChart": {
        "!type": "fn() -> SpreadsheetApp.EmbeddedBarChartBuilder",
        "!doc": "Sets the chart type to BarChart and returns an EmbeddedBarChartBuilder."
      },
      "asColumnChart": {
        "!type": "fn() -> SpreadsheetApp.EmbeddedColumnChartBuilder",
        "!doc": "Sets the chart type to ColumnChart and returns an EmbeddedColumnChartBuilder."
      },
      "asLineChart": {
        "!type": "fn() -> SpreadsheetApp.EmbeddedLineChartBuilder",
        "!doc": "Sets the chart type to LineChart and returns an EmbeddedLineChartBuilder."
      },
      "asPieChart": {
        "!type": "fn() -> SpreadsheetApp.EmbeddedPieChartBuilder",
        "!doc": "Sets the chart type to PieChart and returns an EmbeddedPieChartBuilder."
      },
      "asScatterChart": {
        "!type": "fn() -> SpreadsheetApp.EmbeddedScatterChartBuilder",
        "!doc": "Sets the chart type to ScatterChart and returns an EmbeddedScatterChartBuilder."
      },
      "asTableChart": {
        "!type": "fn() -> SpreadsheetApp.EmbeddedTableChartBuilder",
        "!doc": "Sets the chart type to TableChart and returns an EmbeddedTableChartBuilder."
      },
      "build": {
        "!type": "fn() -> SpreadsheetApp.EmbeddedChart",
        "!doc": "Builds the chart to reflect all changes made to it.\n\n This method will not automatically draw the chart on top of the spreadsheet. A new chart\n must be inserted via sheet.insertChart(chart), and an existing chart should be updated via\n sheet.update(chart);\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var range = sheet.getRange(&quot;A1:B5&quot;);\n var chart = sheet.newChart()\n     .setChartType(Charts.ChartType.BAR)\n     .addRange(range)\n     .setPosition(5, 5, 0, 0)\n     .build()\n\n sheet.insertChart(chart);\n "
      },
      "getChartType": {
        "!type": "fn() -> Charts.ChartType",
        "!doc": "Returns the current chart type."
      },
      "getContainer": {
        "!type": "fn() -> SpreadsheetApp.ContainerInfo",
        "!doc": "Return the ContainerInfo, which encapsulates where the chart appears on the sheet.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var chartBuilder = sheet.newChart()\n     .setChartType(Charts.ChartType.BAR)\n     .addRange(sheet.getRange(&quot;A1:B8&quot;))\n     .setPosition(5, 5, 0, 0);\n\n // This method returns the exact same data as Chart#getContainerInfo()\n var containerInfo = chartBuilder.getContainer();\n\n // Logs the values we used in setPosition()\n Logger.log(&quot;Anchor Column: %s\\r\\nAnchor Row %s\\r\\nOffset X %s\\r\\nOffset Y %s&quot;,\n           containerInfo.getAnchorColumn(),\n           containerInfo.getAnchorRow(),\n           containerInfo.getOffsetX(),\n           containerInfo.getOffsetY());\n "
      },
      "getRanges": {
        "!type": "fn() -> [SpreadsheetApp.Range]",
        "!doc": "Returns a copy of the list of ranges currently providing data for this chart. Use addRange and\n removeRange to modify this list.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var chartBuilder = sheet.newChart()\n     .setChartType(Charts.ChartType.BAR)\n     .addRange(sheet.getRange(&quot;A1:B8&quot;))\n     .setPosition(5, 5, 0, 0)\n\n var ranges = chartBuilder.getRanges();\n\n // There&#39;s only one range as a data source for this chart,\n // so this logs &quot;A1:B8&quot;\n for (var i in ranges) {\n   var range = ranges[i];\n   Logger.log(range.getA1Notation());\n }\n "
      },
      "removeRange": {
        "!type": "fn(range: SpreadsheetApp.Range) -> SpreadsheetApp.EmbeddedChartBuilder",
        "!doc": "Removes the specified Range from the chart represented by this builder. Will not throw an error\n if the Range is not in this chart.\n\n The range removed must match up with a range added via addRange(range), or it will\n not be removed, and it will not throw an exception. This method cannot be used to partially\n remove values from a range.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var firstRange = sheet.getRange(&quot;A1:B5&quot;);\n var secondRange = sheet.getRange(&quot;A6:B8&quot;);\n\n var chartBuilder = sheet.newChart()\n     .setChartType(Charts.ChartType.BAR)\n     .addRange(firstRange)\n     // This range will render in a different color\n     .addRange(secondRange)\n     .setPosition(5, 5, 0, 0);\n\n // Note that you can use either of these two formats, but the range\n // MUST match up with a range that was added via addRange(), or it\n // will not be removed, and will not throw an exception\n chartBuilder.removeRange(firstRange);\n chartBuilder.removeRange(sheet.getRange(&quot;A6:B8&quot;));\n\n var chart = chartBuilder.build();\n\n sheet.insertChart(chart);\n  "
      },
      "reverseCategories": {
        "!type": "fn() -> SpreadsheetApp.EmbeddedPieChartBuilder",
        "!doc": "Reverses the drawing of series in the domain axis.  For vertical-range charts (such as line,\n area or column charts), this means the horizontal axis is drawn from right to left.  For\n horizontal-range charts (such as bar charts), this means the vertical axis is drawn from top\n to bottom.  For pie charts, this means the slices are drawn counterclockwise.\n\n \n \n // Creates a pie chart builder and sets drawing of the slices in a counter-clockwise manner.\n var builder = Charts.newPieChart();\n builder.reverseCategories();\n "
      },
      "set3D": {
        "!type": "fn() -> SpreadsheetApp.EmbeddedPieChartBuilder",
        "!doc": "Sets the chart to be three-dimensional."
      },
      "setBackgroundColor": {
        "!type": "fn(cssValue: string) -> SpreadsheetApp.EmbeddedPieChartBuilder",
        "!doc": "Sets the background color for the chart.\n\n \n \n // Creates a line chart builder and sets the background color to gray\n var builder = Charts.newLineChart();\n builder.setBackgroundColor(&quot;gray&quot;);\n "
      },
      "setChartType": {
        "!type": "fn(type: Charts.ChartType) -> SpreadsheetApp.EmbeddedChartBuilder",
        "!doc": "Changes the type of chart. Not all embedded chart types are currently supported. See\n ChartType.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var range = sheet.getRange(&quot;A1:B5&quot;);\n var chart = sheet.newChart()\n     .setChartType(Charts.ChartType.BAR)\n     .addRange(range)\n     .setPosition(5, 5, 0, 0)\n     .build()\n\n sheet.insertChart(chart);\n "
      },
      "setColors": {
        "!type": "fn(cssValues: [string]) -> SpreadsheetApp.EmbeddedPieChartBuilder",
        "!doc": "Sets the colors for the lines in the chart.\n\n \n \n // Creates a line chart builder and sets the first two lines to be drawn in green and red,\n // respectively.\n var builder = Charts.newLineChart();\n builder.setColors([&quot;green&quot;, &quot;red&quot;]);\n "
      },
      "setLegendPosition": {
        "!type": "fn(position: Charts.Position) -> SpreadsheetApp.EmbeddedPieChartBuilder",
        "!doc": "Sets the position of the legend with respect to the chart.  By default, there will be no\n legend.\n\n \n \n // Creates a line chart builder and sets the legend position to right.\n var builder = Charts.newLineChart();\n builder.setLegendPosition(Charts.Position.RIGHT);\n "
      },
      "setLegendTextStyle": {
        "!type": "fn(textStyle: Charts.TextStyle) -> SpreadsheetApp.EmbeddedPieChartBuilder",
        "!doc": "Sets the text style of the chart legend.\n\n \n \n // Creates a line chart builder and sets it up for a  blue, 26-point legend.\n var textStyleBuilder = Charts.newTextStyle().setColor(&#39;#0000FF&#39;).setFontSize(26);\n var style = textStyleBuilder.build();\n var builder = Charts.newLineChart();\n builder.setLegendTextStyle(style);\n "
      },
      "setOption": {
        "!type": "fn(option: string, value: object) -> SpreadsheetApp.EmbeddedChartBuilder",
        "!doc": "Sets advanced options for this chart. See\n \n https://developers.google.com/chart/interactive/docs/reference for what\n options are available.\n\n This method will NOT validate the option you specify is valid for this\n chart type nor if the value is of the correct format/structure.\n\n This example shows how to change the animation duration to 1 second and\n set a legend.\n\n \n \n builder.setOption(&#39;title&#39;, &#39;Earnings projections&#39;);\n builder.setOption(&#39;animation.duration&#39;, 1000);\n builder.setOption(&#39;legend&#39;, {position: &#39;top&#39;, textStyle: {color: &#39;blue&#39;, fontSize: 16}});\n "
      },
      "setPosition": {
        "!type": "fn(anchorRowPos: number, anchorColPos: number, offsetX: number, offsetY: number) -> SpreadsheetApp.EmbeddedChartBuilder",
        "!doc": "Sets the position, changing where the chart appears on the sheet. AnchorRowPos and AnchorColPos\n are 1-indexed.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var range = sheet.getRange(&quot;A1:B5&quot;);\n var chart = sheet.newChart()\n     .setChartType(Charts.ChartType.BAR)\n     .addRange(range)\n     .setPosition(5, 5, 0, 0)\n     .build()\n\n sheet.insertChart(chart);\n "
      },
      "setTitle": {
        "!type": "fn(chartTitle: string) -> SpreadsheetApp.EmbeddedPieChartBuilder",
        "!doc": "Sets the title of the chart.  The title will be displayed centered above the chart.\n\n \n \n // Creates a line chart builder and title to &#39;My Line Chart&#39;.\n var builder = Charts.newLineChart();\n builder.setTitle(&#39;My Line Chart&#39;)\n "
      },
      "setTitleTextStyle": {
        "!type": "fn(textStyle: Charts.TextStyle) -> SpreadsheetApp.EmbeddedPieChartBuilder",
        "!doc": "Sets the text style of the chart title.\n\n \n \n // Creates a line chart builder and sets it up for a  blue, 26-point title.\n var textStyleBuilder = Charts.newTextStyle().setColor(&#39;#0000FF&#39;).setFontSize(26);\n var style = textStyleBuilder.build();\n var builder = Charts.newLineChart();\n builder.setTitleTextStyle(style);\n "
      }
    },
    "SpreadsheetApp.EmbeddedScatterChartBuilder": {
      "addRange": {
        "!type": "fn(range: SpreadsheetApp.Range) -> SpreadsheetApp.EmbeddedChartBuilder",
        "!doc": "Adds a Range to the chart represented by this builder. Will not add the Range\n if it has already been added to the chart.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var chart = sheet.newChart()\n     .setChartType(Charts.ChartType.BAR)\n     .addRange(sheet.getRange(&quot;A1:B8&quot;))\n     .setPosition(5, 5, 0, 0)\n     .build();\n\n sheet.insertChart(chart);\n "
      },
      "asAreaChart": {
        "!type": "fn() -> SpreadsheetApp.EmbeddedAreaChartBuilder",
        "!doc": "Sets the chart type to AreaChart and returns an EmbeddedAreaChartBuilder."
      },
      "asBarChart": {
        "!type": "fn() -> SpreadsheetApp.EmbeddedBarChartBuilder",
        "!doc": "Sets the chart type to BarChart and returns an EmbeddedBarChartBuilder."
      },
      "asColumnChart": {
        "!type": "fn() -> SpreadsheetApp.EmbeddedColumnChartBuilder",
        "!doc": "Sets the chart type to ColumnChart and returns an EmbeddedColumnChartBuilder."
      },
      "asLineChart": {
        "!type": "fn() -> SpreadsheetApp.EmbeddedLineChartBuilder",
        "!doc": "Sets the chart type to LineChart and returns an EmbeddedLineChartBuilder."
      },
      "asPieChart": {
        "!type": "fn() -> SpreadsheetApp.EmbeddedPieChartBuilder",
        "!doc": "Sets the chart type to PieChart and returns an EmbeddedPieChartBuilder."
      },
      "asScatterChart": {
        "!type": "fn() -> SpreadsheetApp.EmbeddedScatterChartBuilder",
        "!doc": "Sets the chart type to ScatterChart and returns an EmbeddedScatterChartBuilder."
      },
      "asTableChart": {
        "!type": "fn() -> SpreadsheetApp.EmbeddedTableChartBuilder",
        "!doc": "Sets the chart type to TableChart and returns an EmbeddedTableChartBuilder."
      },
      "build": {
        "!type": "fn() -> SpreadsheetApp.EmbeddedChart",
        "!doc": "Builds the chart to reflect all changes made to it.\n\n This method will not automatically draw the chart on top of the spreadsheet. A new chart\n must be inserted via sheet.insertChart(chart), and an existing chart should be updated via\n sheet.update(chart);\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var range = sheet.getRange(&quot;A1:B5&quot;);\n var chart = sheet.newChart()\n     .setChartType(Charts.ChartType.BAR)\n     .addRange(range)\n     .setPosition(5, 5, 0, 0)\n     .build()\n\n sheet.insertChart(chart);\n "
      },
      "getChartType": {
        "!type": "fn() -> Charts.ChartType",
        "!doc": "Returns the current chart type."
      },
      "getContainer": {
        "!type": "fn() -> SpreadsheetApp.ContainerInfo",
        "!doc": "Return the ContainerInfo, which encapsulates where the chart appears on the sheet.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var chartBuilder = sheet.newChart()\n     .setChartType(Charts.ChartType.BAR)\n     .addRange(sheet.getRange(&quot;A1:B8&quot;))\n     .setPosition(5, 5, 0, 0);\n\n // This method returns the exact same data as Chart#getContainerInfo()\n var containerInfo = chartBuilder.getContainer();\n\n // Logs the values we used in setPosition()\n Logger.log(&quot;Anchor Column: %s\\r\\nAnchor Row %s\\r\\nOffset X %s\\r\\nOffset Y %s&quot;,\n           containerInfo.getAnchorColumn(),\n           containerInfo.getAnchorRow(),\n           containerInfo.getOffsetX(),\n           containerInfo.getOffsetY());\n "
      },
      "getRanges": {
        "!type": "fn() -> [SpreadsheetApp.Range]",
        "!doc": "Returns a copy of the list of ranges currently providing data for this chart. Use addRange and\n removeRange to modify this list.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var chartBuilder = sheet.newChart()\n     .setChartType(Charts.ChartType.BAR)\n     .addRange(sheet.getRange(&quot;A1:B8&quot;))\n     .setPosition(5, 5, 0, 0)\n\n var ranges = chartBuilder.getRanges();\n\n // There&#39;s only one range as a data source for this chart,\n // so this logs &quot;A1:B8&quot;\n for (var i in ranges) {\n   var range = ranges[i];\n   Logger.log(range.getA1Notation());\n }\n "
      },
      "removeRange": {
        "!type": "fn(range: SpreadsheetApp.Range) -> SpreadsheetApp.EmbeddedChartBuilder",
        "!doc": "Removes the specified Range from the chart represented by this builder. Will not throw an error\n if the Range is not in this chart.\n\n The range removed must match up with a range added via addRange(range), or it will\n not be removed, and it will not throw an exception. This method cannot be used to partially\n remove values from a range.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var firstRange = sheet.getRange(&quot;A1:B5&quot;);\n var secondRange = sheet.getRange(&quot;A6:B8&quot;);\n\n var chartBuilder = sheet.newChart()\n     .setChartType(Charts.ChartType.BAR)\n     .addRange(firstRange)\n     // This range will render in a different color\n     .addRange(secondRange)\n     .setPosition(5, 5, 0, 0);\n\n // Note that you can use either of these two formats, but the range\n // MUST match up with a range that was added via addRange(), or it\n // will not be removed, and will not throw an exception\n chartBuilder.removeRange(firstRange);\n chartBuilder.removeRange(sheet.getRange(&quot;A6:B8&quot;));\n\n var chart = chartBuilder.build();\n\n sheet.insertChart(chart);\n  "
      },
      "setBackgroundColor": {
        "!type": "fn(cssValue: string) -> SpreadsheetApp.EmbeddedScatterChartBuilder",
        "!doc": "Sets the background color for the chart.\n\n \n \n // Creates a line chart builder and sets the background color to gray\n var builder = Charts.newLineChart();\n builder.setBackgroundColor(&quot;gray&quot;);\n "
      },
      "setChartType": {
        "!type": "fn(type: Charts.ChartType) -> SpreadsheetApp.EmbeddedChartBuilder",
        "!doc": "Changes the type of chart. Not all embedded chart types are currently supported. See\n ChartType.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var range = sheet.getRange(&quot;A1:B5&quot;);\n var chart = sheet.newChart()\n     .setChartType(Charts.ChartType.BAR)\n     .addRange(range)\n     .setPosition(5, 5, 0, 0)\n     .build()\n\n sheet.insertChart(chart);\n "
      },
      "setColors": {
        "!type": "fn(cssValues: [string]) -> SpreadsheetApp.EmbeddedScatterChartBuilder",
        "!doc": "Sets the colors for the lines in the chart.\n\n \n \n // Creates a line chart builder and sets the first two lines to be drawn in green and red,\n // respectively.\n var builder = Charts.newLineChart();\n builder.setColors([&quot;green&quot;, &quot;red&quot;]);\n "
      },
      "setLegendPosition": {
        "!type": "fn(position: Charts.Position) -> SpreadsheetApp.EmbeddedScatterChartBuilder",
        "!doc": "Sets the position of the legend with respect to the chart.  By default, there will be no\n legend.\n\n \n \n // Creates a line chart builder and sets the legend position to right.\n var builder = Charts.newLineChart();\n builder.setLegendPosition(Charts.Position.RIGHT);\n "
      },
      "setLegendTextStyle": {
        "!type": "fn(textStyle: Charts.TextStyle) -> SpreadsheetApp.EmbeddedScatterChartBuilder",
        "!doc": "Sets the text style of the chart legend.\n\n \n \n // Creates a line chart builder and sets it up for a  blue, 26-point legend.\n var textStyleBuilder = Charts.newTextStyle().setColor(&#39;#0000FF&#39;).setFontSize(26);\n var style = textStyleBuilder.build();\n var builder = Charts.newLineChart();\n builder.setLegendTextStyle(style);\n "
      },
      "setOption": {
        "!type": "fn(option: string, value: object) -> SpreadsheetApp.EmbeddedChartBuilder",
        "!doc": "Sets advanced options for this chart. See\n \n https://developers.google.com/chart/interactive/docs/reference for what\n options are available.\n\n This method will NOT validate the option you specify is valid for this\n chart type nor if the value is of the correct format/structure.\n\n This example shows how to change the animation duration to 1 second and\n set a legend.\n\n \n \n builder.setOption(&#39;title&#39;, &#39;Earnings projections&#39;);\n builder.setOption(&#39;animation.duration&#39;, 1000);\n builder.setOption(&#39;legend&#39;, {position: &#39;top&#39;, textStyle: {color: &#39;blue&#39;, fontSize: 16}});\n "
      },
      "setPointStyle": {
        "!type": "fn(style: Charts.PointStyle) -> SpreadsheetApp.EmbeddedScatterChartBuilder",
        "!doc": "Sets the style for points in the line.  By default, points will have no particular styles,\n and only the line will be visible.\n\n \n \n // Creates a line chart builder and sets large point style.\n var builder = Charts.newLineChart();\n builder.setPointStyle(Charts.PointStyle.LARGE);\n "
      },
      "setPosition": {
        "!type": "fn(anchorRowPos: number, anchorColPos: number, offsetX: number, offsetY: number) -> SpreadsheetApp.EmbeddedChartBuilder",
        "!doc": "Sets the position, changing where the chart appears on the sheet. AnchorRowPos and AnchorColPos\n are 1-indexed.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var range = sheet.getRange(&quot;A1:B5&quot;);\n var chart = sheet.newChart()\n     .setChartType(Charts.ChartType.BAR)\n     .addRange(range)\n     .setPosition(5, 5, 0, 0)\n     .build()\n\n sheet.insertChart(chart);\n "
      },
      "setTitle": {
        "!type": "fn(chartTitle: string) -> SpreadsheetApp.EmbeddedScatterChartBuilder",
        "!doc": "Sets the title of the chart.  The title will be displayed centered above the chart.\n\n \n \n // Creates a line chart builder and title to &#39;My Line Chart&#39;.\n var builder = Charts.newLineChart();\n builder.setTitle(&#39;My Line Chart&#39;)\n "
      },
      "setTitleTextStyle": {
        "!type": "fn(textStyle: Charts.TextStyle) -> SpreadsheetApp.EmbeddedScatterChartBuilder",
        "!doc": "Sets the text style of the chart title.\n\n \n \n // Creates a line chart builder and sets it up for a  blue, 26-point title.\n var textStyleBuilder = Charts.newTextStyle().setColor(&#39;#0000FF&#39;).setFontSize(26);\n var style = textStyleBuilder.build();\n var builder = Charts.newLineChart();\n builder.setTitleTextStyle(style);\n "
      },
      "setXAxisLogScale": {
        "!type": "fn() -> SpreadsheetApp.EmbeddedScatterChartBuilder",
        "!doc": "Makes the horizontal axis into a logarithmic scale (requires all values to be positive)."
      },
      "setXAxisRange": {
        "!type": "fn(start: number, end: number) -> SpreadsheetApp.EmbeddedScatterChartBuilder",
        "!doc": "Sets the range for the horizontal axis of the chart.\n \n If any data points fall outside the range, the range will be expanded to include those data\n points.\n\n \n \n // Creates a scatter chart builder and sets the X-axis range to be 0 to 100.\n var builder = Charts.newTableChart();\n builder.setXAxisRange(0, 100);\n "
      },
      "setXAxisTextStyle": {
        "!type": "fn(textStyle: Charts.TextStyle) -> SpreadsheetApp.EmbeddedScatterChartBuilder",
        "!doc": "Sets the horizontal axis text style.\n\n \n \n // Creates a line chart builder and sets the X-axis text style to blue, 18-point font.\n var textStyle = Charts.newTextStyle().setColor(&#39;blue&#39;).setFontSize(18).build();\n var builder = Charts.newLineChart();\n builder.setXAxisTextStyle(textStyle);\n "
      },
      "setXAxisTitle": {
        "!type": "fn(title: string) -> SpreadsheetApp.EmbeddedScatterChartBuilder",
        "!doc": "Adds a title to the horizontal axis.  The title will be centered and will appear below\n the axis value labels.\n\n \n \n // Creates a line chart builder and sets the X-axis title.\n var builder = Charts.newLineChart();\n builder.setTitle(&#39;X-axis Title&#39;)\n "
      },
      "setXAxisTitleTextStyle": {
        "!type": "fn(textStyle: Charts.TextStyle) -> SpreadsheetApp.EmbeddedScatterChartBuilder",
        "!doc": "Sets the horizontal axis title text style.\n\n \n \n // Creates a line chart builder and sets the X-axis title text style to blue, 18-point font.\n var textStyle = Charts.newTextStyle().setColor(&#39;blue&#39;).setFontSize(18).build();\n var builder = Charts.newLineChart();\n builder.setXAxisTitleTextStyle(textStyle);\n "
      },
      "setYAxisLogScale": {
        "!type": "fn() -> SpreadsheetApp.EmbeddedScatterChartBuilder",
        "!doc": "Makes the vertical axis into a logarithmic scale (requires all values to be positive)."
      },
      "setYAxisRange": {
        "!type": "fn(start: number, end: number) -> SpreadsheetApp.EmbeddedScatterChartBuilder",
        "!doc": "Sets the range for the vertical axis of the chart. If any data points fall outside the range,\n the range will be expanded to include those data points.\n\n \n \n // Creates a scatter chart builder and sets the Y-axis range to be 0 to 100.\n var builder = Charts.newTableChart();\n builder.setYAxisRange(0, 100);\n "
      },
      "setYAxisTextStyle": {
        "!type": "fn(textStyle: Charts.TextStyle) -> SpreadsheetApp.EmbeddedScatterChartBuilder",
        "!doc": "Sets the vertical axis text style.\n\n \n \n // Creates a line chart builder and sets the Y-axis text style to blue, 18-point font.\n var textStyle = Charts.newTextStyle().setColor(&#39;blue&#39;).setFontSize(18).build();\n var builder = Charts.newLineChart();\n builder.setYAxisTextStyle(textStyle);\n "
      },
      "setYAxisTitle": {
        "!type": "fn(title: string) -> SpreadsheetApp.EmbeddedScatterChartBuilder",
        "!doc": "Adds a title to the vertical axis.  The title will be centered and will appear to the\n left of the value labels.\n\n \n \n // Creates a line chart builder and sets the Y-axis title.\n var builder = Charts.newLineChart();\n builder.setYAxisTitle(&#39;Y-axis Title&#39;)\n "
      },
      "setYAxisTitleTextStyle": {
        "!type": "fn(textStyle: Charts.TextStyle) -> SpreadsheetApp.EmbeddedScatterChartBuilder",
        "!doc": "Sets the vertical axis title text style.\n\n \n \n // Creates a line chart builder and sets the Y-axis title text style to blue, 18-point font.\n var textStyle = Charts.newTextStyle().setColor(&#39;blue&#39;).setFontSize(18).build();\n var builder = Charts.newLineChart();\n builder.setYAxisTitleTextStyle(textStyle);\n "
      }
    },
    "SpreadsheetApp.EmbeddedTableChartBuilder": {
      "addRange": {
        "!type": "fn(range: SpreadsheetApp.Range) -> SpreadsheetApp.EmbeddedChartBuilder",
        "!doc": "Adds a Range to the chart represented by this builder. Will not add the Range\n if it has already been added to the chart.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var chart = sheet.newChart()\n     .setChartType(Charts.ChartType.BAR)\n     .addRange(sheet.getRange(&quot;A1:B8&quot;))\n     .setPosition(5, 5, 0, 0)\n     .build();\n\n sheet.insertChart(chart);\n "
      },
      "asAreaChart": {
        "!type": "fn() -> SpreadsheetApp.EmbeddedAreaChartBuilder",
        "!doc": "Sets the chart type to AreaChart and returns an EmbeddedAreaChartBuilder."
      },
      "asBarChart": {
        "!type": "fn() -> SpreadsheetApp.EmbeddedBarChartBuilder",
        "!doc": "Sets the chart type to BarChart and returns an EmbeddedBarChartBuilder."
      },
      "asColumnChart": {
        "!type": "fn() -> SpreadsheetApp.EmbeddedColumnChartBuilder",
        "!doc": "Sets the chart type to ColumnChart and returns an EmbeddedColumnChartBuilder."
      },
      "asLineChart": {
        "!type": "fn() -> SpreadsheetApp.EmbeddedLineChartBuilder",
        "!doc": "Sets the chart type to LineChart and returns an EmbeddedLineChartBuilder."
      },
      "asPieChart": {
        "!type": "fn() -> SpreadsheetApp.EmbeddedPieChartBuilder",
        "!doc": "Sets the chart type to PieChart and returns an EmbeddedPieChartBuilder."
      },
      "asScatterChart": {
        "!type": "fn() -> SpreadsheetApp.EmbeddedScatterChartBuilder",
        "!doc": "Sets the chart type to ScatterChart and returns an EmbeddedScatterChartBuilder."
      },
      "asTableChart": {
        "!type": "fn() -> SpreadsheetApp.EmbeddedTableChartBuilder",
        "!doc": "Sets the chart type to TableChart and returns an EmbeddedTableChartBuilder."
      },
      "build": {
        "!type": "fn() -> SpreadsheetApp.EmbeddedChart",
        "!doc": "Builds the chart to reflect all changes made to it.\n\n This method will not automatically draw the chart on top of the spreadsheet. A new chart\n must be inserted via sheet.insertChart(chart), and an existing chart should be updated via\n sheet.update(chart);\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var range = sheet.getRange(&quot;A1:B5&quot;);\n var chart = sheet.newChart()\n     .setChartType(Charts.ChartType.BAR)\n     .addRange(range)\n     .setPosition(5, 5, 0, 0)\n     .build()\n\n sheet.insertChart(chart);\n "
      },
      "enablePaging": {
        "!type": "fn(enablePaging: bool) -> SpreadsheetApp.EmbeddedTableChartBuilder",
        "!doc": "Sets whether to enable paging through the data.\n \n The default behavior is paging disabled. If paging is enabled the default page size is 10."
      },
      "enablePaging ": {
        "!type": "fn(pageSize: number) -> SpreadsheetApp.EmbeddedTableChartBuilder",
        "!doc": "Enables paging and sets the number of rows in each page.\n \n The default page size is 10.\n\n \n \n // Creates a table chart builder and enables paging with page size of 5.\n var builder = Charts.newTableChart();\n builder.enablePaging(5);\n "
      },
      "enablePaging  ": {
        "!type": "fn(pageSize: number, startPage: number) -> SpreadsheetApp.EmbeddedTableChartBuilder",
        "!doc": "Enables paging, sets the number of rows in each page and the first table page to display\n (page numbers are zero based).\n \n The default page size is 10, and the default start page is 0.\n\n \n \n // Creates a table chart builder and enables paging with page size of 5 and displays page 2\n // first.\n var builder = Charts.newTableChart();\n builder.enablePaging(5, 2);\n "
      },
      "enableRtlTable": {
        "!type": "fn(rtlEnabled: bool) -> SpreadsheetApp.EmbeddedTableChartBuilder",
        "!doc": "Adds basic support for right-to-left languages (such as Arabic or Hebrew) by reversing\n the column order of the table, so that column zero is the right-most column, and the last\n column is the left-most column.\n \n This does not affect the column index in the underlying data, only the order of display.\n Full bi-directional (BiDi) language display is not supported by\n the table visualization even with this option. This option will be ignored if you enable\n paging (using the page option), or if the table has scroll bars because you have specified\n height and width options smaller than the required table size.\n The default behavior is RTL support disabled."
      },
      "enableSorting": {
        "!type": "fn(enableSorting: bool) -> SpreadsheetApp.EmbeddedTableChartBuilder",
        "!doc": "Sets whether to sort columns when the user clicks a column heading.\n \n If sorting is enabled, when users click on the column header the rows will be automatically\n sorted. The default behavior is sorting enabled."
      },
      "getChartType": {
        "!type": "fn() -> Charts.ChartType",
        "!doc": "Returns the current chart type."
      },
      "getContainer": {
        "!type": "fn() -> SpreadsheetApp.ContainerInfo",
        "!doc": "Return the ContainerInfo, which encapsulates where the chart appears on the sheet.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var chartBuilder = sheet.newChart()\n     .setChartType(Charts.ChartType.BAR)\n     .addRange(sheet.getRange(&quot;A1:B8&quot;))\n     .setPosition(5, 5, 0, 0);\n\n // This method returns the exact same data as Chart#getContainerInfo()\n var containerInfo = chartBuilder.getContainer();\n\n // Logs the values we used in setPosition()\n Logger.log(&quot;Anchor Column: %s\\r\\nAnchor Row %s\\r\\nOffset X %s\\r\\nOffset Y %s&quot;,\n           containerInfo.getAnchorColumn(),\n           containerInfo.getAnchorRow(),\n           containerInfo.getOffsetX(),\n           containerInfo.getOffsetY());\n "
      },
      "getRanges": {
        "!type": "fn() -> [SpreadsheetApp.Range]",
        "!doc": "Returns a copy of the list of ranges currently providing data for this chart. Use addRange and\n removeRange to modify this list.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var chartBuilder = sheet.newChart()\n     .setChartType(Charts.ChartType.BAR)\n     .addRange(sheet.getRange(&quot;A1:B8&quot;))\n     .setPosition(5, 5, 0, 0)\n\n var ranges = chartBuilder.getRanges();\n\n // There&#39;s only one range as a data source for this chart,\n // so this logs &quot;A1:B8&quot;\n for (var i in ranges) {\n   var range = ranges[i];\n   Logger.log(range.getA1Notation());\n }\n "
      },
      "removeRange": {
        "!type": "fn(range: SpreadsheetApp.Range) -> SpreadsheetApp.EmbeddedChartBuilder",
        "!doc": "Removes the specified Range from the chart represented by this builder. Will not throw an error\n if the Range is not in this chart.\n\n The range removed must match up with a range added via addRange(range), or it will\n not be removed, and it will not throw an exception. This method cannot be used to partially\n remove values from a range.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var firstRange = sheet.getRange(&quot;A1:B5&quot;);\n var secondRange = sheet.getRange(&quot;A6:B8&quot;);\n\n var chartBuilder = sheet.newChart()\n     .setChartType(Charts.ChartType.BAR)\n     .addRange(firstRange)\n     // This range will render in a different color\n     .addRange(secondRange)\n     .setPosition(5, 5, 0, 0);\n\n // Note that you can use either of these two formats, but the range\n // MUST match up with a range that was added via addRange(), or it\n // will not be removed, and will not throw an exception\n chartBuilder.removeRange(firstRange);\n chartBuilder.removeRange(sheet.getRange(&quot;A6:B8&quot;));\n\n var chart = chartBuilder.build();\n\n sheet.insertChart(chart);\n  "
      },
      "setChartType": {
        "!type": "fn(type: Charts.ChartType) -> SpreadsheetApp.EmbeddedChartBuilder",
        "!doc": "Changes the type of chart. Not all embedded chart types are currently supported. See\n ChartType.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var range = sheet.getRange(&quot;A1:B5&quot;);\n var chart = sheet.newChart()\n     .setChartType(Charts.ChartType.BAR)\n     .addRange(range)\n     .setPosition(5, 5, 0, 0)\n     .build()\n\n sheet.insertChart(chart);\n "
      },
      "setFirstRowNumber": {
        "!type": "fn(number: number) -> SpreadsheetApp.EmbeddedTableChartBuilder",
        "!doc": "Sets the row number for the first row in the data table.\n \n The default row number of the first row is 1.\n\n \n \n // Creates a table chart builder and sets the first row to be 2.\n var builder = Charts.newTableChart();\n builder.setFirstRowNumber(2);\n "
      },
      "setInitialSortingAscending": {
        "!type": "fn(column: number) -> SpreadsheetApp.EmbeddedTableChartBuilder",
        "!doc": "Sets the index of the column according to which the table should be initially sorted\n (ascending).\n \n The column will be sorted in ascending order and will be marked with a small arrow\n indicating that.\n\n \n \n // Creates a table chart builder and sorts it by the second column (ascending).\n var builder = Charts.newTableChart();\n builder.setInitialSortingAscending(2);\n "
      },
      "setInitialSortingDescending": {
        "!type": "fn(column: number) -> SpreadsheetApp.EmbeddedTableChartBuilder",
        "!doc": "Sets the index of the column according to which the table should be initially sorted\n (descending).\n \n The column will be sorted in descending order and be marked with a a small arrow\n indicating that.\n\n \n \n // Creates a table chart builder and sorts it by the second column (descending).\n var builder = Charts.newTableChart();\n builder.setInitialSortingDescending(2);\n "
      },
      "setOption": {
        "!type": "fn(option: string, value: object) -> SpreadsheetApp.EmbeddedChartBuilder",
        "!doc": "Sets advanced options for this chart. See\n \n https://developers.google.com/chart/interactive/docs/reference for what\n options are available.\n\n This method will NOT validate the option you specify is valid for this\n chart type nor if the value is of the correct format/structure.\n\n This example shows how to change the animation duration to 1 second and\n set a legend.\n\n \n \n builder.setOption(&#39;title&#39;, &#39;Earnings projections&#39;);\n builder.setOption(&#39;animation.duration&#39;, 1000);\n builder.setOption(&#39;legend&#39;, {position: &#39;top&#39;, textStyle: {color: &#39;blue&#39;, fontSize: 16}});\n "
      },
      "setPosition": {
        "!type": "fn(anchorRowPos: number, anchorColPos: number, offsetX: number, offsetY: number) -> SpreadsheetApp.EmbeddedChartBuilder",
        "!doc": "Sets the position, changing where the chart appears on the sheet. AnchorRowPos and AnchorColPos\n are 1-indexed.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var range = sheet.getRange(&quot;A1:B5&quot;);\n var chart = sheet.newChart()\n     .setChartType(Charts.ChartType.BAR)\n     .addRange(range)\n     .setPosition(5, 5, 0, 0)\n     .build()\n\n sheet.insertChart(chart);\n "
      },
      "showRowNumberColumn": {
        "!type": "fn(showRowNumber: bool) -> SpreadsheetApp.EmbeddedTableChartBuilder",
        "!doc": "Sets whether to show the row number as the first column of the table.\n \n The default behavior is not showing row numbers."
      },
      "useAlternatingRowStyle": {
        "!type": "fn(alternate: bool) -> SpreadsheetApp.EmbeddedTableChartBuilder",
        "!doc": "Sets whether alternating color style will be assigned to odd and even rows of a table\n chart.\n \n The default behavior is the rows having alternating color style."
      }
    },
    "SpreadsheetApp.PageProtection": {
      "addUser": {
        "!type": "fn(email: string)",
        "!doc": "Adds a user to the list of users who can edit the sheet, if it is protected.\n\n \n \n // Add the &quot;user@example.com&quot; user to the list of users who can edit this sheet\n var sheet = SpreadsheetApp.getActiveSheet();\n var permissions = sheet.getSheetProtection();\n permissions.addUser(&#39;user@example.com&#39;);\n permissions.setProtected(true);\n sheet.setSheetProtection(permissions);\n "
      },
      "getUsers": {
        "!type": "fn() -> [string]",
        "!doc": "Returns a list of the email addresses of the users who can edit this sheet.\n\n If sheet protection is disabled, the value returned by this call is meaningless."
      },
      "isProtected": {
        "!type": "fn() -> bool",
        "!doc": "Indicates whether the sheet has sheet protection enabled or not.\n\n \n \n // Determine whether or not sheet protection is enabled\n var sheet = SpreadsheetApp.getActiveSheet();\n var permissions = sheet.getSheetProtection();\n var isProtected = permissions.isProtected();\n "
      },
      "removeUser": {
        "!type": "fn(user: string)",
        "!doc": "Removes a user from the list of users who can edit the sheet.\n\n \n \n // Remove the &quot;user@example.com&quot; user to the list of users who can edit this sheet\n var sheet = SpreadsheetApp.getActiveSheet();\n var permissions = sheet.getSheetProtection();\n permissions.removeUser(&#39;user@example.com&#39;);\n permissions.setProtected(true);\n sheet.setSheetProtection(permissions);\n "
      },
      "setProtected": {
        "!type": "fn(protection: bool)",
        "!doc": "Sets the protection status for the sheet.\n\n \n \n // Enables sheet protection for  this sheet\n var sheet = SpreadsheetApp.getActiveSheet();\n var permissions = sheet.getSheetProtection();\n permissions.setProtected(true);\n sheet.setSheetProtection(permissions);\n "
      }
    },
    "SpreadsheetApp.Protection": {
      "addEditor": {
        "!type": "fn(emailAddress: string) -> SpreadsheetApp.Protection",
        "!doc": "Adds the given user to the list of editors for the protected sheet or range. This method does\n not automatically give the user permission to edit the spreadsheet itself; to do that in\n addition, call Spreadsheet.addEditor(emailAddress)."
      },
      "addEditor ": {
        "!type": "fn(user: User) -> SpreadsheetApp.Protection",
        "!doc": "Adds the given user to the list of editors for the protected sheet or range. This method does\n not automatically give the user permission to edit the spreadsheet itself; to do that in\n addition, call Spreadsheet.addEditor(user)."
      },
      "addEditors": {
        "!type": "fn(emailAddresses: [string]) -> SpreadsheetApp.Protection",
        "!doc": "Adds the given array of users to the list of editors for the protected sheet or range. This\n method does not automatically give the users permission to edit the spreadsheet itself; to do\n that in addition, call Spreadsheet.addEditors(emailAddresses)."
      },
      "canDomainEdit": {
        "!type": "fn() -> bool",
        "!doc": "Determines whether all users in the domain that owns the spreadsheet have permission to edit\n the protected range or sheet. Throws an exception if the user does not have permission to edit\n the protected range or sheet."
      },
      "canEdit": {
        "!type": "fn() -> bool",
        "!doc": "Determines whether the user has permission to edit the protected range or sheet. The\n spreadsheet owner is always able to edit protected ranges and sheets.\n\n \n \n // Remove all range protections in the spreadsheet that the user has permission to edit.\n var ss = SpreadsheetApp.getActive();\n var protections = ss.getProtections(SpreadsheetApp.ProtectionType.RANGE);\n for (var i = 0; i &lt; protections.length; i++) {\n   var protection = protections[i];\n   if (protection.canEdit()) {\n     protection.remove();\n   }\n }\n "
      },
      "getDescription": {
        "!type": "fn() -> string",
        "!doc": "Gets the description of the protected range or sheet. If no description is set, this method\n returns an empty string."
      },
      "getEditors": {
        "!type": "fn() -> [User]",
        "!doc": "Gets the list of editors for the protected range or sheet. Throws an exception if the user does\n not have permission to edit the protected range or sheet.\n\n \n \n // Protect the active sheet, then remove all other users from the list of editors.\n var sheet = SpreadsheetApp.getActiveSheet();\n var protection = sheet.protect().setDescription(&#39;Sample protected sheet&#39;);\n\n // Ensure the current user is an editor before removing others. Otherwise, if the user&#39;s edit\n // permission comes from a group, the script will throw an exception upon removing the group.\n var me = Session.getEffectiveUser();\n protection.addEditor(me);\n protection.removeEditors(protection.getEditors());\n if (protection.canDomainEdit()) {\n   protection.setDomainEdit(false);\n }\n "
      },
      "getProtectionType": {
        "!type": "fn() -> SpreadsheetApp.ProtectionType",
        "!doc": "Gets the type of the protected area, either SpreadsheetApp.ProtectionType.RANGE or\n SpreadsheetApp.ProtectionType.SHEET."
      },
      "getRange": {
        "!type": "fn() -> SpreadsheetApp.Range",
        "!doc": "Gets the range that is being protected. If the protection applies to the sheet instead of a\n range, this method returns a range that spans the entire sheet."
      },
      "getRangeName": {
        "!type": "fn() -> string",
        "!doc": "Gets the name of the protected range if it is associated with a named range. Returns\n null if the protection is not associated with a named range. Note that scripts must\n explicitly call setRangeName(rangeName) to associate a protected range with a named\n range; calling Range.protect() to create a protection from a Range that\n happens to be a named range, without calling setRangeName(rangeName), is not sufficient\n to associate them. However, creating a protected range from a named range in the Google Sheets\n UI will associate them automatically.\n\n \n \n // Protect a named range in a spreadsheet and log the name of the protected range.\n var ss = SpreadsheetApp.getActive();\n var range = ss.getRange(&#39;A1:B10&#39;);\n var protection = range.protect();\n ss.setNamedRange(&#39;Test&#39;, range);       // Create a named range.\n protection.setRangeName(&#39;Test&#39;);       // Associate the protection with the named range.\n Logger.log(protection.getRangeName()); // Verify the name of the protected range.\n "
      },
      "getUnprotectedRanges": {
        "!type": "fn() -> [SpreadsheetApp.Range]",
        "!doc": "Gets an array of unprotected ranges within a protected sheet. If the Protection object\n corresponds to a protected range instead of a protected sheet, this method returns an empty\n array.  To change the unprotected ranges, use setUnprotectedRanges(ranges) to set\n a new array of ranges; to re-protect the entire sheet, set an empty array.\n\n \n \n // Unprotect cells E2:F5 in addition to any other unprotected ranges in the protected sheet.\n var sheet = SpreadsheetApp.getActiveSheet();\n var protection = sheet.protect();\n var unprotected = protection.getUnprotectedRanges();\n unprotected.push(sheet.getRange(&#39;E2:F5&#39;));\n protection.setUnprotectedRanges(unprotected);\n "
      },
      "isWarningOnly": {
        "!type": "fn() -> bool",
        "!doc": "Determines if the protected area is using \"warning based\" protection. Warning-based protection\n means that every user can edit data in the area, except editing will prompt a warning asking\n the user to confirm the edit. By default, protected ranges or sheets are not warning-based.\n To change to the warning state, use setWarningOnly(warningOnly)."
      },
      "remove": {
        "!type": "fn()",
        "!doc": "Unprotects the range or sheet.\n\n \n \n // Remove all range protections in the spreadsheet that the user has permission to edit.\n var ss = SpreadsheetApp.getActive();\n var protections = ss.getProtections(SpreadsheetApp.ProtectionType.RANGE);\n for (var i = 0; i &lt; protections.length; i++) {\n   var protection = protections[i];\n   if (protection.canEdit()) {\n     protection.remove();\n   }\n }\n \n\n \n \n // Remove sheet protection from the active sheet, if the user has permission to edit it.\n var sheet = SpreadsheetApp.getActiveSheet();\n var protection = sheet.getProtections(SpreadsheetApp.ProtectionType.SHEET)[0];\n if (protection &amp;&amp; protection.canEdit()) {\n   protection.remove();\n }\n "
      },
      "removeEditor": {
        "!type": "fn(emailAddress: string) -> SpreadsheetApp.Protection",
        "!doc": "Removes the given user from the list of editors for the protected sheet or range. Note that if\n the user is a member of a Google Group that has edit permission, or if all users in the domain\n have edit permission, the user will still be able to edit the protected area. Neither the\n owner of the spreadsheet nor the current user can be removed."
      },
      "removeEditor ": {
        "!type": "fn(user: User) -> SpreadsheetApp.Protection",
        "!doc": "Removes the given user from the list of editors for the protected sheet or range. Note that if\n the user is a member of a Google Group that has edit permission, or if all users in the domain\n have edit permission, the user will still be able to edit the protected area as well. Neither\n the owner of the spreadsheet nor the current user can be removed."
      },
      "removeEditors": {
        "!type": "fn(emailAddresses: [string]) -> SpreadsheetApp.Protection",
        "!doc": "Removes the given array of users from the list of editors for the protected sheet or range.\n Note that if any of the users are members of a Google Group that has edit permission, or if all\n users in the domain have edit permission, those users will still be able to edit the protected\n area. Neither the owner of the spreadsheet nor the current user can be removed.\n\n \n \n // Protect the active sheet, then remove all other users from the list of editors.\n var sheet = SpreadsheetApp.getActiveSheet();\n var protection = sheet.protect().setDescription(&#39;Sample protected sheet&#39;);\n\n // Ensure the current user is an editor before removing others. Otherwise, if the user&#39;s edit\n // permission comes from a group, the script will throw an exception upon removing the group.\n var me = Session.getEffectiveUser();\n protection.addEditor(me);\n protection.removeEditors(protection.getEditors());\n if (protection.canDomainEdit()) {\n   protection.setDomainEdit(false);\n }\n "
      },
      "setDescription": {
        "!type": "fn(description: string) -> SpreadsheetApp.Protection",
        "!doc": "Sets the description of the protected range or sheet."
      },
      "setDomainEdit": {
        "!type": "fn(editable: bool) -> SpreadsheetApp.Protection",
        "!doc": "Sets whether all users in the domain that owns the spreadsheet have permission to edit the\n protected range or sheet. Note that any users who have explicit edit permission will be able to\n edit the protected area regardless of this setting. Throws an exception if the spreadsheet does\n not belong to a Google Apps domain (that is, if it is owned by a gmail.com account)."
      },
      "setRange": {
        "!type": "fn(range: SpreadsheetApp.Range) -> SpreadsheetApp.Protection",
        "!doc": "Adjusts the range that is being protected. If the given range covers a different area from the\n current protected range, this method moves the protection to cover the new range instead."
      },
      "setRangeName": {
        "!type": "fn(rangeName: string) -> SpreadsheetApp.Protection",
        "!doc": "Associates the protected range with an existing named range. If the named range covers a\n different area from the current protected range, this method moves the protection to cover the\n the named range instead. The named range must be on the same sheet as the current protected\n range. Note that scripts must explicitly call this method to associate a protected range with a\n named range; calling Range.protect() to create a protection from a Range\n that happens to be a named range, without calling setRangeName(rangeName), is not\n sufficient to associate them. However, creating a protected range from a named range in the\n Google Sheets UI will associate them automatically.\n\n \n \n // Protect a named range in a spreadsheet and log the name of the protected range.\n var ss = SpreadsheetApp.getActive();\n var range = ss.getRange(&#39;A1:B10&#39;);\n var protection = range.protect();\n ss.setNamedRange(&#39;Test&#39;, range);       // Create a named range.\n protection.setRangeName(&#39;Test&#39;);       // Associate the protection with the named range.\n Logger.log(protection.getRangeName()); // Verify the name of the protected range.\n "
      },
      "setUnprotectedRanges": {
        "!type": "fn(ranges: [SpreadsheetApp.Range]) -> SpreadsheetApp.Protection",
        "!doc": "Unprotects the given array of ranges within a protected sheet. Throws an exception if the\n Protection object corresponds to a protected range instead of a protected sheet or if\n any of the ranges are not on the protected sheet. To change the unprotected ranges, set a new\n array of ranges; to re-protect the entire sheet, set an empty array.\n\n \n \n // Protect the active sheet except B2:C5, then remove all other users from the list of editors.\n var sheet = SpreadsheetApp.getActiveSheet();\n var protection = sheet.protect().setDescription(&#39;Sample protected sheet&#39;);\n var unprotected = sheet.getRange(&#39;B2:C5&#39;);\n protection.setUnprotectedRanges([unprotected]);\n\n // Ensure the current user is an editor before removing others. Otherwise, if the user&#39;s edit\n // permission comes from a group, the script will throw an exception upon removing the group.\n var me = Session.getEffectiveUser();\n protection.addEditor(me);\n protection.removeEditors(protection.getEditors());\n if (protection.canDomainEdit()) {\n   protection.setDomainEdit(false);\n }\n "
      },
      "setWarningOnly": {
        "!type": "fn(warningOnly: bool) -> SpreadsheetApp.Protection",
        "!doc": "Sets whether or not this protected range is using \"warning based\" protection.\n Warning-based protection means that every user can edit data in the area, except editing\n will prompt a warning asking the user to confirm the edit. By default, protected ranges\n or sheets are not warning-based. To check warning state, use isWarningOnly()."
      }
    },
    "SpreadsheetApp.ProtectionType": {
      "RANGE": {
        "!type": "SpreadsheetApp.ProtectionType",
        "!doc": "Protection for a range."
      },
      "SHEET": {
        "!type": "SpreadsheetApp.ProtectionType",
        "!doc": "Protection for a sheet."
      }
    },
    "SpreadsheetApp.Range": {
      "activate": {
        "!type": "fn() -> SpreadsheetApp.Range",
        "!doc": "Make this range the active range.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var range = sheet.getRange(&quot;A1:D10&quot;);\n range.activate();\n "
      },
      "breakApart": {
        "!type": "fn() -> SpreadsheetApp.Range",
        "!doc": "Break any multi-column cells in the range into individual cells again.\n\n Calling this function on a range is equivalent to selecting a range and clicking\n Format -> Merge -> Unmerge."
      },
      "canEdit": {
        "!type": "fn() -> bool",
        "!doc": "Determines whether the user has permission to edit every cell in the range. The spreadsheet\n owner is always able to edit protected ranges and sheets."
      },
      "clear": {
        "!type": "fn() -> SpreadsheetApp.Range",
        "!doc": "Clears the range of contents, formats, and data-validation rules.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var range = sheet.getRange(&quot;A1:D10&quot;);\n range.clear();\n "
      },
      "clear ": {
        "!type": "fn(options: object) -> SpreadsheetApp.Range",
        "!doc": "Clears the range of contents, format, data-validation rules, and/or comments, as specified with\n the given advanced options. By default all data will be cleared.\n\n \n \n // The code below will clear range C2:G8 in the active sheet, but preserve the format,\n // data-validation rules, and comments.\n SpreadsheetApp.getActiveSheet().getRange(2, 3, 6, 4).clear({contentsOnly: true});\n "
      },
      "clearContent": {
        "!type": "fn() -> SpreadsheetApp.Range",
        "!doc": "Clears the content of the range, leaving the formatting intact.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var range = sheet.getRange(&quot;A1:D10&quot;);\n range.clearContent();\n "
      },
      "clearDataValidations": {
        "!type": "fn() -> SpreadsheetApp.Range",
        "!doc": "Clears the data-validation rules for the range.\n\n \n // Clear the data-validation rules for cells A1:B5.\n var range = SpreadsheetApp.getActive().getRange('A1:B5');\n range.clearDataValidations();\n "
      },
      "clearFormat": {
        "!type": "fn() -> SpreadsheetApp.Range",
        "!doc": "Clears formatting for this range.\n\n This clears text formatting for the cell or cells in the range, but does not reset\n any number formatting rules.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var range = sheet.getRange(&quot;A1:D10&quot;);\n range.clearFormat();\n "
      },
      "clearNote": {
        "!type": "fn() -> SpreadsheetApp.Range",
        "!doc": "Clears the note in the given cell or cells.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var range = sheet.getRange(&quot;A1:D10&quot;);\n range.clearNote();\n "
      },
      "copyFormatToRange": {
        "!type": "fn(gridId: number, column: number, columnEnd: number, row: number, rowEnd: number)",
        "!doc": "Copy the formatting of the range to the given location. If the destination is larger or\n smaller than the source range then the source will be repeated or truncated accordingly. Note\n that this method copies the formatting only.\n\n For a detailed description of the gridId parameter, see getGridId().\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var source = ss.getSheets()[0];\n\n var range = source.getRange(&quot;B2:D4&quot;);\n\n // This copies the formatting in B2:D4 in the source sheet to\n // D4:F6 in the sheet with gridId 1555299895. Note that you can get the gridId\n // of a sheet by calling sheet.getSheetId() or range.getGridId().\n range.copyFormatToRange(1555299895, 4, 6, 4, 6);\n "
      },
      "copyFormatToRange ": {
        "!type": "fn(sheet: SpreadsheetApp.Sheet, column: number, columnEnd: number, row: number, rowEnd: number)",
        "!doc": "Copy the formatting of the range to the given location. If the destination is larger or\n smaller than the source range then the source will be repeated or truncated accordingly. Note\n that this method copies the formatting only.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var source = ss.getSheets()[0];\n var destination = ss.getSheets()[1];\n\n var range = source.getRange(&quot;B2:D4&quot;);\n\n // This copies the formatting in B2:D4 in the source sheet to\n // D4:F6 in the second sheet\n range.copyFormatToRange(destination, 4, 6, 4, 6);\n "
      },
      "copyTo": {
        "!type": "fn(destination: SpreadsheetApp.Range)",
        "!doc": "Copies the data from a range of cells to another range of cells. Both the values and formatting\n are copied.\n\n \n // The code below will copy the first 5 columns over to the 6th column.\n var sheet = SpreadsheetApp.getActiveSheet();\n var rangeToCopy = sheet.getRange(1, 1, sheet.getMaxRows(), 5);\n rangeToCopy.copyTo(sheet.getRange(1, 6));\n }"
      },
      "copyTo ": {
        "!type": "fn(destination: SpreadsheetApp.Range, options: object)",
        "!doc": "Copies the data from a range of cells to another range of cells. By default both the values\n and formatting are copied, but this can be overridden using advanced arguments.\n\n \n // The code below will copy only the values of the first 5 columns over to the 6th column.\n var sheet = SpreadsheetApp.getActiveSheet();\n sheet.getRange(\"A:E\").copyTo(sheet.getRange(\"F1\"), {contentsOnly:true});\n }"
      },
      "copyValuesToRange": {
        "!type": "fn(gridId: number, column: number, columnEnd: number, row: number, rowEnd: number)",
        "!doc": "Copy the content of the range to the given location. If the destination is larger or\n smaller than the source range then the source will be repeated or truncated accordingly.\n\n For a detailed description of the gridId parameter, see getGridId().\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var source = ss.getSheets()[0];\n\n var range = source.getRange(&quot;B2:D4&quot;);\n\n // This copies the data in B2:D4 in the source sheet to\n // D4:F6 in the sheet with gridId 0\n range.copyValuesToRange(0, 4, 6, 4, 6);\n "
      },
      "copyValuesToRange ": {
        "!type": "fn(sheet: SpreadsheetApp.Sheet, column: number, columnEnd: number, row: number, rowEnd: number)",
        "!doc": "Copy the content of the range to the given location. If the destination is larger or\n smaller than the source range then the source will be repeated or truncated accordingly.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var source = ss.getSheets()[0];\n var destination = ss.getSheets()[1];\n\n var range = source.getRange(&quot;B2:D4&quot;);\n\n // This copies the data in B2:D4 in the source sheet to\n // D4:F6 in the second sheet\n range.copyValuesToRange(destination, 4, 6, 4, 6);\n "
      },
      "getA1Notation": {
        "!type": "fn() -> string",
        "!doc": "Returns a string description of the range, in A1 notation.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n var range = sheet.getRange(1, 1, 2, 5);\n\n // Logs &quot;A1:E2&quot;\n Logger.log(range.getA1Notation());\n "
      },
      "getBackground": {
        "!type": "fn() -> string",
        "!doc": "Returns the background color of the top-left cell in the range (i.e., &#39;#ffffff&#39;).\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var cell = sheet.getRange(&quot;B5&quot;);\n Logger.log(cell.getBackground());\n "
      },
      "getBackgrounds": {
        "!type": "fn() -> [[string]]",
        "!doc": "Returns the background colors of the cells in the range (i.e., &#39;#ffffff&#39;).\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var range = sheet.getRange(&quot;B5:C6&quot;);\n var bgColors = range.getBackgrounds();\n for (var i in bgColors) {\n   for (var j in bgColors[i]) {\n     Logger.log(bgColors[i][j]);\n   }\n }\n "
      },
      "getCell": {
        "!type": "fn(row: number, column: number) -> SpreadsheetApp.Range",
        "!doc": "Returns a given cell within a range.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var range = sheet.getRange(&quot;B2:D4&quot;);\n\n // The row and column here are relative to the range\n // getCell(1,1) in this code returns the cell at B2, B2\n var cell = range.getCell(1, 1);\n Logger.log(cell.getValue());\n "
      },
      "getColumn": {
        "!type": "fn() -> number",
        "!doc": "Returns the starting column position for this range.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var range = sheet.getRange(&quot;B2:D4&quot;);\n // Logs &quot;2.0&quot;\n Logger.log(range.getColumn());\n "
      },
      "getDataSourceUrl": {
        "!type": "fn() -> string",
        "!doc": "Returns a URL for the data in this range, which can be used to create\n charts and queries.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n var range = sheet.getRange(&quot;A1:B7&quot;);\n\n var dataSourceUrl = range.getDataSourceUrl();\n\n // Note that this doesn&#39;t build an EmbeddedChart, so we can&#39;t just use\n // Sheet#insertChart(). If we want to do that, we should use\n // sheet.newChart().addRange() instead.\n var chart = Charts.newBarChart()\n     .setOption(&quot;title&quot;, &quot;Your Title Here&quot;)\n     .setDataSourceUrl(dataSourceUrl)\n     .build();\n\n var app = UiApp.createApplication();\n app.add(chart);\n ss.show(app);\n "
      },
      "getDataTable": {
        "!type": "fn() -> DataTable",
        "!doc": "Return the data inside this object as a DataTable."
      },
      "getDataTable ": {
        "!type": "fn(firstRowIsHeader: bool) -> DataTable",
        "!doc": "Return the data inside this Range as a DataTable.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n var range = sheet.getRange(&quot;A1:B7&quot;);\n\n // Calling this method with &quot;true&quot; sets the first line to be the title of the axes\n var datatable = range.getDataTable(true);\n\n // Note that this doesn&#39;t build an EmbeddedChart, so we can&#39;t just use\n // Sheet#insertChart(). If we want to do that, we should use\n // sheet.newChart().addRange() instead.\n var chart = Charts.newBarChart()\n     .setDataTable(datatable)\n     .setOption(&quot;title&quot;, &quot;Your Title Here&quot;)\n     .build();\n\n var app = UiApp.createApplication();\n app.add(chart);\n ss.show(app);\n "
      },
      "getDataValidation": {
        "!type": "fn() -> SpreadsheetApp.DataValidation",
        "!doc": "Returns the data-validation rule for the top-left cell in the range. If data validation has not\n been set on the cell, this method returns null.\n\n \n // Log information about the data-validation rule for cell A1.\n var cell = SpreadsheetApp.getActive().getRange('A1');\n var rule = cell.getDataValidation();\n if (rule != null) {\n   var criteria = rule.getCriteriaType();\n   var args = rule.getCriteriaValues();\n   Logger.log('The data-validation rule is %s %s', criteria, args);\n } else {\n   Logger.log('The cell does not have a data-validation rule.')\n }\n "
      },
      "getDataValidations": {
        "!type": "fn() -> [[SpreadsheetApp.DataValidation]]",
        "!doc": "Returns the data-validation rules for all cells in the range. If data validation has not been\n set on a given cell, this method returns null for that cell's position in the array.\n\n \n // Change existing data-validation rules that require a date in 2013 to require a date in 2014.\n var oldDates = [new Date(&#39;1/1/2013&#39;), new Date(&#39;12/31/2013&#39;)];\n var newDates = [new Date(&#39;1/1/2014&#39;), new Date(&#39;12/31/2014&#39;)];\n var sheet = SpreadsheetApp.getActiveSheet();\n var range = sheet.getRange(1, 1, sheet.getMaxRows(), sheet.getMaxColumns());\n var rules = range.getDataValidations();\n\n for (var i = 0; i &lt; rules.length; i++) {\n   for (var j = 0; j &lt; rules[i].length; j++) {\n     var rule = rules[i][j];\n\n     if (rule != null) {\n       var criteria = rule.getCriteriaType();\n       var args = rule.getCriteriaValues();\n\n       if (criteria == SpreadsheetApp.DataValidationCriteria.DATE_BETWEEN\n           &amp;&amp; args[0].getTime() == oldDates[0].getTime()\n           &amp;&amp; args[1].getTime() == oldDates[1].getTime()) {\n         // Create a builder from the existing rule, then change the dates.\n         rules[i][j] = rule.copy().withCriteria(criteria, newDates).build();\n       }\n     }\n   }\n }\n range.setDataValidations(rules);\n "
      },
      "getFontColor": {
        "!type": "fn() -> string",
        "!doc": "Returns the font color of the cell in the top-left corner of the range, in CSS notation\n (like &#39;#ffffff&#39; or &#39;white&#39;).\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n var range = sheet.getRange(&quot;B2:D4&quot;);\n\n Logger.log(range.getFontColor());\n "
      },
      "getFontColors": {
        "!type": "fn() -> [[string]]",
        "!doc": "Returns the font colors of the cells in the range in CSS notation (like &#39;#ffffff&#39; or\n &#39;white&#39;).\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n var range = sheet.getRange(&quot;B2:D4&quot;);\n\n var results = range.getFontColors();\n\n for (var i in results) {\n   for (var j in results[i]) {\n     Logger.log(results[i][j]);\n   }\n }\n "
      },
      "getFontFamilies": {
        "!type": "fn() -> [[string]]",
        "!doc": "Returns the font families of the cells in the range.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n var range = sheet.getRange(&quot;B2:D4&quot;);\n\n var results = range.getFontFamilies();\n\n for (var i in results) {\n   for (var j in results[i]) {\n     Logger.log(results[i][j]);\n   }\n }\n "
      },
      "getFontFamily": {
        "!type": "fn() -> string",
        "!doc": "Returns the font family of the cell in the top-left corner of the range.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n var range = sheet.getRange(&quot;B2:D4&quot;);\n\n Logger.log(range.getFontFamily());\n "
      },
      "getFontLine": {
        "!type": "fn() -> string",
        "!doc": "Gets the line style of the cell in the top-left corner of the range (&#39;underline&#39;,\n &#39;line-through&#39;, or &#39;none&#39;).\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n var range = sheet.getRange(&quot;B2:D4&quot;);\n\n Logger.log(range.getFontLine());\n "
      },
      "getFontLines": {
        "!type": "fn() -> [[string]]",
        "!doc": "Gets the line style of the cells in the range (&#39;underline&#39;, &#39;line-through&#39;, or\n &#39;none&#39;).\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n var range = sheet.getRange(&quot;B2:D4&quot;);\n\n var results = range.getFontLines();\n\n for (var i in results) {\n   for (var j in results[i]) {\n     Logger.log(results[i][j]);\n   }\n }\n "
      },
      "getFontSize": {
        "!type": "fn() -> number",
        "!doc": "Returns the font size in point size of the cell in the top-left corner of the range.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n var range = sheet.getRange(&quot;B2:D4&quot;);\n\n Logger.log(range.getFontSize());\n "
      },
      "getFontSizes": {
        "!type": "fn() -> [[number]]",
        "!doc": "Returns the font sizes of the cells in the range.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n var range = sheet.getRange(&quot;B2:D4&quot;);\n\n var results = range.getFontSizes();\n\n for (var i in results) {\n   for (var j in results[i]) {\n     Logger.log(results[i][j]);\n   }\n }\n "
      },
      "getFontStyle": {
        "!type": "fn() -> string",
        "!doc": "Returns the font style (&#39;italic&#39; or &#39;normal&#39; of the cell in the top-left corner\n of the range.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n var range = sheet.getRange(&quot;B2:D4&quot;);\n\n Logger.log(range.getFontStyle());\n "
      },
      "getFontStyles": {
        "!type": "fn() -> [[string]]",
        "!doc": "Returns the font styles of the cells in the range.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n var range = sheet.getRange(&quot;B2:D4&quot;);\n\n var results = range.getFontStyles();\n\n for (var i in results) {\n   for (var j in results[i]) {\n     Logger.log(results[i][j]);\n   }\n }\n "
      },
      "getFontWeight": {
        "!type": "fn() -> string",
        "!doc": "Returns the font weight (normal/bold) of the cell in the top-left corner of the range.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n var range = sheet.getRange(&quot;B2:D4&quot;);\n\n Logger.log(range.getFontWeight());\n "
      },
      "getFontWeights": {
        "!type": "fn() -> [[string]]",
        "!doc": "Returns the font weights of the cells in the range.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n var range = sheet.getRange(&quot;B2:D4&quot;);\n\n var results = range.getFontWeights();\n\n for (var i in results) {\n   for (var j in results[i]) {\n     Logger.log(results[i][j]);\n   }\n }\n "
      },
      "getFormula": {
        "!type": "fn() -> string",
        "!doc": "Returns the formula (A1 notation) for the top-left cell of the range,\n or an empty string if the cell is empty or doesn't contain a formula.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n // This assumes we have a function in B5 that sums up\n // B2:B4\n var range = sheet.getRange(&quot;B5&quot;);\n\n // Logs the calculated value and the formula\n Logger.log(&quot;Calculated value: %s Formula: %s&quot;,\n            range.getValue(),\n            range.getFormula());\n "
      },
      "getFormulaR1C1": {
        "!type": "fn() -> string",
        "!doc": "Returns the formula (R1C1 notation) for a given cell, or null if none.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var range = sheet.getRange(&quot;B5&quot;);\n var formula = range.getFormulaR1C1();\n Logger.log(formula);\n "
      },
      "getFormulas": {
        "!type": "fn() -> [[string]]",
        "!doc": "Returns the formulas (A1 notation) for the cells in the range.\n Entries in the 2D array will be an empty string for cells with no formula.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var range = sheet.getRange(&quot;B5:C6&quot;);\n var formulas = range.getFormulas();\n for (var i in formulas) {\n   for (var j in formulas[i]) {\n     Logger.log(formulas[i][j]);\n   }\n }\n "
      },
      "getFormulasR1C1": {
        "!type": "fn() -> [[string]]",
        "!doc": "Returns the formulas (R1C1 notation) for the cells in the range. Entries in the 2D array will\n be null for cells with no formula.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var range = sheet.getRange(&quot;B5:C6&quot;);\n var formulas = range.getFormulasR1C1();\n for (var i in formulas) {\n   for (var j in formulas[i]) {\n     Logger.log(formulas[i][j]);\n   }\n }\n "
      },
      "getGridId": {
        "!type": "fn() -> number",
        "!doc": "Returns the grid ID of the range's parent sheet. The first sheet created in a spreadsheet has a\n grid ID of 0, and each sheet created thereafter increments the ID. The ID does not\n necessarily correspond to a sheet's tab position because sheets may have been reordered or\n deleted. If a sheet is deleted, the grid ID for subsequent sheets continues to increment, and\n the grid ID of the deleted sheet is not reused.\n\n \n \n // Log the grid ID of the first sheet (by tab position) in the spreadsheet.\n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n var range = sheet.getRange(&quot;B2:D4&quot;);\n\n Logger.log(range.getGridId());\n "
      },
      "getHeight": {
        "!type": "fn() -> number",
        "!doc": "Returns the height of the range.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var range = sheet.getRange(&quot;B2:D4&quot;);\n // logs 3.0\n Logger.log(range.getHeight());\n "
      },
      "getHorizontalAlignment": {
        "!type": "fn() -> string",
        "!doc": "Returns the horizontal alignment of the text (left/center/right) of the cell in the top-left\n corner of the range.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n var range = sheet.getRange(&quot;B2:D4&quot;);\n\n Logger.log(range.getHorizontalAlignment());\n "
      },
      "getHorizontalAlignments": {
        "!type": "fn() -> [[string]]",
        "!doc": "Returns the horizontal alignments of the cells in the range.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n var range = sheet.getRange(&quot;B2:D4&quot;);\n\n var results = range.getHorizontalAlignments();\n\n for (var i in results) {\n   for (var j in results[i]) {\n     Logger.log(results[i][j]);\n   }\n }\n "
      },
      "getLastColumn": {
        "!type": "fn() -> number",
        "!doc": "Returns the end column position.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var range = sheet.getRange(&quot;B2:D4&quot;);\n // Logs &quot;4.0&quot;\n Logger.log(range.getLastColumn());\n "
      },
      "getLastRow": {
        "!type": "fn() -> number",
        "!doc": "Returns the end row position.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var range = sheet.getRange(&quot;B2:D4&quot;);\n // Logs &quot;4.0&quot;\n Logger.log(range.getLastRow());\n "
      },
      "getNote": {
        "!type": "fn() -> string",
        "!doc": "Returns the note associated with the given range.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n var range = sheet.getRange(&quot;B2:D4&quot;);\n\n Logger.log(range.getNote());\n "
      },
      "getNotes": {
        "!type": "fn() -> [[string]]",
        "!doc": "Returns the notes associated with the cells in the range.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n var range = sheet.getRange(&quot;B2:D4&quot;);\n\n var results = range.getNotes();\n\n for (var i in results) {\n   for (var j in results[i]) {\n     Logger.log(results[i][j]);\n   }\n }\n "
      },
      "getNumColumns": {
        "!type": "fn() -> number",
        "!doc": "Returns the number of columns in this range.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var range = sheet.getRange(&quot;B2:D5&quot;);\n Logger.log(range.getNumColumns());\n "
      },
      "getNumRows": {
        "!type": "fn() -> number",
        "!doc": "Returns the number of rows in this range.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var range = sheet.getRange(&quot;B2:D5&quot;);\n Logger.log(range.getNumRows());\n "
      },
      "getNumberFormat": {
        "!type": "fn() -> string",
        "!doc": "Get the number formatting of the top-left cell of the given range.\n\n The number format corresponds to a formatting created when a user clicks Format -> Number.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var cell = sheet.getRange(&quot;C4&quot;);\n Logger.log(cell.getNumberFormat());\n "
      },
      "getNumberFormats": {
        "!type": "fn() -> [[string]]",
        "!doc": "Returns the number formats for the cells in the range.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var range = sheet.getRange(&quot;B5:C6&quot;);\n var formats = range.getNumberFormats();\n for (var i in formats) {\n   for (var j in formats[i]) {\n     Logger.log(formats[i][j]);\n   }\n }\n "
      },
      "getRow": {
        "!type": "fn() -> number",
        "!doc": "Returns the row position for this range.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var range = sheet.getRange(&quot;B2&quot;);\n Logger.log(range.getRow());\n "
      },
      "getRowIndex": {
        "!type": "fn() -> number",
        "!doc": "Returns the row position for this range.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var range = sheet.getRange(&quot;B2&quot;);\n Logger.log(range.getRowIndex());\n "
      },
      "getSheet": {
        "!type": "fn() -> SpreadsheetApp.Sheet",
        "!doc": "Returns the sheet this range belongs to."
      },
      "getValue": {
        "!type": "fn() -> object",
        "!doc": "Returns the value of the top-left cell in the range. The value may be of type Number,\n Boolean, Date, or String depending on the value of the cell. Empty\n cells will return an empty string."
      },
      "getValues": {
        "!type": "fn() -> [[object]]",
        "!doc": "Returns the rectangular grid of values for this range.\n\n Returns a two-dimensional array of values, indexed by row, then by column. The values may be of\n type Number, Boolean, Date, or String, depending on the value of\n the cell. Empty cells will be represented by an empty string in the array. Remember that while a\n range index starts at 1, 1, the JavaScript array will be indexed from [0][0].\n\n \n \n // The code below will get the values for the range C2:G8\n // in the active spreadsheet.  Note that this will be a javascript array.\n var values = SpreadsheetApp.getActiveSheet().getRange(2, 3, 6, 4).getValues();\n Logger.log(values[0][0]);\n "
      },
      "getVerticalAlignment": {
        "!type": "fn() -> string",
        "!doc": "Returns the vertical alignment (top/middle/bottom) of the cell in the top-left corner\n of the range.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n var range = sheet.getRange(&quot;B2:D4&quot;);\n\n Logger.log(range.getVerticalAlignment());\n "
      },
      "getVerticalAlignments": {
        "!type": "fn() -> [[string]]",
        "!doc": "Returns the vertical alignments of the cells in the range.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n var range = sheet.getRange(&quot;B2:D4&quot;);\n\n var results = range.getVerticalAlignments();\n\n for (var i in results) {\n   for (var j in results[i]) {\n     Logger.log(results[i][j]);\n   }\n }\n "
      },
      "getWidth": {
        "!type": "fn() -> number",
        "!doc": "Returns the width of the range in columns."
      },
      "getWrap": {
        "!type": "fn() -> Boolean",
        "!doc": "Returns the wrapping policy of the cell in the top-left corner of the range. true if\n the text wraps, false if the text does not.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n var range = sheet.getRange(&quot;B2:D4&quot;);\n\n Logger.log(range.getWrap());\n "
      },
      "getWraps": {
        "!type": "fn() -> [[bool]]",
        "!doc": "Returns the wrapping policy of the cells in the range.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n var range = sheet.getRange(&quot;B2:D4&quot;);\n\n var results = range.getVerticalAlignments();\n\n for (var i in results) {\n   for (var j in results[i]) {\n     var isWrapped = results[i][j];\n     if (isWrapped) {\n        Logger.log(&quot;Cell [%s, %s] has wrapped text&quot;, i, j);\n     }\n   }\n }\n "
      },
      "isBlank": {
        "!type": "fn() -> bool",
        "!doc": "Returns true if the range is totally blank.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n var range = sheet.getRange(&quot;B2:D4&quot;);\n\n Logger.log(range.isBlank());\n "
      },
      "isEndColumnBounded": {
        "!type": "fn() -> bool",
        "!doc": "Determines whether the end of the range is bound to a particular column. For example, for the\n ranges A1:B10 or B:B, which are bound to columns at the end of the range, this\n method returns true; for the ranges 3:7 or A1:5, which are bound only\n to particular rows at the end of the range, this method returns false."
      },
      "isEndRowBounded": {
        "!type": "fn() -> bool",
        "!doc": "Determines whether the end of the range is bound to a particular row. For example, for the\n ranges A1:B10 or 3:7, which are bound to rows at the end of the range, this\n method returns true; for the ranges B:B or A1:C, which are bound only\n to particular columns at the end of the range, this method returns false."
      },
      "isStartColumnBounded": {
        "!type": "fn() -> bool",
        "!doc": "Determines whether the start of the range is bound to a particular column. For example, for the\n ranges A1:B10 or B:B, which are bound to columns at the start of the range,\n this method returns true; for the range 3:7, which is bound only to a\n row at the start of the range, this method returns false."
      },
      "isStartRowBounded": {
        "!type": "fn() -> bool",
        "!doc": "Determines whether the start of the range is bound to a particular row. For example, for the\n ranges A1:B10 or 3:7, which are bound to rows at the start of the range, this\n method returns true; for the range B:B, which is bound only to a\n particular column at the start of the range, this method returns false."
      },
      "merge": {
        "!type": "fn() -> SpreadsheetApp.Range",
        "!doc": "Merges the cells in the range together into a single block.\n\n \n \n  var sheet = SpreadsheetApp.getActiveSheet();\n\n  // The code below will 2-dimensionally merge the cells in A1 to B3\n  sheet.getRange(&#39;A1:B3&#39;).merge();\n "
      },
      "mergeAcross": {
        "!type": "fn() -> SpreadsheetApp.Range",
        "!doc": "Merge the cells in the range across the columns of the range.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n // The code below will merge cells C5:E5 into one cell\n var range1 = sheet.getRange(&quot;C5:E5&quot;);\n range1.mergeAcross();\n\n // The code below will create 2 horizontal cells, F5:H5 and F6:H6\n var range2 = sheet.getRange(&quot;F5:H6&quot;);\n range2.mergeAcross();\n "
      },
      "mergeVertically": {
        "!type": "fn() -> SpreadsheetApp.Range",
        "!doc": "Merges the cells in the range together.\n\n \n \n  var sheet = SpreadsheetApp.getActiveSheet();\n\n  // The code below will vertically merge the cells in A1 to A10\n  sheet.getRange(&#39;A1:A10&#39;).mergeVertically();\n\n  // The code below will create 3 merged columns: B1 to B10, C1 to C10, and D1 to D10\n  sheet.getRange(&#39;B1:D10&#39;).mergeVertically();\n "
      },
      "moveTo": {
        "!type": "fn(target: SpreadsheetApp.Range)",
        "!doc": "Cut and paste (both format and values) from this range to the target range.\n\n \n \n // The code below will move the first 5 columns over to the 6th column\n var sheet = SpreadsheetApp.getActiveSheet()\n sheet.getRange(&quot;A1:E&quot;).moveTo(sheet.getRange(&quot;F1&quot;));\n "
      },
      "offset": {
        "!type": "fn(rowOffset: number, columnOffset: number) -> SpreadsheetApp.Range",
        "!doc": "Returns a new range that is offset from this range by the given number of rows and columns\n (which can be negative). The new range will be the same size as the original range.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var cell = sheet.getRange(&quot;A1&quot;);\n\n // newCell references B2\n var newCell = cell.offset(1, 1);\n "
      },
      "offset ": {
        "!type": "fn(rowOffset: number, columnOffset: number, numRows: number) -> SpreadsheetApp.Range",
        "!doc": "Returns a new range that is relative to the current range, whose  upper left point is offset\n from the current range by the given rows and columns, and with the given height in cells.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var cell = sheet.getRange(&quot;A1&quot;);\n\n // newCell references B2:B3\n var newRange = cell.offset(1, 1, 2);\n "
      },
      "offset  ": {
        "!type": "fn(rowOffset: number, columnOffset: number, numRows: number, numColumns: number) -> SpreadsheetApp.Range",
        "!doc": "Returns a new range that is relative to the current range, whose upper left point is offset\n from the current range by the given rows and columns, and with the given height and width in\n cells.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var cell = sheet.getRange(&quot;A1&quot;);\n\n // newCell references B2:C3\n var newRange = cell.offset(1, 1, 2, 2);\n "
      },
      "protect": {
        "!type": "fn() -> SpreadsheetApp.Protection",
        "!doc": "Creates an object that can protect the range from being edited except by users who have\n permission. Until the script actually changes the list of editors for the range (by calling\n Protection.removeEditor(emailAddress), Protection.removeEditor(user),\n Protection.removeEditors(emailAddresses), Protection.addEditor(emailAddress),\n Protection.addEditor(user), Protection.addEditors(emailAddresses), or\n setting a new value for Protection.setDomainEdit(editable)), the permissions will\n mirror those of the spreadsheet itself, which effectively means that the range remains\n unprotected. If the range is already protected, this method creates a new protected range that\n overlaps the existing one. If a cell is covered by two protected ranges and one of the\n protected ranges allows a particular user to edit the cell and the other does not, the user\n will not be able to edit.\n\n \n \n // Protect range A1:B10, then remove all other users from the list of editors.\n var ss = SpreadsheetApp.getActive();\n var range = ss.getRange(&#39;A1:B10&#39;);\n var protection = range.protect().setDescription(&#39;Sample protected range&#39;);\n\n // Ensure the current user is an editor before removing others. Otherwise, if the user&#39;s edit\n // permission comes from a group, the script will throw an exception upon removing the group.\n var me = Session.getEffectiveUser();\n protection.addEditor(me);\n protection.removeEditors(protection.getEditors());\n if (protection.canDomainEdit()) {\n   protection.setDomainEdit(false);\n }\n "
      },
      "setBackground": {
        "!type": "fn(color: string) -> SpreadsheetApp.Range",
        "!doc": "Sets the background color of all cells in the range in CSS notation (like &#39;#ffffff&#39; or\n &#39;white&#39;).\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var range = sheet.getRange(&quot;B2:D5&quot;);\n range.setBackground(&quot;red&quot;);\n "
      },
      "setBackgroundRGB": {
        "!type": "fn(red: number, green: number, blue: number) -> SpreadsheetApp.Range",
        "!doc": "Sets the background to the given RGB color.  This is a convenience\n wrapper for the setBackground call that takes a string color.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var cell = sheet.getRange(&quot;B2&quot;);\n\n // Sets the background to white\n cell.setBackgroundRGB(255, 255, 255);\n\n // Sets the background to red\n cell.setBackgroundRGB(255, 0, 0);\n "
      },
      "setBackgrounds": {
        "!type": "fn(color: [[string]]) -> SpreadsheetApp.Range",
        "!doc": "Sets a rectangular grid of background colors (must match dimensions of this range). The colors\n are in CSS notation (like &#39;#ffffff&#39; or &#39;white&#39;).\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var colors = [\n   [&quot;red&quot;, &quot;white&quot;, &quot;blue&quot;],\n   [&quot;#FF0000&quot;, &quot;#FFFFFF&quot;, &quot;#0000FF&quot;] // These are the hex equivalents\n ];\n\n var cell = sheet.getRange(&quot;B5:D6&quot;);\n cell.setBackgrounds(colors);\n "
      },
      "setBorder": {
        "!type": "fn(top: bool, left: bool, bottom: bool, right: bool, vertical: bool, horizontal: bool) -> SpreadsheetApp.Range",
        "!doc": "Sets the border property. Valid values are true (on), false (off) and\n null (no change).\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var cell = sheet.getRange(&quot;B2&quot;);\n // Sets borders on the top and bottom, but leaves the left and right unchanged\n cell.setBorder(true, null, true, null, false, false);\n "
      },
      "setDataValidation": {
        "!type": "fn(rule: SpreadsheetApp.DataValidation) -> SpreadsheetApp.Range",
        "!doc": "Sets one data-validation rule for all cells in the range.\n\n \n // Set the data-validation rule for cell A1 to require a value from B1:B10.\n var cell = SpreadsheetApp.getActive().getRange('A1');\n var range = SpreadsheetApp.getActive().getRange('B1:B10');\n var rule = SpreadsheetApp.newDataValidation().requireValueInRange(range).build();\n cell.setDataValidation(rule);\n "
      },
      "setDataValidations": {
        "!type": "fn(rules: [[SpreadsheetApp.DataValidation]]) -> SpreadsheetApp.Range",
        "!doc": "Sets the data-validation rules for all cells in the range. This method takes a two-dimensional\n array of data validations, indexed by row then by column. The array dimensions must correspond\n to the range dimensions.\n\n \n // Set the data-validation rules for Sheet1!A1:B5 to require a value from Sheet2!A1:A10.\n var destinationRange = SpreadsheetApp.getActive().getSheetByName(&#39;Sheet1&#39;).getRange(&#39;A1:B5&#39;);\n var sourceRange = SpreadsheetApp.getActive().getSheetByName(&#39;Sheet2&#39;).getRange(&#39;A1:A10&#39;);\n var rule = SpreadsheetApp.newDataValidation().requireValueInRange(sourceRange).build();\n var rules = destinationRange.getDataValidations();\n for (var i = 0; i &lt; rules.length; i++) {\n   for (var j = 0; j &lt; rules[i].length; j++) {\n     rules[i][j] = rule;\n   }\n }\n destinationRange.setDataValidations(rules);\n "
      },
      "setFontColor": {
        "!type": "fn(color: string) -> SpreadsheetApp.Range",
        "!doc": "Sets the font color in CSS notation (like &#39;#ffffff&#39; or &#39;white&#39;).\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var cell = sheet.getRange(&quot;B2&quot;);\n cell.setFontColor(&quot;red&quot;);\n "
      },
      "setFontColors": {
        "!type": "fn(colors: [[object]]) -> SpreadsheetApp.Range",
        "!doc": "Sets a rectangular grid of font colors (must match dimensions of this range). The colors are in\n CSS notation (like &#39;#ffffff&#39; or &#39;white&#39;).\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var colors = [\n   [&quot;red&quot;, &quot;white&quot;, &quot;blue&quot;],\n   [&quot;#FF0000&quot;, &quot;#FFFFFF&quot;, &quot;#0000FF&quot;] // These are the hex equivalents\n ];\n\n var cell = sheet.getRange(&quot;B5:D6&quot;);\n cell.setFontColors(colors);\n "
      },
      "setFontFamilies": {
        "!type": "fn(fontFamilies: [[object]]) -> SpreadsheetApp.Range",
        "!doc": "Sets a rectangular grid of font families (must match dimensions of this range).\n Examples of font families are \"Arial\" or \"Helvetica\".\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var fonts = [\n   [&quot;Arial&quot;, &quot;Helvetica&quot;, &quot;Verdana&quot;],\n   [&quot;Courier New&quot;, &quot;Arial&quot;, &quot;Helvetica] // These are the hex equivalents\n ];\n\n var cell = sheet.getRange(&quot;B2:D3&quot;);\n cell.setFontFamilies(fonts);\n "
      },
      "setFontFamily": {
        "!type": "fn(fontFamily: string) -> SpreadsheetApp.Range",
        "!doc": "Sets the font family, such as \"Arial\" or \"Helvetica\".\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var cell = sheet.getRange(&quot;B2&quot;);\n cell.setFontFamily(&quot;Helvetica&quot;);\n "
      },
      "setFontLine": {
        "!type": "fn(fontLine: string) -> SpreadsheetApp.Range",
        "!doc": "Sets the line style of the given range (&#39;underline&#39;, &#39;line-through&#39;, or\n &#39;none&#39;).\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var cell = sheet.getRange(&quot;B2&quot;);\n cell.setFontLine(&quot;line-through&quot;);\n "
      },
      "setFontLines": {
        "!type": "fn(fontLines: [[object]]) -> SpreadsheetApp.Range",
        "!doc": "Sets a rectangular grid of line styles (must match dimensions of this range).\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n // The size of the two-dimensional array must match the size of the range.\n var fontLines = [\n   [&quot;underline&quot;, &quot;line-through&quot;, &quot;none&quot;]\n ];\n\n var range = sheet.getRange(&quot;B2:D2&quot;);\n range.setFontLines(fontLines);\n "
      },
      "setFontSize": {
        "!type": "fn(size: number) -> SpreadsheetApp.Range",
        "!doc": "Sets the font size, with the size being the point size to use.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var cell = sheet.getRange(&quot;B2&quot;);\n cell.setFontSize(20);\n "
      },
      "setFontSizes": {
        "!type": "fn(sizes: [[object]]) -> SpreadsheetApp.Range",
        "!doc": "Sets a rectangular grid of font sizes (must match dimensions of this range).\n The sizes are in points.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n // The size of the two-dimensional array must match the size of the range.\n var fontSizes = [\n   [16, 20, 24]\n ];\n\n var range = sheet.getRange(&quot;B2:D2&quot;);\n range.setFontSizes(fontSizes);\n "
      },
      "setFontStyle": {
        "!type": "fn(fontStyle: string) -> SpreadsheetApp.Range",
        "!doc": "Set the font style for the given range (&#39;italic&#39; or &#39;normal&#39;).\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var cell = sheet.getRange(&quot;B2&quot;);\n cell.setFontStyle(&quot;italic&quot;);\n "
      },
      "setFontStyles": {
        "!type": "fn(fontStyles: [[object]]) -> SpreadsheetApp.Range",
        "!doc": "Sets a rectangular grid of font styles (must match dimensions of this range).\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n // The size of the two-dimensional array must match the size of the range.\n var fontStyles = [\n   [&quot;italic&quot;, &quot;normal&quot;]\n ];\n\n var range = sheet.getRange(&quot;B2:C2&quot;);\n range.setFontSizes(fontStyles);\n "
      },
      "setFontWeight": {
        "!type": "fn(fontWeight: string) -> SpreadsheetApp.Range",
        "!doc": "Set the font weight for the given range (normal/bold).\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var cell = sheet.getRange(&quot;B2&quot;);\n cell.setFontWeight(&quot;bold&quot;);\n "
      },
      "setFontWeights": {
        "!type": "fn(fontWeights: [[object]]) -> SpreadsheetApp.Range",
        "!doc": "Sets a rectangular grid of font weights (must match dimensions of this range).\n An example of a font weight is \"bold\".\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n // The size of the two-dimensional array must match the size of the range.\n var fontStyles = [\n   [ &quot;bold&quot;, &quot;bold&quot;, &quot;normal&quot; ]\n ];\n\n var range = sheet.getRange(&quot;B2:D2&quot;);\n range.setFontWeights(fontStyles);\n "
      },
      "setFormula": {
        "!type": "fn(formula: string) -> SpreadsheetApp.Range",
        "!doc": "Updates the formula for this range. The given formula must be in A1 notation.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var cell = sheet.getRange(&quot;B5&quot;);\n cell.setFormula(&quot;=SUM(B3:B4)&quot;);\n "
      },
      "setFormulaR1C1": {
        "!type": "fn(formula: string) -> SpreadsheetApp.Range",
        "!doc": "Updates the formula for this range. The given formula must be in R1C1 notation.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var cell = sheet.getRange(&quot;B5&quot;);\n // This sets the formula to be the sum of the 3 rows above B5\n cell.setFormulaR1C1(&quot;=SUM(R[-3]C[0]:R[-1]C[0])&quot;);\n "
      },
      "setFormulas": {
        "!type": "fn(formulas: [[string]]) -> SpreadsheetApp.Range",
        "!doc": "Sets a rectangular grid of formulas (must match dimensions of this range). The given formulas\n must be in A1 notation. This method takes a two-dimensional array of formulas, indexed by row,\n then by column. The array dimensions must correspond to the range dimensions.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n // This sets the formulas to be a row of sums, followed by a row of averages right below.\n // The size of the two-dimensional array must match the size of the range.\n var formulas = [\n   [&quot;=SUM(B2:B4)&quot;, &quot;=SUM(C2:C4)&quot;, &quot;=SUM(D2:D4)&quot;],\n   [&quot;=AVERAGE(B2:B4)&quot;, &quot;=AVERAGE(C2:C4)&quot;, &quot;=AVERAGE(D2:D4)&quot;]\n ];\n\n var cell = sheet.getRange(&quot;B5:D6&quot;);\n cell.setFormulas(formulas);\n "
      },
      "setFormulasR1C1": {
        "!type": "fn(formulas: [[string]]) -> SpreadsheetApp.Range",
        "!doc": "Sets a rectangular grid of formulas (must match dimensions of this range). The given formulas\n must be in R1C1 notation.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n // This creates formulas for a row of sums, followed by a row of averages.\n var sumOfRowsAbove = &quot;=SUM(R[-3]C[0]:R[-1]C[0])&quot;;\n var averageOfRowsAbove = &quot;=AVERAGE(R[-4]C[0]:R[-2]C[0])&quot;;\n\n // The size of the two-dimensional array must match the size of the range.\n var formulas = [\n   [sumOfRowsAbove, sumOfRowsAbove, sumOfRowsAbove],\n   [averageOfRowsAbove, averageOfRowsAbove, averageOfRowsAbove]\n ];\n\n var cell = sheet.getRange(&quot;B5:D6&quot;);\n // This sets the formula to be the sum of the 3 rows above B5.\n cell.setFormulasR1C1(formulas);\n "
      },
      "setHorizontalAlignment": {
        "!type": "fn(alignment: string) -> SpreadsheetApp.Range",
        "!doc": "Set the horizontal (left to right) alignment for the given range (left/center/right).\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var cell = sheet.getRange(&quot;B2&quot;);\n cell.setHorizontalAlignment(&quot;center&quot;);\n "
      },
      "setHorizontalAlignments": {
        "!type": "fn(alignments: [[object]]) -> SpreadsheetApp.Range",
        "!doc": "Sets a rectangular grid of horizontal alignments.\n see setHorizontalAlignment(alignment)\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n // The size of the two-dimensional array must match the size of the range.\n var horizontalAlignments = [\n   [ &quot;left&quot;, &quot;right&quot;, &quot;center&quot; ]\n ];\n\n var range = sheet.getRange(&quot;B2:D2&quot;);\n range.setHorizontalAlignments(horizontalAlignments);\n "
      },
      "setNote": {
        "!type": "fn(note: string) -> SpreadsheetApp.Range",
        "!doc": "Sets the note to the given value.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var cell = sheet.getRange(&quot;B2&quot;);\n cell.setNote(&quot;This is a note&quot;);\n "
      },
      "setNotes": {
        "!type": "fn(notes: [[object]]) -> SpreadsheetApp.Range",
        "!doc": "Sets a rectangular grid of notes (must match dimensions of this range).\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n // The size of the two-dimensional array must match the size of the range.\n var notes = [\n   [&quot;it goes&quot;, &quot;like this&quot;, &quot;the fourth, the fifth&quot;],\n   [&quot;the minor fall&quot;, &quot;and the&quot;, &quot;major lift&quot;]\n ];\n\n var cell = sheet.getRange(&quot;B2:D3&quot;);\n cell.setNotes(notes)\n "
      },
      "setNumberFormat": {
        "!type": "fn(numberFormat: string) -> SpreadsheetApp.Range",
        "!doc": "Sets the number or date format to the given formatting string. Date formats follow the\n java.text.SimpleDateFormat specification.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var cell = sheet.getRange(&quot;B2&quot;);\n // Always show 3 decimal points\n cell.setNumberFormat(&quot;0.000&quot;);\n "
      },
      "setNumberFormats": {
        "!type": "fn(numberFormats: [[object]]) -> SpreadsheetApp.Range",
        "!doc": "Sets a rectangular grid of number or date formats (must match dimensions of this range). The\n values are formatting strings, see setNumberFormat(numberFormat). Date formats follow the\n java.text.SimpleDateFormat specification.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n // The size of the two-dimensional array must match the size of the range.\n var formats = [\n   [ &quot;0.000&quot;, &quot;0,000,000&quot;, &quot;$0.00&quot; ]\n ];\n\n var range = sheet.getRange(&quot;B2:D2&quot;);\n range.setNumberFormats(formats);\n "
      },
      "setValue": {
        "!type": "fn(value: object) -> SpreadsheetApp.Range",
        "!doc": "Sets the value of the range. The value can be numeric, string,\n boolean or date.  If it begins with '=' it is interpreted\n as a formula.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var cell = sheet.getRange(&quot;B2&quot;);\n cell.setValue(100);\n "
      },
      "setValues": {
        "!type": "fn(values: [[object]]) -> SpreadsheetApp.Range",
        "!doc": "Sets a rectangular grid of values (must match dimensions of this range).\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n // The size of the two-dimensional array must match the size of the range.\n var values = [\n   [ &quot;2.000&quot;, &quot;1,000,000&quot;, &quot;$2.99&quot; ]\n ];\n\n var range = sheet.getRange(&quot;B2:D2&quot;);\n range.setValues(values);\n "
      },
      "setVerticalAlignment": {
        "!type": "fn(alignment: string) -> SpreadsheetApp.Range",
        "!doc": "Set the vertical (top to bottom) alignment for the given range (top/middle/bottom).\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var cell = sheet.getRange(&quot;B2&quot;);\n cell.setVerticalAlignment(&quot;middle&quot;);\n "
      },
      "setVerticalAlignments": {
        "!type": "fn(alignments: [[object]]) -> SpreadsheetApp.Range",
        "!doc": "Sets a rectangular grid of vertical alignments (must match dimensions of this range).\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n // The size of the two-dimensional array must match the size of the range.\n var alignments = [\n   [ &quot;top&quot;, &quot;middle&quot;, &quot;bottom&quot; ]\n ];\n\n var range = sheet.getRange(&quot;B2:D2&quot;);\n range.setVerticalAlignments(alignments);\n "
      },
      "setWrap": {
        "!type": "fn(isWrapEnabled: bool) -> SpreadsheetApp.Range",
        "!doc": "Set the cell wrap of the given range.\n\n Cells with wrap enabled (the default) will resize to display their full content. Cells with\n wrap disabled will display as much as possible in the cell without resizing or running to\n multiple lines.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var cell = sheet.getRange(&quot;B2&quot;);\n cell.setWrap(true);\n "
      },
      "setWraps": {
        "!type": "fn(isWrapEnabled: [[object]]) -> SpreadsheetApp.Range",
        "!doc": "Sets a rectangular grid of word wrap policies (must match dimensions of this range). Cells with\n wrap enabled (the default) will resize to display their full content. Cells with wrap disabled\n will display as much as possible in the cell without resizing or running to multiple lines.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n // The size of the two-dimensional array must match the size of the range.\n var wraps = [\n   [ true, true, false ]\n ];\n\n var range = sheet.getRange(&quot;B2:D2&quot;);\n range.setWraps(wraps);\n "
      },
      "sort": {
        "!type": "fn(sortSpecObj: object) -> SpreadsheetApp.Range",
        "!doc": "Sorts the cells in the given range.\n\n Sorts the cells in a given range, by column and order specified.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n var range = sheet.getRange(&quot;A1:C7&quot;);\n\n // Sorts by the values in the first column (A)\n range.sort(1);\n\n // Sorts by the values in the second column (B)\n range.sort(2);\n\n // Sorts descending by column B\n range.sort({column: 2, ascending: false});\n\n // Sorts descending by column B, then ascending by column A\n // Note the use of an array\n range.sort([{column: 2, ascending: false}, {column: 1, ascending: true}]);\n\n // For rows that are sorted in ascending order, the &quot;ascending&quot; parameter is\n // optional, and just an integer with the column can be used instead. Note that\n // in general, keeping the sort specification consistent results in more readable\n // code. We could have expressed the earlier sort as:\n range.sort([{column: 2, ascending: false}, 1]);\n\n // Alternatively, if we wanted all columns to be in ascending order, we would use\n // the following (this would make column 2 ascending)\n range.sort([2, 1]);\n // ... which is equivalent to\n range.sort([{column: 2, ascending: true}, {column: 1, ascending: true}]);\n "
      }
    },
    "SpreadsheetApp.Sheet": {
      "activate": {
        "!type": "fn() -> SpreadsheetApp.Sheet",
        "!doc": "Activates this sheet. Does not alter the sheet itself, only\n the parent's notion of the active sheet.\n\n \n \n // This example assumes there is a sheet named &quot;first&quot;\n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var first = ss.getSheetByName(&quot;first&quot;);\n first.activate();\n "
      },
      "appendRow": {
        "!type": "fn(rowContents: [object]) -> SpreadsheetApp.Sheet",
        "!doc": "Appends a row to the spreadsheet.  This operation is atomic; it prevents issues where\n a user asks for the last row, and then writes to that row, and an intervening mutation\n occurs between getting the last row and writing to it.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n // Appends a new row with 3 columns to the bottom of the\n // spreadsheet containing the values in the array\n sheet.appendRow([&quot;a man&quot;, &quot;a plan&quot;, &quot;panama&quot;]);\n "
      },
      "autoResizeColumn": {
        "!type": "fn(columnPosition: number) -> SpreadsheetApp.Sheet",
        "!doc": "Sets the width of the given column to fit its contents\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n sheet.getRange(&#39;a1&#39;).setValue(&#39;Whenever it is a damp, drizzly November in my soul...&#39;);\n\n // Sets the first column to a width which fits the text\n sheet.autoResizeColumn(1);\n "
      },
      "clear": {
        "!type": "fn() -> SpreadsheetApp.Sheet",
        "!doc": "Clears the sheet of content and formatting information.\n\n \n \n // This example assumes there is a sheet named &quot;first&quot;\n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var first = ss.getSheetByName(&quot;first&quot;);\n first.clear();\n "
      },
      "clear ": {
        "!type": "fn(options: object) -> SpreadsheetApp.Sheet",
        "!doc": "Clears the sheet of contents and/or format, as specified with the given\n advanced options.\n\n The advanced options are:\n \n   contentsOnly\n   formatOnly\n \n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n sheet.clear({ formatOnly: true, contentsOnly: true });\n "
      },
      "clearContents": {
        "!type": "fn() -> SpreadsheetApp.Sheet",
        "!doc": "Clears the sheet of contents, while preserving formatting information.\n\n \n \n // This example assumes there is a sheet named &quot;first&quot;\n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var first = ss.getSheetByName(&quot;first&quot;);\n first.clearContents();\n "
      },
      "clearFormats": {
        "!type": "fn() -> SpreadsheetApp.Sheet",
        "!doc": "Clears the sheet of formatting, while preserving contents.\n\n Formatting refers to how data is formatted as allowed by choices under the \"Format\" menu\n (ex: bold, italics, conditional formatting) and not width or height of cells.\n\n \n \n // This example assumes there is a sheet named &quot;first&quot;\n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var first = ss.getSheetByName(&quot;first&quot;);\n first.clearFormats();\n "
      },
      "clearNotes": {
        "!type": "fn() -> SpreadsheetApp.Sheet",
        "!doc": "Clears the sheet of all notes.\n\n \n \n // This example assumes there is a sheet named &quot;first&quot;\n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var first = ss.getSheetByName(&quot;first&quot;);\n first.clearNotes();\n "
      },
      "copyTo": {
        "!type": "fn(spreadsheet: SpreadsheetApp.Spreadsheet) -> SpreadsheetApp.Sheet",
        "!doc": "Copies the sheet to a given spreadsheet, which can be the same spreadsheet\n as the source. The copied sheet will be named \"Copy of [original name]\".\n\n \n \n var source = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = source.getSheets()[0];\n\n var destination = SpreadsheetApp.openById(&#39;ID_GOES HERE&#39;);\n sheet.copyTo(destination);\n "
      },
      "deleteColumn": {
        "!type": "fn(columnPosition: number) -> SpreadsheetApp.Sheet",
        "!doc": "Deletes the column at the given column position.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n // Columns start at &quot;1&quot; - this will delete the first column\n sheet.deleteColumn(1);\n "
      },
      "deleteColumns": {
        "!type": "fn(columnPosition: number, howMany: number)",
        "!doc": "Deletes a number of columns starting at the given column position.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n // Columns start at &quot;1&quot; - this will delete the first two columns\n sheet.deleteColumns(1, 2);\n "
      },
      "deleteRow": {
        "!type": "fn(rowPosition: number) -> SpreadsheetApp.Sheet",
        "!doc": "Deletes the row at the given row position.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n // Rows start at &quot;1&quot; - this will delete the first row\n sheet.deleteRow(1);\n "
      },
      "deleteRows": {
        "!type": "fn(rowPosition: number, howMany: number)",
        "!doc": "Deletes a number of rows starting at the given row position.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n // Rows start at &quot;1&quot; - this will delete the first two rows\n sheet.deleteRows(1, 2);\n "
      },
      "getActiveCell": {
        "!type": "fn() -> SpreadsheetApp.Range",
        "!doc": "Returns the active cell in this sheet.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n // Returns the active cell\n var cell = sheet.getActiveCell();\n "
      },
      "getActiveRange": {
        "!type": "fn() -> SpreadsheetApp.Range",
        "!doc": "Returns the active range for the active sheet.\n\n Returns the range of cells that is currently considered active. This generally means the\n range that a user has selected in the active sheet, but in a custom function it refers to\n the cell being actively recalculated.\n\n Note that when called on a SpreadsheetApp it effectively calls getActiveSpreadsheet and\n then getActiveSheet to act on the active Sheet.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n // Returns the active cell\n var range = sheet.getActiveRange();\n "
      },
      "getCharts": {
        "!type": "fn() -> [SpreadsheetApp.EmbeddedChart]",
        "!doc": "Returns an array of charts on this sheet.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n var charts = sheet.getCharts();\n\n for (var i in charts) {\n   var chart = charts[i];\n   // Do something with the chart\n }\n "
      },
      "getColumnWidth": {
        "!type": "fn(columnPosition: number) -> number",
        "!doc": "Gets the width in pixels of the given column.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n // Columns start at 1\n Logger.log(sheet.getColumnWidth(1));\n "
      },
      "getDataRange": {
        "!type": "fn() -> SpreadsheetApp.Range",
        "!doc": "Returns a Range corresponding to the dimensions in which data is present.\n\n This is functionally equivalent to creating a Range bounded by A1 and\n (Range.getLastColumn(), Range.getLastRow()).\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n // This represents ALL the data\n var range = sheet.getDataRange();\n var values = range.getValues();\n\n // This logs the spreadsheet in CSV format with a trailing comma\n for (var i = 0; i &lt; values.length; i++) {\n   var row = &quot;&quot;;\n   for (var j = 0; j &lt; values[i].length; j++) {\n     if (values[i][j]) {\n       row = row + values[i][j];\n     }\n     row = row + &quot;,&quot;;\n   }\n   Logger.log(row);\n }\n "
      },
      "getFrozenColumns": {
        "!type": "fn() -> number",
        "!doc": "Returns the number of frozen columns.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n Logger.log(&quot;Number of frozen columns: %s&quot;, sheet.getFrozenColumns());\n "
      },
      "getFrozenRows": {
        "!type": "fn() -> number",
        "!doc": "Returns the number of frozen rows.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n Logger.log(&quot;Number of frozen rows: %s&quot;, sheet.getFrozenRows());\n "
      },
      "getIndex": {
        "!type": "fn() -> number",
        "!doc": "Gets the position of the sheet in its parent spreadsheet. Starts at 1.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n // Note that the JavaScript index is 0, but this will log 1\n var sheet = ss.getSheets()[0];\n // ... because spreadsheets are 1-indexed\n Logger.log(sheet.getIndex());\n "
      },
      "getLastColumn": {
        "!type": "fn() -> number",
        "!doc": "Returns the position of the last column that has content.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n // This logs the value in the very last cell of this sheet\n var lastRow = sheet.getLastRow();\n var lastColumn = sheet.getLastColumn();\n var lastCell = sheet.getRange(lastRow, lastColumn);\n Logger.log(lastCell.getValue());\n "
      },
      "getLastRow": {
        "!type": "fn() -> number",
        "!doc": "Returns the position of the last row that has content.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n // This logs the value in the very last cell of this sheet\n var lastRow = sheet.getLastRow();\n var lastColumn = sheet.getLastColumn();\n var lastCell = sheet.getRange(lastRow, lastColumn);\n Logger.log(lastCell.getValue());\n "
      },
      "getMaxColumns": {
        "!type": "fn() -> number",
        "!doc": "The maximum width of the sheet, regardless of content.\n\n \n \n // This example assumes there is a sheet named &quot;first&quot;\n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var first = ss.getSheetByName(&quot;first&quot;);\n Logger.log(first.getMaxColumns());\n "
      },
      "getMaxRows": {
        "!type": "fn() -> number",
        "!doc": "The maximum height of the sheet, regardless of content.\n\n \n \n // This example assumes there is a sheet named &quot;first&quot;\n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var first = ss.getSheetByName(&quot;first&quot;);\n Logger.log(first.getMaxRows());\n "
      },
      "getName": {
        "!type": "fn() -> string",
        "!doc": "Returns the name of the sheet.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n Logger.log(sheet.getName());\n "
      },
      "getParent": {
        "!type": "fn() -> SpreadsheetApp.Spreadsheet",
        "!doc": "Returns the Spreadsheet that contains this sheet.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n // parent is identical to ss\n var parent = sheet.getParent();\n "
      },
      "getProtections": {
        "!type": "fn(type: SpreadsheetApp.ProtectionType) -> [SpreadsheetApp.Protection]",
        "!doc": "Gets an array of objects representing all protected ranges in the sheet, or a single-element\n array representing the protection on the sheet itself.\n\n \n \n // Remove all range protections in the spreadsheet that the user has permission to edit.\n var sheet = SpreadsheetApp.getActiveSheet();\n var protections = sheet.getProtections(SpreadsheetApp.ProtectionType.RANGE);\n for (var i = 0; i &lt; protections.length; i++) {\n   var protection = protections[i];\n   if (protection.canEdit()) {\n     protection.remove();\n   }\n }\n \n\n \n \n // Remove sheet protection from the active sheet, if the user has permission to edit it.\n var sheet = SpreadsheetApp.getActiveSheet();\n var protection = sheet.getProtections(SpreadsheetApp.ProtectionType.SHEET)[0];\n if (protection &amp;&amp; protection.canEdit()) {\n   protection.remove();\n }\n "
      },
      "getRange": {
        "!type": "fn(row: number, column: number) -> SpreadsheetApp.Range",
        "!doc": "Returns the range with the top left cell at the given coordinates.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n // Passing only two arguments returns a &quot;range&quot; with a single cell.\n var range = sheet.getRange(1, 1);\n var values = range.getValues();\n Logger.log(values[0][0]);\n "
      },
      "getRange ": {
        "!type": "fn(row: number, column: number, numRows: number) -> SpreadsheetApp.Range",
        "!doc": "Returns the range with the top left cell at the given coordinates, and with the given\n number of rows.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n // When the &quot;numRows&quot; argument is used, only a single column of data is returned.\n var range = sheet.getRange(1, 1, 3);\n var values = range.getValues();\n\n // Prints 3 values from the first column, starting from row 1.\n for (var row in values) {\n   for (var col in values[row]) {\n     Logger.log(values[row][col]);\n   }\n }\n "
      },
      "getRange  ": {
        "!type": "fn(row: number, column: number, numRows: number, numColumns: number) -> SpreadsheetApp.Range",
        "!doc": "Returns the range with the top left cell at the given coordinates with the given\n number of rows and columns.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n var range = sheet.getRange(1, 1, 3, 3);\n var values = range.getValues();\n\n // Print values from a 3x3 box.\n for (var row in values) {\n   for (var col in values[row]) {\n     Logger.log(values[row][col]);\n   }\n }\n "
      },
      "getRange   ": {
        "!type": "fn(a1Notation: string) -> SpreadsheetApp.Range",
        "!doc": "Returns the range as specified in A1 notation or R1C1 notation.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n // Returns the first cell\n var cell = sheet.getRange(&quot;A1&quot;);\n "
      },
      "getRowHeight": {
        "!type": "fn(rowPosition: number) -> number",
        "!doc": "Gets the height in pixels of the given row.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n // Rows start at 1\n Logger.log(sheet.getRowHeight(1));\n "
      },
      "getSheetId": {
        "!type": "fn() -> number",
        "!doc": "Returns the ID of the sheet represented by this object.\n\n This is an ID for the sheet that is unique to the spreadsheet. The ID is a monotonically\n increasing integer assigned at sheet creation time that is independent of sheet position.\n This is useful in conjunction with methods such as\n Range.copyFormatToRange(gridId, column, columnEnd, row, rowEnd) that take a gridId\n parameter rather than a Sheet instance.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n Logger.log(sheet.getSheetId());\n "
      },
      "getSheetName": {
        "!type": "fn() -> string",
        "!doc": "Returns the sheet name.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n Logger.log(sheet.getSheetName());\n "
      },
      "getSheetProtection": {
        "!type": "fn() -> SpreadsheetApp.PageProtection",
        "!doc": "Returns a PageProtection instance describing the permissions for the current sheet.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var permissions = sheet.getSheetProtection();\n\n permissions.setProtected(true);\n permissions.addUser(&quot;user@example.com&quot;);\n\n // Logs the users that have access to edit this sheet. Note that this\n // is different from access to the entire spreadsheet - getUsers() will\n // only return users if permissions.isProtected() is set to true.\n var users = permissions.getUsers();\n Logger.log(users);\n "
      },
      "getSheetValues": {
        "!type": "fn(startRow: number, startColumn: number, numRows: number, numColumns: number) -> [[object]]",
        "!doc": "Returns the rectangular grid of values for this range starting at the given\n coordinates. A -1 value given as the row or column position is equivalent to getting the\n very last row or column that has data in the sheet.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n // The two samples below produce the same output\n var values = sheet.getSheetValues(1, 1, 3, 3);\n Logger.log(values);\n\n var range = sheet.getRange(1, 1, 3, 3);\n values = range.getValues();\n Logger.log(values);\n "
      },
      "hideColumn": {
        "!type": "fn(column: SpreadsheetApp.Range)",
        "!doc": "Hides the columns in the given range.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n // This hides the first column\n var range = sheet.getRange(&quot;A1&quot;);\n sheet.hideColumn(range);\n "
      },
      "hideColumns": {
        "!type": "fn(columnIndex: number)",
        "!doc": "Hides the column at the given index.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n // Hides the first column\n sheet.hideColumns(1);\n "
      },
      "hideColumns ": {
        "!type": "fn(columnIndex: number, numColumns: number)",
        "!doc": "Hides one or more consecutive columns starting at the given index.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n // Hides the first three columns\n sheet.hideColumns(1, 3);\n "
      },
      "hideRow": {
        "!type": "fn(row: SpreadsheetApp.Range)",
        "!doc": "Hides the rows in the given range.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n // This hides the first row\n var range = sheet.getRange(&quot;A1&quot;);\n sheet.hideRow(range);\n "
      },
      "hideRows": {
        "!type": "fn(rowIndex: number)",
        "!doc": "Hides the row at the given index.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n // Hides the first row\n sheet.hideRows(1);\n "
      },
      "hideRows ": {
        "!type": "fn(rowIndex: number, numRows: number)",
        "!doc": "Hides one or more consecutive rows starting at the given index.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n // Hides the first three rows\n sheet.hideRows(1, 3);\n "
      },
      "hideSheet": {
        "!type": "fn() -> SpreadsheetApp.Sheet",
        "!doc": "Hides this sheet.  Has no effect if the sheet is already hidden.  If this method is called\n on the only visible sheet, it will throw an exception.\n\n \n \n var sheet = SpreadsheetApp.getActiveSheet();\n sheet.hideSheet();\n "
      },
      "insertChart": {
        "!type": "fn(chart: SpreadsheetApp.EmbeddedChart)",
        "!doc": "Adds a new chart to this sheet.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n // This creates a simple bar chart from the first three rows\n // of the first two columns of the spreadsheet\n var chart = sheet.newChart()\n     .setChartType(Charts.ChartType.BAR)\n     .addRange(sheet.getRange(&quot;A1:B4&quot;))\n     .setPosition(5, 5, 0, 0)\n     .setOption(&quot;title&quot;, &quot;Dynamic Chart&quot;)\n     .build();\n sheet.insertChart(chart);\n "
      },
      "insertColumnAfter": {
        "!type": "fn(afterPosition: number) -> SpreadsheetApp.Sheet",
        "!doc": "Inserts a column after the given column position.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n // This inserts a column after the first column position\n sheet.insertColumnAfter(1);\n "
      },
      "insertColumnBefore": {
        "!type": "fn(beforePosition: number) -> SpreadsheetApp.Sheet",
        "!doc": "Inserts a column before the given column position.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n // This inserts a column in the first column position\n sheet.insertColumnBefore(1);\n "
      },
      "insertColumns": {
        "!type": "fn(columnIndex: number)",
        "!doc": "Inserts a blank column in a sheet at the specified location.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n // Shifts all columns by one\n sheet.insertColumns(1);\n "
      },
      "insertColumns ": {
        "!type": "fn(columnIndex: number, numColumns: number)",
        "!doc": "Inserts one or more consecutive blank columns in a sheet starting at the specified location.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n // Shifts all columns by three\n sheet.insertColumns(1, 3);\n "
      },
      "insertColumnsAfter": {
        "!type": "fn(afterPosition: number, howMany: number) -> SpreadsheetApp.Sheet",
        "!doc": "Inserts a number of columns after the given column position.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n // This inserts a column in the second column position\n sheet.insertColumnsAfter(1);\n "
      },
      "insertColumnsBefore": {
        "!type": "fn(beforePosition: number, howMany: number) -> SpreadsheetApp.Sheet",
        "!doc": "Inserts a number of columns before the given column position.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n // This inserts five columns before the first column\n sheet.insertColumnsBefore(1, 5);\n "
      },
      "insertImage": {
        "!type": "fn(blob: Blob, column: number, row: number)",
        "!doc": "Inserts a Blob as an image in the document at a given row and column. The image size\n is retrieved from the blob contents.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var blob = Utilities.newBlob(binaryData, &#39;image/png&#39;, &#39;MyImageName&#39;);\n sheet.insertImage(blob, 1, 1);\n "
      },
      "insertImage ": {
        "!type": "fn(blob: Blob, column: number, row: number, offsetX: number, offsetY: number)",
        "!doc": "Inserts a Blob as an image in the document at a given row and column, with a pixel\n offset. The image size is retrieved from the blob contents.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var blob = Utilities.newBlob(binaryData, &#39;image/png&#39;, &#39;MyImageName&#39;);\n sheet.insertImage(blob, 1, 1, 10, 10);\n "
      },
      "insertImage  ": {
        "!type": "fn(url: string, column: number, row: number)",
        "!doc": "Inserts an image in the document at a given row and column.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n sheet.insertImage(&quot;https://www.google.com/images/srpr/logo3w.png&quot;, 1, 1);\n "
      },
      "insertImage   ": {
        "!type": "fn(url: string, column: number, row: number, offsetX: number, offsetY: number)",
        "!doc": "Inserts an image in the document at a given row and column, with a pixel offset.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n sheet.insertImage(&quot;https://www.google.com/images/srpr/logo3w.png&quot;, 1, 1, 10, 10);\n "
      },
      "insertRowAfter": {
        "!type": "fn(afterPosition: number) -> SpreadsheetApp.Sheet",
        "!doc": "Inserts a row after the given row position.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n // This inserts a row after the first row position\n sheet.insertRowAfter(1);\n "
      },
      "insertRowBefore": {
        "!type": "fn(beforePosition: number) -> SpreadsheetApp.Sheet",
        "!doc": "Inserts a row before the given row position.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n // This inserts a row before the first row position\n sheet.insertRowBefore(1);\n "
      },
      "insertRows": {
        "!type": "fn(rowIndex: number)",
        "!doc": "Inserts a blank row in a sheet at the specified location.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n // Shifts all rows down by one\n sheet.insertRows(1);\n "
      },
      "insertRows ": {
        "!type": "fn(rowIndex: number, numRows: number)",
        "!doc": "Inserts one or more consecutive blank rows in a sheet starting at the specified location.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n // Shifts all rows down by three\n sheet.insertRows(1, 3);\n "
      },
      "insertRowsAfter": {
        "!type": "fn(afterPosition: number, howMany: number) -> SpreadsheetApp.Sheet",
        "!doc": "Inserts a number of rows after the given row position.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n // This inserts five rows after the first row\n sheet.insertRowsAfter(1, 5);\n "
      },
      "insertRowsBefore": {
        "!type": "fn(beforePosition: number, howMany: number) -> SpreadsheetApp.Sheet",
        "!doc": "Inserts a number of rows before the given row position.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n // This inserts five rows before the first row\n sheet.insertRowsBefore(1, 5);\n "
      },
      "isSheetHidden": {
        "!type": "fn() -> bool",
        "!doc": "Returns true if the sheet is currently hidden.\n\n \n \n var sheet = SpreadsheetApp.getActiveSheet();\n if (sheet.isSheetHidden()) {\n   // do something...\n }\n "
      },
      "newChart": {
        "!type": "fn() -> SpreadsheetApp.EmbeddedChartBuilder",
        "!doc": "Returns a builder to create a new chart for this sheet.\n\n This example shows how to create a new chart:\n \n \n var sheet = SpreadsheetApp.getActiveSheet();\n var range = sheet.getRange(&quot;A1:B8&quot;);\n var chartBuilder = sheet.newChart();\n chartBuilder.addRange(range)\n     .setChartType(Charts.ChartType.LINE)\n     .setPosition(2, 2, 0, 0)\n     .setOption(&#39;title&#39;, &#39;My Line Chart!&#39;);\n sheet.insertChart(chartBuilder.build());\n "
      },
      "protect": {
        "!type": "fn() -> SpreadsheetApp.Protection",
        "!doc": "Creates an object that can protect the sheet from being edited except by users who have\n permission. Until the script actually changes the list of editors for the sheet (by calling\n Protection.removeEditor(emailAddress), Protection.removeEditor(user),\n Protection.removeEditors(emailAddresses), Protection.addEditor(emailAddress),\n Protection.addEditor(user), Protection.addEditors(emailAddresses), or\n setting a new value for Protection.setDomainEdit(editable)), the permissions will\n mirror those of the spreadsheet itself, which effectively means that the sheet remains\n unprotected. If the sheet is already protected, this method returns an object representing its\n existing protection settings. A protected sheet may include unprotected regions.\n\n \n \n // Protect the active sheet, then remove all other users from the list of editors.\n var sheet = SpreadsheetApp.getActiveSheet();\n var protection = sheet.protect().setDescription(&#39;Sample protected sheet&#39;);\n\n // Ensure the current user is an editor before removing others. Otherwise, if the user&#39;s edit\n // permission comes from a group, the script will throw an exception upon removing the group.\n var me = Session.getEffectiveUser();\n protection.addEditor(me);\n protection.removeEditors(protection.getEditors());\n if (protection.canDomainEdit()) {\n   protection.setDomainEdit(false);\n }\n "
      },
      "removeChart": {
        "!type": "fn(chart: SpreadsheetApp.EmbeddedChart)",
        "!doc": "Removes a chart from the parent sheet.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n // This removes all the embedded charts from the spreadsheet\n var charts = sheet.getCharts();\n for (var i in charts) {\n   sheet.removeChart(charts[i]);\n }\n "
      },
      "setActiveRange": {
        "!type": "fn(range: SpreadsheetApp.Range) -> SpreadsheetApp.Range",
        "!doc": "Sets the active range for the active sheet.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var range = sheet.getRange(&quot;A1:D4&quot;);\n sheet.setActiveRange(range);\n "
      },
      "setActiveSelection": {
        "!type": "fn(range: SpreadsheetApp.Range) -> SpreadsheetApp.Range",
        "!doc": "Sets the active selection region for this sheet.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var range = sheet.getRange(&quot;A1:D4&quot;);\n sheet.setActiveSelection(range);\n "
      },
      "setActiveSelection ": {
        "!type": "fn(a1Notation: string) -> SpreadsheetApp.Range",
        "!doc": "Sets the active selection, as specified in A1 notation or R1C1 notation.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n sheet.setActiveSelection(&quot;A1:D4&quot;);\n "
      },
      "setColumnWidth": {
        "!type": "fn(columnPosition: number, width: number) -> SpreadsheetApp.Sheet",
        "!doc": "Sets the width of the given column in pixels.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n // Sets the first column to a width of 200 pixels\n sheet.setColumnWidth(1, 200);\n "
      },
      "setFrozenColumns": {
        "!type": "fn(columns: number)",
        "!doc": "Freezes the given number of columns. If zero, no columns are frozen.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n // Freezes the first column\n sheet.setFrozenColumns(1);\n "
      },
      "setFrozenRows": {
        "!type": "fn(rows: number)",
        "!doc": "Freezes the given number of rows. If zero, no rows are frozen.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n // Freezes the first row\n sheet.setFrozenRows(1);\n "
      },
      "setName": {
        "!type": "fn(name: string) -> SpreadsheetApp.Sheet",
        "!doc": "Sets the sheet name.\n\n \n \n // This example assumes there is a sheet named &quot;first&quot;\n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var first = ss.getSheetByName(&quot;first&quot;);\n first.setName(&quot;not first anymore&quot;);\n "
      },
      "setRowHeight": {
        "!type": "fn(rowPosition: number, height: number) -> SpreadsheetApp.Sheet",
        "!doc": "Sets the row height of the given row in pixels.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n // Sets the first row to a height of 200 pixels\n sheet.setRowHeight(1, 200);\n "
      },
      "setSheetProtection": {
        "!type": "fn(permissions: SpreadsheetApp.PageProtection)",
        "!doc": "Sets the permissions for the current sheet.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var permissions = sheet.getSheetProtection();\n\n // This copies the permissions on the first sheet to the second sheet\n var sheetToClonePermissionsTo = ss.getSheets()[1];\n sheetToClonePermissionsTo.setSheetProtection(permissions);\n "
      },
      "showColumns": {
        "!type": "fn(columnIndex: number)",
        "!doc": "Unhides the column at the given index.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n // Unhides the first column\n sheet.showColumns(1);\n "
      },
      "showColumns ": {
        "!type": "fn(columnIndex: number, numColumns: number)",
        "!doc": "Unhides one or more consecutive columns starting at the given index.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n // Unhides the first three columns\n sheet.showColumns(1, 3);\n "
      },
      "showRows": {
        "!type": "fn(rowIndex: number)",
        "!doc": "Unhides the row at the given index.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n // Unhides the first row\n sheet.showRows(1);\n "
      },
      "showRows ": {
        "!type": "fn(rowIndex: number, numRows: number)",
        "!doc": "Unhides one or more consecutive rows starting at the given index.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n // Unhides the first three rows\n sheet.showRows(1, 3);\n "
      },
      "showSheet": {
        "!type": "fn() -> SpreadsheetApp.Sheet",
        "!doc": "Makes the sheet visible.  Has no effect if the sheet is already visible.\n\n \n \n var sheet = SpreadsheetApp.getActiveSheet();\n sheet.showSheet();\n "
      },
      "sort": {
        "!type": "fn(columnPosition: number) -> SpreadsheetApp.Sheet",
        "!doc": "Sorts a sheet by column, ascending.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n // Sorts the sheet by the first column, ascending\n sheet.sort(1);\n "
      },
      "sort ": {
        "!type": "fn(columnPosition: number, ascending: bool) -> SpreadsheetApp.Sheet",
        "!doc": "Sorts a sheet by column. Takes a parameter to specify ascending or descending.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n // Sorts the sheet by the first column, descending\n sheet.sort(1, false);\n "
      },
      "unhideColumn": {
        "!type": "fn(column: SpreadsheetApp.Range)",
        "!doc": "Unhides the column in the given range.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n // This unhides the first column if it was previously hidden\n var range = sheet.getRange(&quot;A1&quot;);\n sheet.unhideColumn(range);\n "
      },
      "unhideRow": {
        "!type": "fn(row: SpreadsheetApp.Range)",
        "!doc": "Unhides the row in the given range.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n // This unhides the first row if it was previously hidden\n var range = sheet.getRange(&quot;A1&quot;);\n sheet.unhideRow(range);\n "
      },
      "updateChart": {
        "!type": "fn(chart: SpreadsheetApp.EmbeddedChart)",
        "!doc": "Updates the chart on this sheet.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n // This code is going to loop through all the charts and change them to\n // column charts\n var charts = sheet.getCharts();\n for (var i in charts) {\n   var chart = charts[i];\n   var newChart = chart\n       .modify()\n       .setChartType(Charts.ChartType.COLUMN)\n       .build();\n   sheet.updateChart(newChart);\n }\n "
      }
    },
    "SpreadsheetApp.Spreadsheet": {
      "addEditor": {
        "!type": "fn(emailAddress: string) -> SpreadsheetApp.Spreadsheet",
        "!doc": "Adds the given user to the list of editors for the Spreadsheet. If the user was already\n on the list of viewers, this method promotes the user out of the list of viewers."
      },
      "addEditor ": {
        "!type": "fn(user: User) -> SpreadsheetApp.Spreadsheet",
        "!doc": "Adds the given user to the list of editors for the Spreadsheet. If the user was already\n on the list of viewers, this method promotes the user out of the list of viewers."
      },
      "addEditors": {
        "!type": "fn(emailAddresses: [string]) -> SpreadsheetApp.Spreadsheet",
        "!doc": "Adds the given array of users to the list of editors for the Spreadsheet. If any of the\n users were already on the list of viewers, this method promotes them out of the list of\n viewers."
      },
      "addMenu": {
        "!type": "fn(name: string, subMenus: [object])",
        "!doc": "Creates a new menu in the Spreadsheet UI.\n\n Each menu entry runs a user-defined function. Usually, you will want to call it from\n the onOpen function so that the menu is automatically created when the Spreadsheet is loaded.\n\n \n \n // The onOpen function is executed automatically every time a Spreadsheet is loaded\n function onOpen() {\n   var ss = SpreadsheetApp.getActiveSpreadsheet();\n   var menuEntries = [];\n   // When the user clicks on &quot;addMenuExample&quot; then &quot;Menu Entry 1&quot;, the function function1 is\n   // executed.\n   menuEntries.push({name: &quot;Menu Entry 1&quot;, functionName: &quot;function1&quot;});\n   menuEntries.push(null); // line separator\n   menuEntries.push({name: &quot;Menu Entry 2&quot;, functionName: &quot;function2&quot;});\n\n   ss.addMenu(&quot;addMenuExample&quot;, menuEntries);\n }\n "
      },
      "addViewer": {
        "!type": "fn(emailAddress: string) -> SpreadsheetApp.Spreadsheet",
        "!doc": "Adds the given user to the list of viewers for the Spreadsheet. If the user was already\n on the list of editors, this method has no effect."
      },
      "addViewer ": {
        "!type": "fn(user: User) -> SpreadsheetApp.Spreadsheet",
        "!doc": "Adds the given user to the list of viewers for the Spreadsheet. If the user was already\n on the list of editors, this method has no effect."
      },
      "addViewers": {
        "!type": "fn(emailAddresses: [string]) -> SpreadsheetApp.Spreadsheet",
        "!doc": "Adds the given array of users to the list of viewers for the Spreadsheet. If any of the\n users were already on the list of editors, this method has no effect for them."
      },
      "appendRow": {
        "!type": "fn(rowContents: [object]) -> SpreadsheetApp.Sheet",
        "!doc": "Appends a row to the spreadsheet.  This operation is atomic; it prevents issues where\n a user asks for the last row, and then writes to that row, and an intervening mutation\n occurs between getting the last row and writing to it.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n // Appends a new row with 3 columns to the bottom of the\n // spreadsheet containing the values in the array\n sheet.appendRow([&quot;a man&quot;, &quot;a plan&quot;, &quot;panama&quot;]);\n "
      },
      "autoResizeColumn": {
        "!type": "fn(columnPosition: number) -> SpreadsheetApp.Sheet",
        "!doc": "Sets the width of the given column to fit its contents\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n sheet.getRange(&#39;a1&#39;).setValue(&#39;Whenever it is a damp, drizzly November in my soul...&#39;);\n\n // Sets the first column to a width which fits the text\n sheet.autoResizeColumn(1);\n "
      },
      "copy": {
        "!type": "fn(name: string) -> SpreadsheetApp.Spreadsheet",
        "!doc": "Copies the spreadsheet and returns the new one.\n\n \n \n // This code makes a copy of the current spreadsheet and names it appropriately\n var ss = SpreadsheetApp.getActiveSpreadsheet();\n ss.copy(&quot;Copy of &quot; + ss.getName());\n "
      },
      "deleteActiveSheet": {
        "!type": "fn() -> SpreadsheetApp.Sheet",
        "!doc": "Deletes the currently active sheet.\n\n \n \n // The code below deletes the currently active sheet and stores the new active sheet in a\n // variable\n var newSheet = SpreadsheetApp.getActiveSpreadsheet().deleteActiveSheet();\n "
      },
      "deleteColumn": {
        "!type": "fn(columnPosition: number) -> SpreadsheetApp.Sheet",
        "!doc": "Deletes the column at the given column position.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n // Columns start at &quot;1&quot; - this will delete the first column\n sheet.deleteColumn(1);\n "
      },
      "deleteColumns": {
        "!type": "fn(columnPosition: number, howMany: number)",
        "!doc": "Deletes a number of columns starting at the given column position.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n // Columns start at &quot;1&quot; - this will delete the first two columns\n sheet.deleteColumns(1, 2);\n "
      },
      "deleteRow": {
        "!type": "fn(rowPosition: number) -> SpreadsheetApp.Sheet",
        "!doc": "Deletes the row at the given row position.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n // Rows start at &quot;1&quot; - this will delete the first row\n sheet.deleteRow(1);\n "
      },
      "deleteRows": {
        "!type": "fn(rowPosition: number, howMany: number)",
        "!doc": "Deletes a number of rows starting at the given row position.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n // Rows start at &quot;1&quot; - this will delete the first two rows\n sheet.deleteRows(1, 2);\n "
      },
      "deleteSheet": {
        "!type": "fn(sheet: SpreadsheetApp.Sheet)",
        "!doc": "Deletes the specified sheet.\n\n \n \n // The code below deletes the specified sheet.\n var ss = SpreadsheetApp.getActive();\n var sheet = ss.getSheetByName(&#39;My Sheet&#39;);\n ss.deleteSheet(sheet);\n "
      },
      "duplicateActiveSheet": {
        "!type": "fn() -> SpreadsheetApp.Sheet",
        "!doc": "Duplicates the active sheet and makes it the active sheet.\n\n \n \n // The code below makes a duplicate of the active sheet\n SpreadsheetApp.getActiveSpreadsheet().duplicateActiveSheet();\n "
      },
      "getActiveCell": {
        "!type": "fn() -> SpreadsheetApp.Range",
        "!doc": "Returns the active cell in this sheet.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n // Returns the active cell\n var cell = sheet.getActiveCell();\n "
      },
      "getActiveRange": {
        "!type": "fn() -> SpreadsheetApp.Range",
        "!doc": "Returns the active range for the active sheet.\n\n Returns the range of cells that is currently considered active. This generally means the\n range that a user has selected in the active sheet, but in a custom function it refers to\n the cell being actively recalculated.\n\n Note that when called on a SpreadsheetApp it effectively calls getActiveSpreadsheet and\n then getActiveSheet to act on the active Sheet.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n // Returns the active cell\n var range = sheet.getActiveRange();\n "
      },
      "getActiveSheet": {
        "!type": "fn() -> SpreadsheetApp.Sheet",
        "!doc": "Gets the active sheet in a spreadsheet.\n\n The active sheet in a spreadsheet is the sheet that is being displayed in the spreadsheet UI.\n\n \n \n var sheet = SpreadsheetApp.getActiveSpreadsheet().getActiveSheet();\n "
      },
      "getAs": {
        "!type": "fn(contentType: string) -> Blob",
        "!doc": "Return the data inside this object as a blob converted to the specified content type. This\n method adds the appropriate extension to the filename ? for example, \"myfile.pdf\". However, it\n assumes that the part of the filename that follows the last period (if any) is an existing\n extension that should be replaced. Consequently, \"ChristmasList.12.25.2014\" will become\n \"ChristmasList.12.25.pdf\"."
      },
      "getBlob": {
        "!type": "fn() -> Blob",
        "!doc": "Return the data inside this object as a blob."
      },
      "getColumnWidth": {
        "!type": "fn(columnPosition: number) -> number",
        "!doc": "Gets the width in pixels of the given column.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n // Columns start at 1\n Logger.log(sheet.getColumnWidth(1));\n "
      },
      "getDataRange": {
        "!type": "fn() -> SpreadsheetApp.Range",
        "!doc": "Returns a Range corresponding to the dimensions in which data is present.\n\n This is functionally equivalent to creating a Range bounded by A1 and\n (Range.getLastColumn(), Range.getLastRow()).\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n // This represents ALL the data\n var range = sheet.getDataRange();\n var values = range.getValues();\n\n // This logs the spreadsheet in CSV format with a trailing comma\n for (var i = 0; i &lt; values.length; i++) {\n   var row = &quot;&quot;;\n   for (var j = 0; j &lt; values[i].length; j++) {\n     if (values[i][j]) {\n       row = row + values[i][j];\n     }\n     row = row + &quot;,&quot;;\n   }\n   Logger.log(row);\n }\n "
      },
      "getEditors": {
        "!type": "fn() -> [User]",
        "!doc": "Gets the list of editors for this Spreadsheet. If the user who executes the script does\n not have edit access to the Spreadsheet, this method throws an exception."
      },
      "getFormUrl": {
        "!type": "fn() -> string",
        "!doc": "Returns the url for the form attached to the spreadsheet, null if there is no form."
      },
      "getFrozenColumns": {
        "!type": "fn() -> number",
        "!doc": "Returns the number of frozen columns.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n Logger.log(&quot;Number of frozen columns: %s&quot;, sheet.getFrozenColumns());\n "
      },
      "getFrozenRows": {
        "!type": "fn() -> number",
        "!doc": "Returns the number of frozen rows.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n Logger.log(&quot;Number of frozen rows: %s&quot;, sheet.getFrozenRows());\n "
      },
      "getId": {
        "!type": "fn() -> string",
        "!doc": "Gets a unique identifier for this spreadsheet. A spreadsheet ID can be extracted from its URL.\n For example, the spreadsheet ID in the URL\n https://docs.google.com/spreadsheets/d/abc1234567/edit#gid=0 is \"abc1234567\".\n\n \n \n // The code below logs the ID for the active spreadsheet.\n Logger.log(SpreadsheetApp.getActiveSpreadsheet().getId());\n "
      },
      "getLastColumn": {
        "!type": "fn() -> number",
        "!doc": "Returns the position of the last column that has content.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n // This logs the value in the very last cell of this sheet\n var lastRow = sheet.getLastRow();\n var lastColumn = sheet.getLastColumn();\n var lastCell = sheet.getRange(lastRow, lastColumn);\n Logger.log(lastCell.getValue());\n "
      },
      "getLastRow": {
        "!type": "fn() -> number",
        "!doc": "Returns the position of the last row that has content.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n // This logs the value in the very last cell of this sheet\n var lastRow = sheet.getLastRow();\n var lastColumn = sheet.getLastColumn();\n var lastCell = sheet.getRange(lastRow, lastColumn);\n Logger.log(lastCell.getValue());\n "
      },
      "getName": {
        "!type": "fn() -> string",
        "!doc": "Gets the name of the document.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n Logger.log(ss.getName());\n "
      },
      "getNumSheets": {
        "!type": "fn() -> number",
        "!doc": "Returns the number of sheets in this spreadsheet.\n\n \n \n // The code below logs the number of sheets in the active spreadsheet.\n Logger.log(SpreadsheetApp.getActiveSpreadsheet().getNumSheets());\n "
      },
      "getOwner": {
        "!type": "fn() -> User",
        "!doc": "Returns the owner of the document.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var owner = ss.getOwner();\n Logger.log(owner.getEmail());\n "
      },
      "getProtections": {
        "!type": "fn(type: SpreadsheetApp.ProtectionType) -> [SpreadsheetApp.Protection]",
        "!doc": "Gets an array of objects representing all protected ranges or sheets in the spreadsheet.\n\n \n \n // Remove all range protections in the spreadsheet that the user has permission to edit.\n var ss = SpreadsheetApp.getActive();\n var protections = ss.getProtections(SpreadsheetApp.ProtectionType.RANGE);\n for (var i = 0; i &lt; protections.length; i++) {\n   var protection = protections[i];\n   if (protection.canEdit()) {\n     protection.remove();\n   }\n }\n \n\n \n \n // Remove all sheet protections in the spreadsheet that the user has permission to edit.\n var ss = SpreadsheetApp.getActive();\n var protections = ss.getProtections(SpreadsheetApp.ProtectionType.SHEET);\n for (var i = 0; i &lt; protections.length; i++) {\n   var protection = protections[i];\n   if (protection.canEdit()) {\n     protection.remove();\n   }\n }\n "
      },
      "getRange": {
        "!type": "fn(a1Notation: string) -> SpreadsheetApp.Range",
        "!doc": "Returns the range as specified in A1 notation or R1C1 notation.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n // Returns the first cell\n var cell = sheet.getRange(&quot;A1&quot;);\n "
      },
      "getRangeByName": {
        "!type": "fn(name: string) -> SpreadsheetApp.Range",
        "!doc": "Returns a named range, or null if no range with the given name is found. If multiple\n sheets of the spreadsheet use the same range name, specify the sheet name without additional\n quotation marks ??? for example, getRangeByName(&#39;TaxRates&#39;) or\n getRangeByName(&#39;Sheet Name!TaxRates&#39;), but not\n getRangeByName(&#39;&quot;Sheet Name&quot;!TaxRates&#39;).\n\n \n \n // Log the number of columns for the range named &#39;TaxRates&#39; in the active spreadsheet.\n var range = SpreadsheetApp.getActiveSpreadsheet().getRangeByName(&#39;TaxRates&#39;);\n if (range != null) {\n   Logger.log(range.getNumColumns());\n }\n "
      },
      "getRowHeight": {
        "!type": "fn(rowPosition: number) -> number",
        "!doc": "Gets the height in pixels of the given row.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n // Rows start at 1\n Logger.log(sheet.getRowHeight(1));\n "
      },
      "getSheetByName": {
        "!type": "fn(name: string) -> SpreadsheetApp.Sheet",
        "!doc": "Returns a sheet with the given name.\n\n If multiple sheets have the same name, the leftmost one is returned. Returns null if there is\n no sheet with the given name.\n\n \n \n // The code below will log the index of a sheet named &quot;Expenses&quot;\n var sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(&quot;Expenses&quot;);\n if (sheet != null) {\n   Logger.log(sheet.getIndex());\n }\n "
      },
      "getSheetId": {
        "!type": "fn() -> number",
        "!doc": "Returns the ID of the sheet represented by this object.\n\n This is an ID for the sheet that is unique to the spreadsheet. The ID is a monotonically\n increasing integer assigned at sheet creation time that is independent of sheet position.\n This is useful in conjunction with methods such as\n Range.copyFormatToRange(gridId, column, columnEnd, row, rowEnd) that take a gridId\n parameter rather than a Sheet instance.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n Logger.log(sheet.getSheetId());\n "
      },
      "getSheetName": {
        "!type": "fn() -> string",
        "!doc": "Returns the sheet name.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n Logger.log(sheet.getSheetName());\n "
      },
      "getSheetProtection": {
        "!type": "fn() -> SpreadsheetApp.PageProtection",
        "!doc": "Returns a PageProtection instance describing the permissions for the current sheet.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var permissions = sheet.getSheetProtection();\n\n permissions.setProtected(true);\n permissions.addUser(&quot;user@example.com&quot;);\n\n // Logs the users that have access to edit this sheet. Note that this\n // is different from access to the entire spreadsheet - getUsers() will\n // only return users if permissions.isProtected() is set to true.\n var users = permissions.getUsers();\n Logger.log(users);\n "
      },
      "getSheetValues": {
        "!type": "fn(startRow: number, startColumn: number, numRows: number, numColumns: number) -> [[object]]",
        "!doc": "Returns the rectangular grid of values for this range starting at the given\n coordinates. A -1 value given as the row or column position is equivalent to getting the\n very last row or column that has data in the sheet.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n // The two samples below produce the same output\n var values = sheet.getSheetValues(1, 1, 3, 3);\n Logger.log(values);\n\n var range = sheet.getRange(1, 1, 3, 3);\n values = range.getValues();\n Logger.log(values);\n "
      },
      "getSheets": {
        "!type": "fn() -> [SpreadsheetApp.Sheet]",
        "!doc": "Gets all the sheets in this spreadsheet.\n\n \n \n // The code below will log the name of the second sheet\n var sheets = SpreadsheetApp.getActiveSpreadsheet().getSheets();\n if (sheets.length &gt; 1) {\n   Logger.log(sheets[1].getName());\n }\n "
      },
      "getSpreadsheetLocale": {
        "!type": "fn() -> string",
        "!doc": "Gets the spreadsheet locale."
      },
      "getSpreadsheetTimeZone": {
        "!type": "fn() -> string",
        "!doc": "Gets the time zone for the spreadsheet."
      },
      "getUrl": {
        "!type": "fn() -> string",
        "!doc": "Returns the url for the given spreadsheet.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n Logger.log(ss.getUrl());\n "
      },
      "getViewers": {
        "!type": "fn() -> [User]",
        "!doc": "Gets the list of viewers and commenters for this Spreadsheet.  If the user who executes\n the script does not have edit access to the Spreadsheet, this method throws an exception."
      },
      "hideColumn": {
        "!type": "fn(column: SpreadsheetApp.Range)",
        "!doc": "Hides the columns in the given range.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n // This hides the first column\n var range = sheet.getRange(&quot;A1&quot;);\n sheet.hideColumn(range);\n "
      },
      "hideRow": {
        "!type": "fn(row: SpreadsheetApp.Range)",
        "!doc": "Hides the rows in the given range.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n // This hides the first row\n var range = sheet.getRange(&quot;A1&quot;);\n sheet.hideRow(range);\n "
      },
      "insertColumnAfter": {
        "!type": "fn(afterPosition: number) -> SpreadsheetApp.Sheet",
        "!doc": "Inserts a column after the given column position.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n // This inserts a column after the first column position\n sheet.insertColumnAfter(1);\n "
      },
      "insertColumnBefore": {
        "!type": "fn(beforePosition: number) -> SpreadsheetApp.Sheet",
        "!doc": "Inserts a column before the given column position.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n // This inserts a column in the first column position\n sheet.insertColumnBefore(1);\n "
      },
      "insertColumnsAfter": {
        "!type": "fn(afterPosition: number, howMany: number) -> SpreadsheetApp.Sheet",
        "!doc": "Inserts a number of columns after the given column position.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n // This inserts a column in the second column position\n sheet.insertColumnsAfter(1);\n "
      },
      "insertColumnsBefore": {
        "!type": "fn(beforePosition: number, howMany: number) -> SpreadsheetApp.Sheet",
        "!doc": "Inserts a number of columns before the given column position.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n // This inserts five columns before the first column\n sheet.insertColumnsBefore(1, 5);\n "
      },
      "insertImage": {
        "!type": "fn(blob: Blob, column: number, row: number)",
        "!doc": "Inserts a Blob as an image in the document at a given row and column. The image size\n is retrieved from the blob contents.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var blob = Utilities.newBlob(binaryData, &#39;image/png&#39;, &#39;MyImageName&#39;);\n sheet.insertImage(blob, 1, 1);\n "
      },
      "insertImage ": {
        "!type": "fn(blob: Blob, column: number, row: number, offsetX: number, offsetY: number)",
        "!doc": "Inserts a Blob as an image in the document at a given row and column, with a pixel\n offset. The image size is retrieved from the blob contents.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var blob = Utilities.newBlob(binaryData, &#39;image/png&#39;, &#39;MyImageName&#39;);\n sheet.insertImage(blob, 1, 1, 10, 10);\n "
      },
      "insertImage  ": {
        "!type": "fn(url: string, column: number, row: number)",
        "!doc": "Inserts an image in the document at a given row and column.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n sheet.insertImage(&quot;https://www.google.com/images/srpr/logo3w.png&quot;, 1, 1);\n "
      },
      "insertImage   ": {
        "!type": "fn(url: string, column: number, row: number, offsetX: number, offsetY: number)",
        "!doc": "Inserts an image in the document at a given row and column, with a pixel offset.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n sheet.insertImage(&quot;https://www.google.com/images/srpr/logo3w.png&quot;, 1, 1, 10, 10);\n "
      },
      "insertRowAfter": {
        "!type": "fn(afterPosition: number) -> SpreadsheetApp.Sheet",
        "!doc": "Inserts a row after the given row position.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n // This inserts a row after the first row position\n sheet.insertRowAfter(1);\n "
      },
      "insertRowBefore": {
        "!type": "fn(beforePosition: number) -> SpreadsheetApp.Sheet",
        "!doc": "Inserts a row before the given row position.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n // This inserts a row before the first row position\n sheet.insertRowBefore(1);\n "
      },
      "insertRowsAfter": {
        "!type": "fn(afterPosition: number, howMany: number) -> SpreadsheetApp.Sheet",
        "!doc": "Inserts a number of rows after the given row position.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n // This inserts five rows after the first row\n sheet.insertRowsAfter(1, 5);\n "
      },
      "insertRowsBefore": {
        "!type": "fn(beforePosition: number, howMany: number) -> SpreadsheetApp.Sheet",
        "!doc": "Inserts a number of rows before the given row position.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n // This inserts five rows before the first row\n sheet.insertRowsBefore(1, 5);\n "
      },
      "insertSheet": {
        "!type": "fn() -> SpreadsheetApp.Sheet",
        "!doc": "Inserts a new sheet in the spreadsheet, with a default name.\n\n As a side effect, it makes it the active sheet.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n ss.insertSheet();\n "
      },
      "insertSheet ": {
        "!type": "fn(sheetIndex: number) -> SpreadsheetApp.Sheet",
        "!doc": "Inserts a new sheet in the spreadsheet at the given index.\n\n As a side effect, it makes it the active sheet.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n ss.insertSheet(1);\n "
      },
      "insertSheet  ": {
        "!type": "fn(sheetIndex: number, options: object) -> SpreadsheetApp.Sheet",
        "!doc": "Inserts a new sheet in the spreadsheet at the given index and uses optional advanced arguments.\n\n As a side effect, it makes it the active sheet.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var templateSheet = ss.getSheetByName(&#39;Sales&#39;);\n ss.insertSheet(1, {template: templateSheet});\n "
      },
      "insertSheet   ": {
        "!type": "fn(options: object) -> SpreadsheetApp.Sheet",
        "!doc": "Inserts a new sheet in the spreadsheet, with a default name and uses optional advanced\n arguments.\n\n As a side effect, it makes it the active sheet.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var templateSheet = ss.getSheetByName(&#39;Sales&#39;);\n ss.insertSheet({template: templateSheet});\n "
      },
      "insertSheet    ": {
        "!type": "fn(sheetName: string) -> SpreadsheetApp.Sheet",
        "!doc": "Inserts a new sheet in the spreadsheet with the given name.\n\n As a side effect, it makes it the active sheet.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n ss.insertSheet(&#39;My New Sheet&#39;);\n "
      },
      "insertSheet     ": {
        "!type": "fn(sheetName: string, sheetIndex: number) -> SpreadsheetApp.Sheet",
        "!doc": "Inserts a new sheet in the spreadsheet with the given name\n at the given index.\n\n As a side effect, it makes it the active sheet.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n ss.insertSheet(&#39;My New Sheet&#39;, 1);\n "
      },
      "insertSheet      ": {
        "!type": "fn(sheetName: string, sheetIndex: number, options: object) -> SpreadsheetApp.Sheet",
        "!doc": "Inserts a new sheet in the spreadsheet with the given name at the given index and uses optional\n advanced arguments.\n\n As a side effect, it makes it the active sheet.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var templateSheet = ss.getSheetByName(&#39;Sales&#39;);\n ss.insertSheet(&#39;My New Sheet&#39;, 1, {template: templateSheet});\n "
      },
      "insertSheet       ": {
        "!type": "fn(sheetName: string, options: object) -> SpreadsheetApp.Sheet",
        "!doc": "Inserts a new sheet in the spreadsheet with the given name and uses optional advanced\n arguments.\n\n As a side effect, it makes it the active sheet.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var templateSheet = ss.getSheetByName(&#39;Sales&#39;);\n ss.insertSheet(&#39;My New Sheet&#39;, {template: templateSheet});\n "
      },
      "isAnonymousView": {
        "!type": "fn() -> bool",
        "!doc": "Indicates whether the document allows anonymous viewing. As this is no longer supported in the\n new version of Google Sheets, use\n File.getSharingAccess() and\n File.getSharingPermission() instead.\n\n \n \n // Determine if the document allows anonymous viewing via the Drive API.\n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var file = DriveApp.getFileById(ss.getId());\n var access = file.getSharingAccess();\n var permission = file.getSharingPermission();\n var isAnonymousAccess =\n     access == DriveApp.Access.ANYONE || access == DriveApp.Access.ANYONE_WITH_LINK;\n var isAnonymousEdit = isAnonymousAccess &amp;&amp; permission != DriveApp.Permission.NONE;\n "
      },
      "isAnonymousWrite": {
        "!type": "fn() -> bool",
        "!doc": "Indicates whether the document allows edits from anonymous users. As this is no longer\n supported in the\n new version of Google Sheets, use\n File.getSharingAccess() and\n File.getSharingPermission() instead.\n\n \n \n // Determine if the document allow anonymous edits via the Drive API.\n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var file = DriveApp.getFileById(ss.getId());\n var access = file.getSharingAccess();\n var permission = file.getSharingPermission();\n var isAnonymousAccess =\n     access == DriveApp.Access.ANYONE || access == DriveApp.Access.ANYONE_WITH_LINK;\n var isAnonymousEdit = isAnonymousAccess &amp;&amp; permission == DriveApp.Permission.EDIT;\n "
      },
      "moveActiveSheet": {
        "!type": "fn(pos: number)",
        "!doc": "Moves the active sheet to the given position in the list of sheets.\n Throws an exception if the position is negative or greater than the\n number of sheets.\n\n \n \n // This example assumes there are two sheets in the current\n // active spreadsheet: one named &quot;first&quot;, and another named &quot;second&quot;,\n // and that the current active sheet (first) is in position 1\n var spreadsheet = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = spreadsheet.getSheetByName(&quot;first&quot;);\n\n // This should output &#39;Current index of sheet: 1&#39;\n Logger.log(&quot;Current index of sheet: %s&quot;, sheet.getIndex());\n\n spreadsheet.moveActiveSheet(2);\n\n // This should output &#39;New index of sheet: 2&#39;\n Logger.log(&quot;New index of sheet: %s&quot;, sheet.getIndex());\n "
      },
      "removeEditor": {
        "!type": "fn(emailAddress: string) -> SpreadsheetApp.Spreadsheet",
        "!doc": "Removes the given user from the list of editors for the Spreadsheet. This method does not\n block users from accessing the Spreadsheet if they belong to a class of users who have\n general access ? for example, if the Spreadsheet is shared with the user's entire domain."
      },
      "removeEditor ": {
        "!type": "fn(user: User) -> SpreadsheetApp.Spreadsheet",
        "!doc": "Removes the given user from the list of editors for the Spreadsheet. This method does not\n block users from accessing the Spreadsheet if they belong to a class of users who have\n general access ? for example, if the Spreadsheet is shared with the user's entire domain."
      },
      "removeMenu": {
        "!type": "fn(name: string)",
        "!doc": "Removes a menu that was added by addMenu(name, subMenus). The name argument\n should have the same value as the corresponding call to addMenu(name, subMenus).\n\n \n \n // The onOpen function is executed automatically every time a Spreadsheet is loaded\n function onOpen() {\n   var ss = SpreadsheetApp.getActiveSpreadsheet();\n   ss.addMenu(&quot;badMenu&quot;, [{name: &quot;remove bad menu&quot;, functionName: &quot;removeBadMenu&quot;},\n                                        {name: &quot;foo&quot;, functionName: &quot;foo&quot;}]);\n }\n function removeBadMenu() {\n   var ss = SpreadsheetApp.getActiveSpreadsheet();\n   ss.removeMenu(&quot;badMenu&quot;);//name must match the name we used when added the menu\n }\n function foo(){\n //do nothing\n }\n "
      },
      "removeNamedRange": {
        "!type": "fn(name: string)",
        "!doc": "Deletes a named range with the given name. Throws an exception if no range with the given name\n is found in the spreadsheet.\n\n \n // The code below will create a new named range &quot;foo&quot;, and then remove it.\n var ss = SpreadsheetApp.getActiveSpreadsheet();\n ss.setNamedRange(&quot;foo&quot;, ss.getActiveRange());\n ss.removeNamedRange(&quot;foo&quot;);\n "
      },
      "removeViewer": {
        "!type": "fn(emailAddress: string) -> SpreadsheetApp.Spreadsheet",
        "!doc": "Removes the given user from the list of viewers and commenters for the Spreadsheet.  This\n method has no effect if the user is an editor, not a viewer or commenter. This method also does\n not block users from accessing the Spreadsheet if they belong to a class of users who\n have general access ? for example, if the Spreadsheet is shared with the user's entire\n domain."
      },
      "removeViewer ": {
        "!type": "fn(user: User) -> SpreadsheetApp.Spreadsheet",
        "!doc": "Removes the given user from the list of viewers and commenters for the Spreadsheet.  This\n method has no effect if the user is an editor, not a viewer. This method also does not block\n users from accessing the Spreadsheet if they belong to a class of users who have general\n access ? for example, if the Spreadsheet is shared with the user's entire domain."
      },
      "rename": {
        "!type": "fn(newName: string)",
        "!doc": "Renames the document.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n ss.rename(&quot;This is the new name&quot;);\n "
      },
      "renameActiveSheet": {
        "!type": "fn(newName: string)",
        "!doc": "Renames the current active sheet to the given new name.\n\n \n \n // The code below will rename the active sheet to &quot;Hello world&quot;\n SpreadsheetApp.getActiveSpreadsheet().renameActiveSheet(&quot;Hello world&quot;);\n "
      },
      "setActiveRange": {
        "!type": "fn(range: SpreadsheetApp.Range) -> SpreadsheetApp.Range",
        "!doc": "Sets the active range for the active sheet.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var range = sheet.getRange(&quot;A1:D4&quot;);\n sheet.setActiveRange(range);\n "
      },
      "setActiveSelection": {
        "!type": "fn(range: SpreadsheetApp.Range) -> SpreadsheetApp.Range",
        "!doc": "Sets the active selection region for this sheet.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var range = sheet.getRange(&quot;A1:D4&quot;);\n sheet.setActiveSelection(range);\n "
      },
      "setActiveSelection ": {
        "!type": "fn(a1Notation: string) -> SpreadsheetApp.Range",
        "!doc": "Sets the active selection, as specified in A1 notation or R1C1 notation.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n sheet.setActiveSelection(&quot;A1:D4&quot;);\n "
      },
      "setActiveSheet": {
        "!type": "fn(sheet: SpreadsheetApp.Sheet) -> SpreadsheetApp.Sheet",
        "!doc": "Sets the given sheet to be the active sheet in the spreadsheet.\n\n The spreadsheet UI will display the chosen sheet unless the sheet belongs to a different\n spreadsheet.\n\n \n \n // The code below will make the first sheet active in the active workbook\n var ss = SpreadsheetApp.getActiveSpreadsheet();\n ss.setActiveSheet(ss.getSheets()[0]);\n "
      },
      "setAnonymousAccess": {
        "!type": "fn(anonymousReadAllowed: bool, anonymousWriteAllowed: bool)",
        "!doc": "Sets the document's policy on anonymous reading and writing. As this is no longer supported in\n the new version of Google Sheets,\n use File.setSharing(accessType, permissionType) as an alternative.\n\n \n \n // Set the document&#39;s policy on anonymous reading and writing via the Drive API.\n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var file = DriveApp.getFileById(ss.getId());\n\n // Set anonymous read.\n file.setSharing(DriveApi.Access.ANYONE, DriveApi.Permission.VIEW);\n\n // Set anonymous write.\n file.setSharing(DriveApi.Access.ANYONE, DriveApi.Permission.EDIT);\n\n // Disable anonymous access.\n file.setSharing(DriveApi.Access.PRIVATE, file.getSharingPermission());\n "
      },
      "setColumnWidth": {
        "!type": "fn(columnPosition: number, width: number) -> SpreadsheetApp.Sheet",
        "!doc": "Sets the width of the given column in pixels.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n // Sets the first column to a width of 200 pixels\n sheet.setColumnWidth(1, 200);\n "
      },
      "setFrozenColumns": {
        "!type": "fn(columns: number)",
        "!doc": "Freezes the given number of columns. If zero, no columns are frozen.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n // Freezes the first column\n sheet.setFrozenColumns(1);\n "
      },
      "setFrozenRows": {
        "!type": "fn(rows: number)",
        "!doc": "Freezes the given number of rows. If zero, no rows are frozen.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n // Freezes the first row\n sheet.setFrozenRows(1);\n "
      },
      "setNamedRange": {
        "!type": "fn(name: string, range: SpreadsheetApp.Range)",
        "!doc": "Names a range.\n\n \n \n // The code below will create a new named range &quot;TaxRates&quot; in the active spreadsheet\n var ss = SpreadsheetApp.getActiveSpreadsheet();\n ss.setNamedRange(&quot;TaxRates&quot;, SpreadsheetApp.getActiveRange());\n "
      },
      "setRowHeight": {
        "!type": "fn(rowPosition: number, height: number) -> SpreadsheetApp.Sheet",
        "!doc": "Sets the row height of the given row in pixels.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n // Sets the first row to a height of 200 pixels\n sheet.setRowHeight(1, 200);\n "
      },
      "setSheetProtection": {
        "!type": "fn(permissions: SpreadsheetApp.PageProtection)",
        "!doc": "Sets the permissions for the current sheet.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n var permissions = sheet.getSheetProtection();\n\n // This copies the permissions on the first sheet to the second sheet\n var sheetToClonePermissionsTo = ss.getSheets()[1];\n sheetToClonePermissionsTo.setSheetProtection(permissions);\n "
      },
      "setSpreadsheetLocale": {
        "!type": "fn(locale: string)",
        "!doc": "Sets the spreadsheet locale."
      },
      "setSpreadsheetTimeZone": {
        "!type": "fn(timezone: string)",
        "!doc": "Sets the time zone for the spreadsheet."
      },
      "show": {
        "!type": "fn(userInterface: object)",
        "!doc": "Displays a custom user interface component in a dialog centered in the user's browser's\n viewport. The server-side script's execution will not be suspended. To communicate\n with the server side, the user interface component must make asynchronous callbacks to the\n server-side script.\n\n If the server-side script previously displayed a dialog that has not yet been dismissed,\n then the existing dialog will be replaced with the newly requested dialog's user interface.\n\n The following code snippet displays a simple\n HtmlService application in a dialog with\n the specified title, height, and width:\n\n \n \n var htmlApp = HtmlService\n     .createHtmlOutput(&#39;&lt;p&gt;A change of speed, a change of style...&lt;/p&gt;&#39;)\n     .setSandboxMode(HtmlService.SandboxMode.IFRAME)\n     .setTitle(&#39;My HtmlService Application&#39;)\n     .setWidth(250)\n     .setHeight(300);\n\n SpreadsheetApp.getActiveSpreadsheet().show(htmlApp);\n\n // The script resumes execution immediately after showing the dialog.\n \n\n Likewise, the following code snippet displays a simple\n UiApp application in a dialog with the\n specified title, height, and width:\n\n \n \n var uiApp = UiApp.createApplication()\n     .setTitle(&#39;My UiApp Application&#39;)\n     .setWidth(250)\n     .setHeight(300);\n uiApp.add(uiApp.createLabel(&#39;The photograph on the dashboard taken years ago...&#39;));\n\n SpreadsheetApp.getActiveSpreadsheet().show(uiApp);\n\n // The script resumes execution immediately after showing the dialog.\n "
      },
      "sort": {
        "!type": "fn(columnPosition: number) -> SpreadsheetApp.Sheet",
        "!doc": "Sorts a sheet by column, ascending.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n // Sorts the sheet by the first column, ascending\n sheet.sort(1);\n "
      },
      "sort ": {
        "!type": "fn(columnPosition: number, ascending: bool) -> SpreadsheetApp.Sheet",
        "!doc": "Sorts a sheet by column. Takes a parameter to specify ascending or descending.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n // Sorts the sheet by the first column, descending\n sheet.sort(1, false);\n "
      },
      "toast": {
        "!type": "fn(msg: string)",
        "!doc": "Shows a popup window in the lower right corner of the spreadsheet with the given message.\n\n \n \n // Show a popup with the message &quot;Task started&quot;.\n SpreadsheetApp.getActiveSpreadsheet().toast(&#39;Task started&#39;);\n "
      },
      "toast ": {
        "!type": "fn(msg: string, title: string)",
        "!doc": "Shows a popup window in the lower right corner of the spreadsheet with the given message and\n title.\n\n \n \n // Show a popup with the title &quot;Status&quot; and the message &quot;Task started&quot;.\n SpreadsheetApp.getActiveSpreadsheet().toast(&#39;Task started&#39;, &#39;Status&#39;);\n "
      },
      "toast  ": {
        "!type": "fn(msg: string, title: string, timeoutSeconds: number)",
        "!doc": "Shows a popup window in the lower right corner of the spreadsheet with the given title and\n message, that stays visible for a certain length of time.\n\n \n \n // Show a 3-second popup with the title &quot;Status&quot; and the message &quot;Task started&quot;.\n SpreadsheetApp.getActiveSpreadsheet().toast(&#39;Task started&#39;, &#39;Status&#39;, 3);\n "
      },
      "unhideColumn": {
        "!type": "fn(column: SpreadsheetApp.Range)",
        "!doc": "Unhides the column in the given range.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n // This unhides the first column if it was previously hidden\n var range = sheet.getRange(&quot;A1&quot;);\n sheet.unhideColumn(range);\n "
      },
      "unhideRow": {
        "!type": "fn(row: SpreadsheetApp.Range)",
        "!doc": "Unhides the row in the given range.\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var sheet = ss.getSheets()[0];\n\n // This unhides the first row if it was previously hidden\n var range = sheet.getRange(&quot;A1&quot;);\n sheet.unhideRow(range);\n "
      },
      "updateMenu": {
        "!type": "fn(name: string, subMenus: [object])",
        "!doc": "Updates a menu that was added by addMenu(name, subMenus). Works exactly like\n addMenu(name, subMenus).\n\n \n \n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var menuEntries = [];\n menuEntries.push({name: &quot;Lone Menu Entry&quot;, functionName: &quot;function1&quot;});\n ss.updateMenu(&quot;addMenuExample&quot;, menuEntries);\n "
      }
    }
  },
  "DataTable": {},
  "ColumnType": {
    "DATE": {
      "!type": "ColumnType",
      "!doc": "Corresponds to date values."
    },
    "NUMBER": {
      "!type": "ColumnType",
      "!doc": "Corresponds to number values."
    },
    "STRING": {
      "!type": "ColumnType",
      "!doc": "Corresponds to string values."
    }
  },
  "User": {
    "getEmail": {
      "!type": "fn() -> string",
      "!doc": "Gets the user's email address, if available. If security policies do not allow access to the\n user's email address, this method returns a blank string. The circumstances in which the email\n address is available vary: for example, the user's email address is not available in any\n context that allows a script to run without that user's authorization, like a simple\n onOpen(e) or onEdit(e) trigger, a custom function in Google Sheets, or a web\n app deployed to \"execute as me\" (that is, authorized by the developer instead of the user).\n However, these restrictions generally do not apply if the developer and the user belong to the\n same Google Apps for Business domain.\n\n \n // Log the email address of the person running the script.\n Logger.log(Session.getActiveUser().getEmail());\n "
    },
    "getUserLoginId": {
      "!type": "fn() -> string",
      "!doc": "Gets the user's email address.\n\n \n // Log the email address of the person running the script.\n Logger.log(Session.getActiveUser().getUserLoginId());\n "
    }
  },
  "DataTableSource": {
    "getDataTable": {
      "!type": "fn() -> DataTable",
      "!doc": "Return the data inside this object as a DataTable."
    }
  },
  "Charts": {
    "ChartType": {
      "!type": "Charts.ChartType",
      "!doc": "An enumeration of chart types supported by the Charts service."
    },
    "ColumnType": {
      "!type": "ColumnType",
      "!doc": "An enumeration of the valid data types for columns in a DataTable."
    },
    "CurveStyle": {
      "!type": "Charts.CurveStyle",
      "!doc": "An enumeration of the styles for curves in a chart."
    },
    "MatchType": {
      "!type": "Charts.MatchType",
      "!doc": "An enumeration of how a string value should be matched."
    },
    "Orientation": {
      "!type": "Charts.Orientation",
      "!doc": "An enumeration of the orientation of an object."
    },
    "PickerValuesLayout": {
      "!type": "Charts.PickerValuesLayout",
      "!doc": "An enumeration of how to display selected values in a picker widget."
    },
    "PointStyle": {
      "!type": "Charts.PointStyle",
      "!doc": "An enumeration of the styles of points in a line."
    },
    "Position": {
      "!type": "Charts.Position",
      "!doc": "An enumeration of legend positions within a chart."
    },
    "newAreaChart": {
      "!type": "fn() -> Charts.AreaChartBuilder",
      "!doc": "Starts building an area chart, as described in the Google Chart\n Tools documentation."
    },
    "newBarChart": {
      "!type": "fn() -> Charts.BarChartBuilder",
      "!doc": "Starts building a bar chart, as described in the Google Chart\n Tools documentation."
    },
    "newCategoryFilter": {
      "!type": "fn() -> Charts.CategoryFilterBuilder",
      "!doc": "Starts building a category filter control, as described in the \n Google Chart Tools documentation."
    },
    "newColumnChart": {
      "!type": "fn() -> Charts.ColumnChartBuilder",
      "!doc": "Starts building a column chart, as described in the Google Chart\n Tools documentation."
    },
    "newDashboardPanel": {
      "!type": "fn() -> Charts.DashboardPanelBuilder",
      "!doc": "Starts building a dashboard panel, as described in the \n Google Chart Tools documentation."
    },
    "newDataTable": {
      "!type": "fn() -> DataTableBuilder",
      "!doc": "Creates an empty data table, which can have its values set manually.\n \n Data tables hold the data for all chart types."
    },
    "newDataViewDefinition": {
      "!type": "fn() -> Charts.DataViewDefinitionBuilder",
      "!doc": "Creates a new data view definition.\n \n Use setters to define the different properties of the data view."
    },
    "newLineChart": {
      "!type": "fn() -> Charts.LineChartBuilder",
      "!doc": "Starts building a line chart, as described in the Google Chart\n Tools documentation."
    },
    "newNumberRangeFilter": {
      "!type": "fn() -> Charts.NumberRangeFilterBuilder",
      "!doc": "Starts building a number range filter control, as described in the \n Google Chart Tools documentation."
    },
    "newPieChart": {
      "!type": "fn() -> Charts.PieChartBuilder",
      "!doc": "Starts building a pie chart, as described in the Google Chart\n Tools documentation."
    },
    "newScatterChart": {
      "!type": "fn() -> Charts.ScatterChartBuilder",
      "!doc": "Starts building a scatter chart, as described in the Google Chart\n Tools documentation."
    },
    "newStringFilter": {
      "!type": "fn() -> Charts.StringFilterBuilder",
      "!doc": "Starts building a string filter control, as described in the \n Google Chart Tools documentation."
    },
    "newTableChart": {
      "!type": "fn() -> Charts.TableChartBuilder",
      "!doc": "Starts building a table chart, as described in the Google Chart\n Tools documentation."
    },
    "newTextStyle": {
      "!type": "fn() -> Charts.TextStyleBuilder",
      "!doc": "Creates a new text style builder.\n \n To change the default values, use the setter functions."
    }
  },
  "UrlFetchApp": {
    "fetch": {
      "!type": "fn(url: string) -> UrlFetchApp.HTTPResponse",
      "!doc": "Makes a request to fetch a URL.\n\n This works over HTTP as well as HTTPS.\n\n \n \n // The code below logs the HTML code of the Google home page.\n var response = UrlFetchApp.fetch(&quot;http://www.google.com/&quot;);\n Logger.log(response.getContentText());\n "
    },
    "fetch ": {
      "!type": "fn(url: string, params: object) -> UrlFetchApp.HTTPResponse",
      "!doc": "Makes a request to fetch a URL using optional advanced parameters.\n\n This works over HTTP as well as HTTPS.\n\n \n \n // The code below logs the HTML code of the Google home page.\n var response = UrlFetchApp.fetch(&quot;http://www.google.com/&quot;);\n Logger.log(response.getContentText());\n \n\n \n \n // This sample pulls in your tweets from Twitter and puts them in a spreadsheet.\n //\n //  First: set up Script Properties &quot;twitterConsumerKey&quot; and\n // &quot;twitterConsumerSecret&quot; with values provided to you by Twitter.\n\n var fields = {&#39;in_reply_to_screen_name&#39;:true,&#39;created_at&#39;:true,&#39;text&#39;:true};\n\n function tweet() {\n   // Setup OAuthServiceConfig\n   var oAuthConfig = UrlFetchApp.addOAuthService(&quot;twitter&quot;);\n   oAuthConfig.setAccessTokenUrl(&quot;https://api.twitter.com/oauth/access_token&quot;);\n   oAuthConfig.setRequestTokenUrl(&quot;https://api.twitter.com/oauth/request_token&quot;);\n   oAuthConfig.setAuthorizationUrl(&quot;https://api.twitter.com/oauth/authorize&quot;);\n   oAuthConfig.setConsumerKey(ScriptProperties.getProperty(&quot;twitterConsumerKey&quot;));\n   oAuthConfig.setConsumerSecret(ScriptProperties.getProperty(&quot;twitterConsumerSecret&quot;));\n\n   // Setup optional parameters to point request at OAuthConfigService.  The &quot;twitter&quot;\n   // value matches the argument to &quot;addOAuthService&quot; above.\n   var options =\n     {\n       &quot;oAuthServiceName&quot; : &quot;twitter&quot;,\n       &quot;oAuthUseToken&quot; : &quot;always&quot;\n     };\n\n   var result = UrlFetchApp.fetch(&quot;https://api.twitter.com/1.1/statuses/user_timeline.json&quot;,\n       options);\n   var o  = Utilities.jsonParse(result.getContentText());\n   var doc = SpreadsheetApp.getActiveSpreadsheet();\n   var cell = doc.getRange(&#39;a1&#39;);\n   var index = 0;\n   for (var i in o) {\n     var row = o[i];\n     var col = 0;\n     for (var j in row) {\n       if (fields[j]) {\n         cell.offset(index, col).setValue(row[j]);\n         col++;\n       }\n     }\n     index++;\n   }\n }\n \n\n \n \n // This sample sends POST payload data in the style of an HTML form, including\n // a file.\n\n function sendHttpPost() {\n\n   // Download a file now (GET), so we can upload it in the HTTP POST below.\n   var response = UrlFetchApp.fetch(&quot;http://example.com/image_to_download.jpg&quot;);\n   var fileBlob = response.getBlob();\n\n   var payload =\n   {\n     &quot;fieldOne&quot; : &quot;value for field one&quot;,\n     &quot;fieldTwo&quot; : &quot;value for field two&quot;,\n     &quot;fileAttachment&quot;: fileBlob\n   };\n\n   // Because payload is a JavaScript object, it will be interpreted as\n   // an HTML form. (We do not need to specify contentType; it will\n   // automatically default to either &#39;application/x-www-form-urlencoded&#39;\n   // or &#39;multipart/form-data&#39;)\n\n   var options =\n   {\n     &quot;method&quot; : &quot;post&quot;,\n     &quot;payload&quot; : payload\n   };\n\n   UrlFetchApp.fetch(&quot;http://example.com/upload_form.cgi&quot;, options);\n }\n "
    },
    "getRequest": {
      "!type": "fn(url: string) -> object",
      "!doc": "Returns the request that would be made if the operation was invoked.\n\n This method does not actually issue the request.\n\n \n \n // The code below logs the value for every key of the returned map.\n var response = UrlFetchApp.getRequest(&quot;http://www.google.com/&quot;);\n for(i in response) {\n   Logger.log(i + &quot;: &quot; + response[i]);\n }\n "
    },
    "getRequest ": {
      "!type": "fn(url: string, params: object) -> object",
      "!doc": "Returns the request that would be made if the operation were invoked.\n\n This method does not actually issue the request.\n\n \n \n // The code below logs the value for every key of the returned map.\n var fields = {&#39;in_reply_to_screen_name&#39;: true, &#39;created_at&#39;: true, &#39;text&#39;: true};\n\n function tweet() {\n   // Setup OAuthServiceConfig\n   var oAuthConfig = UrlFetchApp.addOAuthService(&quot;twitter&quot;);\n   oAuthConfig.setAccessTokenUrl(&quot;https://api.twitter.com/oauth/access_token&quot;);\n   oAuthConfig.setRequestTokenUrl(&quot;https://api.twitter.com/oauth/request_token&quot;);\n   oAuthConfig.setAuthorizationUrl(&quot;https://api.twitter.com/oauth/authorize&quot;);\n   oAuthConfig.setConsumerKey(ScriptProperties.getProperty(&quot;twitterConsumerKey&quot;));\n   oAuthConfig.setConsumerSecret(ScriptProperties.getProperty(&quot;twitterConsumerSecret&quot;));\n\n   // Setup optional parameters to point request at OAuthConfigService.  The &quot;twitter&quot;\n   // value matches the argument to &quot;addOAuthService&quot; above.\n   var options =\n     {\n       &quot;oAuthServiceName&quot; : &quot;twitter&quot;,\n       &quot;oAuthUseToken&quot; : &quot;always&quot;\n     };\n\n   var result = UrlFetchApp.getRequest(&quot;https://api.twitter.com/1.1/statuses/user_timeline.json&quot;,\n       options);\n   for(i in result) {\n     Logger.log(i + &quot;: &quot; + result[i]);\n   }\n }\n "
    }
  },
  "JSON": {
    "parse": {
      "!type": "fn(text: string) -> object"
    },
    "parse ": {
      "!type": "fn(text: string, reviver: Function) -> object"
    },
    "stringify": {
      "!type": "fn(value: object) -> string"
    },
    "stringify ": {
      "!type": "fn(value: object, replacer: Function) -> string"
    },
    "stringify  ": {
      "!type": "fn(value: object, replacer: Function, space: object) -> string"
    }
  },
  "Logger": {
    "clear": {
      "!type": "fn()",
      "!doc": "Clears the log."
    },
    "getLog": {
      "!type": "fn() -> string",
      "!doc": "Returns a complete list of messages in the current log. This method can be used to save or\n email the entire log output generated during script execution.\n\n \n // Generate a log, then email it to the person who ran the script.\n var files = DriveApp.getFiles();\n while (files.hasNext()) {\n   Logger.log(files.next().getName());\n }\n var recipient = Session.getActiveUser().getEmail();\n var subject = 'A list of files in your Google Drive';\n var body = Logger.getLog();\n MailApp.sendEmail(recipient, subject, body);\n "
    },
    "log": {
      "!type": "fn(data: object) -> Logger",
      "!doc": "Writes the string to the logging console. To view the logged output, select\n View > Show logs. This can be very useful for debugging scripts."
    },
    "log ": {
      "!type": "fn(format: string, values: Object...) -> Logger",
      "!doc": "Writes a formatted string to the logging console, using the format and values provided. The\n string can include multiple %s placeholders, which are replaced with corresponding\n values from the list of arguments, converted to strings.\n\n \n // Log the number of Google Groups you belong to.\n var groups = GroupsApp.getGroups();\n Logger.log('You are a member of %s Google Groups.', groups.length);\n "
    }
  },
  "Math": {
    "E": {
      "!type": "number"
    },
    "LN10": {
      "!type": "number"
    },
    "LN2": {
      "!type": "number"
    },
    "LOG10E": {
      "!type": "number"
    },
    "LOG2E": {
      "!type": "number"
    },
    "PI": {
      "!type": "number"
    },
    "SQRT1_2": {
      "!type": "number"
    },
    "SQRT_2": {
      "!type": "number"
    },
    "abs": {
      "!type": "fn(x: number) -> number"
    },
    "acos": {
      "!type": "fn(x: number) -> number"
    },
    "asin": {
      "!type": "fn(x: number) -> number"
    },
    "atan": {
      "!type": "fn(x: number) -> number"
    },
    "atan2": {
      "!type": "fn(y: number, x: number) -> number"
    },
    "ceil": {
      "!type": "fn(x: number) -> number"
    },
    "cos": {
      "!type": "fn(x: number) -> number"
    },
    "exp": {
      "!type": "fn(x: number) -> number"
    },
    "floor": {
      "!type": "fn(x: number) -> number"
    },
    "log": {
      "!type": "fn(x: number) -> number"
    },
    "max": {
      "!type": "fn(values: Number...) -> number"
    },
    "min": {
      "!type": "fn(values: Number...) -> number"
    },
    "pow": {
      "!type": "fn(x: number, y: number) -> number"
    },
    "random": {
      "!type": "fn() -> number"
    },
    "round": {
      "!type": "fn(x: number) -> number"
    },
    "sin": {
      "!type": "fn(x: number) -> number"
    },
    "sqrt": {
      "!type": "fn(x: number) -> number"
    },
    "tan": {
      "!type": "fn(x: number) -> number"
    }
  },
  "MimeType": {
    "BMP": {
      "!type": "string",
      "!doc": "Representation of MIME type for a BMP image file (typically .bmp)."
    },
    "CSS": {
      "!type": "string",
      "!doc": "Representation of MIME type for a CSS text file (typically .css)."
    },
    "CSV": {
      "!type": "string",
      "!doc": "Representation of MIME type for a CSV text file (typically .csv)."
    },
    "FOLDER": {
      "!type": "string",
      "!doc": "Representation of MIME type for a Google Drive folder."
    },
    "GIF": {
      "!type": "string",
      "!doc": "Representation of MIME type for a GIF image file (typically .gif)."
    },
    "GOOGLE_APPS_SCRIPT": {
      "!type": "string",
      "!doc": "Representation of MIME type for a Google Apps Script project."
    },
    "GOOGLE_DOCS": {
      "!type": "string",
      "!doc": "Representation of MIME type for a Google Docs file."
    },
    "GOOGLE_DRAWINGS": {
      "!type": "string",
      "!doc": "Representation of MIME type for a Google Drawings file."
    },
    "GOOGLE_FORMS": {
      "!type": "string",
      "!doc": "Representation of MIME type for a Google Forms file."
    },
    "GOOGLE_SHEETS": {
      "!type": "string",
      "!doc": "Representation of MIME type for a Google Sheets file."
    },
    "GOOGLE_SLIDES": {
      "!type": "string",
      "!doc": "Representation of MIME type for a Google Slides file."
    },
    "HTML": {
      "!type": "string",
      "!doc": "Representation of MIME type for an HTML text file (typically .html)."
    },
    "JAVASCRIPT": {
      "!type": "string",
      "!doc": "Representation of MIME type for a JavaScript text file (typically .js)."
    },
    "JPEG": {
      "!type": "string",
      "!doc": "Representation of MIME type for a JPEG image file (typically .jpg)."
    },
    "MICROSOFT_EXCEL": {
      "!type": "string",
      "!doc": "Representation of MIME type for a Microsoft Excel spreadsheet file (typically .xlsx)."
    },
    "MICROSOFT_EXCEL_LEGACY": {
      "!type": "string",
      "!doc": "Representation of MIME type for a Microsoft Excel legacy file (typically .xls)."
    },
    "MICROSOFT_POWERPOINT": {
      "!type": "string",
      "!doc": "Representation of MIME type for a Microsoft PowerPoint presentation file (typically .pptx)."
    },
    "MICROSOFT_POWERPOINT_LEGACY": {
      "!type": "string",
      "!doc": "Representation of MIME type for a Microsoft PowerPoint legacy file (typically .ppt)."
    },
    "MICROSOFT_WORD": {
      "!type": "string",
      "!doc": "Representation of MIME type for a Microsoft Word document file (typically .docx)."
    },
    "MICROSOFT_WORD_LEGACY": {
      "!type": "string",
      "!doc": "Representation of MIME type for a Microsoft Word legacy file (typically .doc)."
    },
    "OPENDOCUMENT_GRAPHICS": {
      "!type": "string",
      "!doc": "Representation of MIME type for an OpenDocument graphics file (typically .odg)."
    },
    "OPENDOCUMENT_PRESENTATION": {
      "!type": "string",
      "!doc": "Representation of MIME type for an OpenDocument presentation file (typically .odp)."
    },
    "OPENDOCUMENT_SPREADSHEET": {
      "!type": "string",
      "!doc": "Representation of MIME type for an OpenDocument spreadsheet file (typically .ods)."
    },
    "OPENDOCUMENT_TEXT": {
      "!type": "string",
      "!doc": "Representation of MIME type for an OpenDocument word-processing file (typically .odt)."
    },
    "PDF": {
      "!type": "string",
      "!doc": "Representation of MIME type for a PDF file (typically .pdf)."
    },
    "PLAIN_TEXT": {
      "!type": "string",
      "!doc": "Representation of MIME type for a plain text file (typically .txt)."
    },
    "PNG": {
      "!type": "string",
      "!doc": "Representation of MIME type for a PNG image file (typically .png)."
    },
    "RTF": {
      "!type": "string",
      "!doc": "Representation of MIME type for a rich text file (typically .rtf)."
    },
    "SVG": {
      "!type": "string",
      "!doc": "Representation of MIME type for an SVG image file (typically .svg)."
    },
    "ZIP": {
      "!type": "string",
      "!doc": "Representation of MIME type for a ZIP archive file (typically .zip)."
    }
  },
  "Month": {
    "APRIL": {
      "!type": "Month",
      "!doc": "April (month 4)."
    },
    "AUGUST": {
      "!type": "Month",
      "!doc": "August (month 8)."
    },
    "DECEMBER": {
      "!type": "Month",
      "!doc": "December (month 12)."
    },
    "FEBRUARY": {
      "!type": "Month",
      "!doc": "February (month 2)."
    },
    "JANUARY": {
      "!type": "Month",
      "!doc": "January (month 1)."
    },
    "JULY": {
      "!type": "Month",
      "!doc": "July (month 7)."
    },
    "JUNE": {
      "!type": "Month",
      "!doc": "June (month 6)."
    },
    "MARCH": {
      "!type": "Month",
      "!doc": "March (month 3)."
    },
    "MAY": {
      "!type": "Month",
      "!doc": "May (month 5)."
    },
    "NOVEMBER": {
      "!type": "Month",
      "!doc": "November (month 11)."
    },
    "OCTOBER": {
      "!type": "Month",
      "!doc": "October (month 10)."
    },
    "SEPTEMBER": {
      "!type": "Month",
      "!doc": "September (month 9)."
    }
  },
  "Weekday": {
    "FRIDAY": {
      "!type": "Weekday",
      "!doc": "Friday."
    },
    "MONDAY": {
      "!type": "Weekday",
      "!doc": "Monday."
    },
    "SATURDAY": {
      "!type": "Weekday",
      "!doc": "Saturday."
    },
    "SUNDAY": {
      "!type": "Weekday",
      "!doc": "Sunday."
    },
    "THURSDAY": {
      "!type": "Weekday",
      "!doc": "Thursday."
    },
    "TUESDAY": {
      "!type": "Weekday",
      "!doc": "Tuesday."
    },
    "WEDNESDAY": {
      "!type": "Weekday",
      "!doc": "Wednesday."
    }
  },
  "Utilities": {
    "Charset": {
      "!type": "Utilities.Charset"
    },
    "DigestAlgorithm": {
      "!type": "DigestAlgorithm"
    },
    "MacAlgorithm": {
      "!type": "Utilities.MacAlgorithm"
    },
    "base64Decode": {
      "!type": "fn(encoded: string) -> [number]",
      "!doc": "Decodes a base-64 encoded string into a UTF-8 byte array.\n\n \n \n // This is the base64 encoded form of &quot;Google ????&quot;\n var base64data = &quot;R29vZ2xlIOOCsOODq+ODvOODlw==&quot;;\n\n // This will log:\n //     [71, 111, 111, 103, 108, 101, 32, -29, -126, -80,\n //      -29, -125, -85, -29, -125, -68, -29, -125, -105]\n var decoded = Utilities.base64Decode(base64data);\n Logger.log(decoded);\n\n // If we want a String instead of a byte array:\n // This will log the original &quot;Google ????&quot;\n Logger.log(Utilities.newBlob(decoded).getDataAsString());\n "
    },
    "base64Decode ": {
      "!type": "fn(encoded: string, charset: Utilities.Charset) -> [number]",
      "!doc": "Decodes a base-64 encoded string into a byte array in a specific character set.\n\n \n \n // This is the base64 encoded form of &quot;Google ????&quot;\n var base64data = &quot;R29vZ2xlIOOCsOODq+ODvOODlw==&quot;;\n\n var decoded = Utilities.base64Decode(base64data, Utilities.Charset.UTF_8);\n\n // This will log:\n //     [71, 111, 111, 103, 108, 101, 32, -29, -126, -80,\n //      -29, -125, -85, -29, -125, -68, -29, -125, -105]\n Logger.log(decoded);\n\n // If we want a String instead of a byte array:\n // This will log the original &quot;Google ????&quot;\n Logger.log(Utilities.newBlob(decoded).getDataAsString());\n "
    },
    "base64DecodeWebSafe": {
      "!type": "fn(encoded: string) -> [number]",
      "!doc": "Decodes a base-64 web-safe encoded string into a UTF-8 byte array.\n\n \n \n // This is the base64 web-safe encoded form of &quot;Google ????&quot;\n var base64data = &quot;R29vZ2xlIOOCsOODq-ODvOODlw==&quot;;\n\n var decoded = Utilities.base64DecodeWebSafe(base64data);\n\n // This will log:\n //     [71, 111, 111, 103, 108, 101, 32, -29, -126, -80,\n //      -29, -125, -85, -29, -125, -68, -29, -125, -105]\n Logger.log(decoded);\n\n // If we want a String instead of a byte array:\n // This will log the original &quot;Google ????&quot;\n Logger.log(Utilities.newBlob(decoded).getDataAsString());\n "
    },
    "base64DecodeWebSafe ": {
      "!type": "fn(encoded: string, charset: Utilities.Charset) -> [number]",
      "!doc": "Decodes a base-64 web-safe encoded string into a byte array in a specific character set.\n\n \n \n // This is the base64 web-safe encoded form of &quot;Google ????&quot;\n var base64data = &quot;R29vZ2xlIOOCsOODq-ODvOODlw==&quot;;\n\n var decoded = Utilities.base64DecodeWebSafe(base64data, Utilities.Charset.UTF_8);\n\n // This will log:\n //     [71, 111, 111, 103, 108, 101, 32, -29, -126, -80,\n //      -29, -125, -85, -29, -125, -68, -29, -125, -105]\n Logger.log(decoded);\n\n // If we want a String instead of a byte array:\n // This will log the original &quot;Google ????&quot;\n Logger.log(Utilities.newBlob(decoded).getDataAsString());\n "
    },
    "base64Encode": {
      "!type": "fn(data: [number]) -> string",
      "!doc": "Generates a base-64 encoded string from the given byte array.\n Base 64 is a common encoding accepted by a variety of tools that cannot\n accept binary data. Base 64 is commonly used in internet protocols\n such as email, HTTP, or in XML documents.\n\n \n \n // Instantiates a blob here for clarity\n var blob = Utilities.newBlob(&quot;A string here&quot;);\n\n // Writes &#39;QSBzdHJpbmcgaGVyZQ==&#39; to the log.\n var encoded = Utilities.base64Encode(blob.getBytes());\n Logger.log(encoded);\n "
    },
    "base64Encode ": {
      "!type": "fn(data: string) -> string",
      "!doc": "Generates a base-64 encoded string from the given string.\n Base 64 is a common encoding accepted by a variety of tools that cannot\n accept binary data. Base 64 is commonly used in internet protocols\n such as email, HTTP, or in XML documents.\n\n \n \n // Writes &#39;QSBzdHJpbmcgaGVyZQ==&#39; to the log.\n var encoded = Utilities.base64Encode(&quot;A string here&quot;);\n Logger.log(encoded);\n "
    },
    "base64Encode  ": {
      "!type": "fn(data: string, charset: Utilities.Charset) -> string",
      "!doc": "Generates a base-64 encoded string from the given string in a specific character set.\n A Charset is a way of encoding characters such that they can be encoded.\n These are typically done in a binary format, which can generally be incompatible\n with certain data transmission protocols. To make the data compatible,\n they are generally encoded into base 64, which is a common encoding accepted by a\n variety of tools that cannot accept binary data. Base 64 is commonly used in internet\n protocols such as email, HTTP, or in XML documents.\n\n \n \n // &quot;Google Groups&quot; in Katakana (Japanese)\n var input = &quot;Google ????&quot;;\n\n // Writes &quot;R29vZ2xlIOOCsOODq+ODvOODlw==&quot; to the log\n var encoded = Utilities.base64Encode(input, Utilities.Charset.UTF_8);\n Logger.log(encoded);\n\n "
    },
    "base64EncodeWebSafe": {
      "!type": "fn(data: [number]) -> string",
      "!doc": "Generates a base-64 web-safe encoded string from the given byte array.\n Base 64 is a common encoding accepted by a variety of tools that cannot\n accept binary data. Base 64 web-safe is commonly used in internet protocols\n such as email, HTTP, or in XML documents.\n\n \n \n // Instantiates a blob here for clarity\n var blob = Utilities.newBlob(&quot;A string here&quot;);\n\n // Writes &#39;QSBzdHJpbmcgaGVyZQ==&#39; to the log.\n var encoded = Utilities.base64EncodeWebSafe(blob.getBytes());\n Logger.log(encoded);\n "
    },
    "base64EncodeWebSafe ": {
      "!type": "fn(data: string) -> string",
      "!doc": "Generates a base-64 web-safe encoded string from the given string.\n Base 64 is a common encoding accepted by a variety of tools that cannot\n accept binary data. Base 64 web-safe is commonly used in internet protocols\n such as email, HTTP, or in XML documents.\n\n \n \n // Writes &#39;QSBzdHJpbmcgaGVyZQ==&#39; to the log.\n var encoded = Utilities.base64EncodeWebSafe(&quot;A string here&quot;);\n Logger.log(encoded);\n "
    },
    "base64EncodeWebSafe  ": {
      "!type": "fn(data: string, charset: Utilities.Charset) -> string",
      "!doc": "Generates a base-64 web-safe encoded string from the given string in a specific character set.\n A Charset is a way of encoding characters such that they can be encoded.\n These are typically done in a binary format, which can generally be incompatible\n with certain data transmission protocols. To make the data compatible,\n they are generally encoded into base 64, which is a common encoding accepted by a\n variety of tools that cannot accept binary data. Base 64 web-safe is commonly used in internet\n protocols such as email, HTTP, or in XML documents.\n\n \n \n // &quot;Google Groups&quot; in Katakana (Japanese)\n var input = &quot;Google ????&quot;;\n\n // Writes &quot;R29vZ2xlIOOCsOODq-ODvOODlw==&quot; to the log\n var encoded = Utilities.base64EncodeWebSafe(input, Utilities.Charset.UTF_8);\n Logger.log(encoded);\n\n "
    },
    "computeDigest": {
      "!type": "fn(algorithm: DigestAlgorithm, value: string) -> [number]",
      "!doc": "Compute a digest using the specified algorithm on the specified value\n\n \n \n var digest = Utilities.computeDigest(Utilities.DigestAlgorithm.MD5, &quot;input to hash&quot;);\n Logger.log(digest);\n "
    },
    "computeDigest ": {
      "!type": "fn(algorithm: DigestAlgorithm, value: string, charset: Utilities.Charset) -> [number]",
      "!doc": "Compute a digest using the specified algorithm on the specified value\n\n \n \n var digest = Utilities.computeDigest(Utilities.DigestAlgorithm.MD5,\n                                      &quot;input to hash&quot;,\n                                      Utilities.Charset.US_ASCII);\n Logger.log(digest);\n "
    },
    "computeHmacSha256Signature": {
      "!type": "fn(value: string, key: string) -> [number]",
      "!doc": "Signs the provided value using HMAC-SHA256 with the given key.\n\n \n \n // This will write an array of bytes to the log.\n var signature = Utilities.computeHmacSha256Signature(&quot;this is my input&quot;,\n                                                       &quot;my key - use a stronger one&quot;);\n Logger.log(signature);\n "
    },
    "computeHmacSha256Signature ": {
      "!type": "fn(value: string, key: string, charset: Utilities.Charset) -> [number]",
      "!doc": "Signs the provided value using HMAC-SHA256 with the given key and character set.\n\n \n \n // This will write an array of bytes to the log.\n var signature = Utilities.computeHmacSha256Signature(&quot;this is my input&quot;,\n                                                      &quot;my key - use a stronger one&quot;,\n                                                      Utilities.Charset.US_ASCII);\n Logger.log(signature);\n "
    },
    "computeHmacSignature": {
      "!type": "fn(algorithm: Utilities.MacAlgorithm, value: string, key: string) -> [number]",
      "!doc": "Compute a message authentication code using the specified algorithm on the specified key\n and value.\n\n \n \n // This will write an array of bytes to the log.\n var signature = Utilities.computeHmacSignature(Utilities.MacAlgorithm.HMAC_MD5,\n                                                &quot;input to hash&quot;,\n                                                &quot;key&quot;);\n Logger.log(signature);\n "
    },
    "computeHmacSignature ": {
      "!type": "fn(algorithm: Utilities.MacAlgorithm, value: string, key: string, charset: Utilities.Charset) -> [number]",
      "!doc": "Compute a message authentication code using the specified algorithm on the specified key\n and value.\n\n \n \n // This will write an array of bytes to the log.\n var signature = Utilities.computeHmacSignature(Utilities.MacAlgorithm.HMAC_MD5,\n                                                &quot;input to hash&quot;,\n                                                &quot;key&quot;,\n                                                Utilities.Charset.US_ASCII);\n Logger.log(signature);\n "
    },
    "computeRsaSha256Signature": {
      "!type": "fn(value: string, key: string) -> [number]",
      "!doc": "Signs the provided value using RSA-SHA256 with the given key.\n\n \n \n // This will write an array of bytes to the log.\n var signature = Utilities.computeRsaSha256Signature(&quot;this is my input&quot;,\n     &quot;-----BEGIN PRIVATE KEY-----\\nprivatekeyhere\\n-----END PRIVATE KEY-----\\n&quot;);\n Logger.log(signature);\n "
    },
    "computeRsaSha256Signature ": {
      "!type": "fn(value: string, key: string, charset: Utilities.Charset) -> [number]",
      "!doc": "Signs the provided value using RSA-SHA256 with the given key.\n\n \n \n // This will write an array of bytes to the log.\n var signature = Utilities.computeRsaSha256Signature(&quot;this is my input&quot;,\n     &quot;-----BEGIN PRIVATE KEY-----\\nprivatekeyhere\\n-----END PRIVATE KEY-----\\n&quot;);\n Logger.log(signature);\n "
    },
    "formatDate": {
      "!type": "fn(date: Date, timeZone: string, format: string) -> string",
      "!doc": "Formats date according to specification described in Java SE\n SimpleDateFormat class. Please visit the specification at\n \n http://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html\n\n \n \n // This formats the date as Greenwich Mean Time in the format\n // year-month-dateThour-minute-second.\n var formattedDate = Utilities.formatDate(new Date(), &quot;GMT&quot;, &quot;yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39;&quot;);\n Logger.log(formattedDate);\n "
    },
    "formatString": {
      "!type": "fn(template: string, args: Object...) -> string",
      "!doc": "Performs sprintf-like string formatting using '%'-style format strings.\n\n \n \n // will be: &quot;123.456000&quot;\n Utilities.formatString(&#39;%11.6f&#39;, 123.456);\n\n // will be: &quot;   abc&quot;\n Utilities.formatString(&#39;%6s&#39;, &#39;abc&#39;);\n "
    },
    "jsonParse": {
      "!type": "fn(jsonString: string) -> object",
      "!doc": "Return an object corresponding to the JSON string passed in.\n\n \n \n // Returns the object { name: &quot;John Smith&quot;, company: &quot;Virginia Company&quot;}\n var obj = Utilities.jsonParse(&#39;{&quot;name&quot;:&quot;John Smith&quot;,&quot;company&quot;:&quot;Virginia Company&quot;}&#39;);\n "
    },
    "jsonStringify": {
      "!type": "fn(obj: object) -> string",
      "!doc": "Return a JSON string of the object passed in.\n\n \n \n // Logs: {&quot;name&quot;:&quot;John Smith&quot;,&quot;company&quot;:&quot;Virginia Company&quot;}\n var person = { name: &quot;John Smith&quot;, company: &quot;Virginia Company&quot; };\n var json = Utilities.jsonStringify(person);\n Logger.log(json);\n "
    },
    "newBlob": {
      "!type": "fn(data: [number]) -> Blob",
      "!doc": "Create a new Blob object that is used in many Apps Script APIs that take binary data as input."
    },
    "newBlob ": {
      "!type": "fn(data: [number], contentType: string) -> Blob",
      "!doc": "Create a new Blob object that is used in many Apps Script APIs that take binary data as input."
    },
    "newBlob  ": {
      "!type": "fn(data: [number], contentType: string, name: string) -> Blob",
      "!doc": "Create a new Blob object that is used in many Apps Script APIs that take binary data as input."
    },
    "newBlob   ": {
      "!type": "fn(data: string) -> Blob",
      "!doc": "Create a new Blob object that is used in many Apps Script APIs that take binary data as input."
    },
    "newBlob    ": {
      "!type": "fn(data: string, contentType: string) -> Blob",
      "!doc": "Create a new Blob object that is used in many Apps Script APIs that take binary data as input."
    },
    "newBlob     ": {
      "!type": "fn(data: string, contentType: string, name: string) -> Blob",
      "!doc": "Create a new Blob object that is used in many Apps Script APIs that take binary data as input."
    },
    "parseCsv": {
      "!type": "fn(csv: string) -> [[string]]",
      "!doc": "Returns a tabular 2D array representation of a CSV string.\n\n \n \n // This will create a 2 dimensional array of the format [[a, b, c], [d, e, f]]\n var csvString = &quot;a,b,c\\nd,e,f&quot;;\n var data = Utilities.parseCsv(csvString);\n "
    },
    "parseCsv ": {
      "!type": "fn(csv: string, delimiter: Char) -> [[string]]",
      "!doc": "Returns a tabular 2D array representation of a CSV string using a custom delimiter.\n\n \n \n // This will create a 2 dimensional array of the format [[a, b, c], [d, e, f]]\n var csvString = &quot;a,b,c\\td,e,f&quot;;\n var data = Utilities.parseCsv(csvString, &#39;\\t&#39;);\n "
    },
    "sleep": {
      "!type": "fn(milliseconds: number)",
      "!doc": "Sleeps for specified number of milliseconds.\n Immediately puts the script to sleep for the specified number of milliseconds.\n The maximum allowed value is 300000 (or 5 minutes)."
    },
    "unzip": {
      "!type": "fn(blob: BlobSource) -> [Blob]",
      "!doc": "Takes a Blob representing a zip file and returns its component files.\n\n \n \n var googleFavIconUrl = &quot;https://www.google.com/favicon.ico&quot;;\n var googleLogoUrl = &quot;https://www.google.com/images/srpr/logo3w.png&quot;;\n\n // Fetch the Google favicon.ico file and get the Blob data\n var faviconBlob = UrlFetchApp.fetch(googleFavIconUrl).getBlob();\n var logoBlob = UrlFetchApp.fetch(googleLogoUrl).getBlob();\n\n // zip now references a blob containing an archive of both faviconBlob and logoBlob\n var zip = Utilities.zip([faviconBlob, logoBlob], &quot;google_images.zip&quot;);\n\n // This will now unzip the blobs\n var files = Utilities.unzip(zip);\n "
    },
    "zip": {
      "!type": "fn(blobs: [BlobSource]) -> Blob",
      "!doc": "Creates a new Blob object that is a zip file containing the data from the\n Blobs passed in.\n\n \n \n var googleFavIconUrl = &quot;https://www.google.com/favicon.ico&quot;;\n var googleLogoUrl = &quot;https://www.google.com/images/srpr/logo3w.png&quot;;\n\n // Fetch the Google favicon.ico file and get the Blob data\n var faviconBlob = UrlFetchApp.fetch(googleFavIconUrl).getBlob();\n var logoBlob = UrlFetchApp.fetch(googleLogoUrl).getBlob();\n\n // zip now references a blob containing an archive of both faviconBlob and logoBlob\n var zip = Utilities.zip([faviconBlob, logoBlob]);\n "
    },
    "zip ": {
      "!type": "fn(blobs: [BlobSource], name: string) -> Blob",
      "!doc": "Creates a new Blob object that is a zip file containing the data from the\n Blobs passed in. This version of the method allows a filename to be\n specified.\n\n \n \n var googleFavIconUrl = &quot;https://www.google.com/favicon.ico&quot;;\n var googleLogoUrl = &quot;https://www.google.com/images/srpr/logo3w.png&quot;;\n\n // Fetch the Google favicon.ico file and get the Blob data\n var faviconBlob = UrlFetchApp.fetch(googleFavIconUrl).getBlob();\n var logoBlob = UrlFetchApp.fetch(googleLogoUrl).getBlob();\n\n // zip now references a blob containing an archive of both faviconBlob and logoBlob\n var zip = Utilities.zip([faviconBlob, logoBlob], &quot;google_images.zip&quot;);\n "
    }
  },
  "ButtonSet": {
    "OK": {
      "!type": "ButtonSet",
      "!doc": "A single \"OK\" button, indicating an informational message that can only be dismissed."
    },
    "OK_CANCEL": {
      "!type": "ButtonSet",
      "!doc": "An \"OK\" button and a \"Cancel\" button, allowing the user to either proceed with or halt an\n operation."
    },
    "YES_NO": {
      "!type": "ButtonSet",
      "!doc": "A \"Yes\" button and a \"No\" button, allowing the user to answer a yes/no question."
    },
    "YES_NO_CANCEL": {
      "!type": "ButtonSet",
      "!doc": "A \"Yes\" button, a \"No\" button, and a \"Cancel\" button, allowing the user to either answer a\n yes/no question or halt an operation."
    }
  },
  "Button": {
    "CANCEL": {
      "!type": "Button",
      "!doc": "A \"Cancel\" button, indicating that an operation should not proceed."
    },
    "CLOSE": {
      "!type": "Button",
      "!doc": "The standard close button displayed in every dialog's title bar. This button is not explicitly\n added to a dialog, and it cannot be removed."
    },
    "NO": {
      "!type": "Button",
      "!doc": "A \"No\" button, indicating a negative response to a question."
    },
    "OK": {
      "!type": "Button",
      "!doc": "An \"OK\" button, indicating that an operation should proceed."
    },
    "YES": {
      "!type": "Button",
      "!doc": "A \"Yes\" button, indicating a positive response to a question."
    }
  },
  "BigNumber": {
    "abs": {
      "!type": "fn() -> BigNumber"
    },
    "add": {
      "!type": "fn(augend: BigNumber) -> BigNumber"
    },
    "add ": {
      "!type": "fn(augend: number) -> BigNumber"
    },
    "compareTo": {
      "!type": "fn(value: BigNumber) -> number"
    },
    "compareTo ": {
      "!type": "fn(value: number) -> number"
    },
    "divide": {
      "!type": "fn(divisor: BigNumber) -> BigNumber"
    },
    "divide ": {
      "!type": "fn(divisor: number) -> BigNumber"
    },
    "divideAndRemainder": {
      "!type": "fn(divisor: BigNumber) -> [BigNumber]"
    },
    "divideAndRemainder ": {
      "!type": "fn(divisor: number) -> [BigNumber]"
    },
    "divideToIntegralValue": {
      "!type": "fn(divisor: BigNumber) -> BigNumber"
    },
    "divideToIntegralValue ": {
      "!type": "fn(divisor: number) -> BigNumber"
    },
    "max": {
      "!type": "fn(value: BigNumber) -> BigNumber"
    },
    "max ": {
      "!type": "fn(value: number) -> BigNumber"
    },
    "min": {
      "!type": "fn(value: BigNumber) -> BigNumber"
    },
    "min ": {
      "!type": "fn(value: number) -> BigNumber"
    },
    "movePointLeft": {
      "!type": "fn(shift: number) -> BigNumber"
    },
    "movePointRight": {
      "!type": "fn(shift: number) -> BigNumber"
    },
    "multiply": {
      "!type": "fn(multiplicand: BigNumber) -> BigNumber"
    },
    "multiply ": {
      "!type": "fn(multiplicand: number) -> BigNumber"
    },
    "negate": {
      "!type": "fn() -> BigNumber"
    },
    "newInstance": {
      "!type": "fn() -> BigNumber"
    },
    "parse": {
      "!type": "fn(value: string) -> BigNumber"
    },
    "parse ": {
      "!type": "fn(value: string, radix: number) -> BigNumber"
    },
    "plus": {
      "!type": "fn() -> BigNumber"
    },
    "pow": {
      "!type": "fn(exponent: number) -> BigNumber"
    },
    "precision": {
      "!type": "fn() -> number"
    },
    "remainder": {
      "!type": "fn(divisor: BigNumber) -> BigNumber"
    },
    "remainder ": {
      "!type": "fn(divisor: number) -> BigNumber"
    },
    "sign": {
      "!type": "fn() -> number"
    },
    "subtract": {
      "!type": "fn(subtrahend: BigNumber) -> BigNumber"
    },
    "subtract ": {
      "!type": "fn(subtrahend: number) -> BigNumber"
    },
    "toExponential": {
      "!type": "fn() -> string"
    },
    "toFixed": {
      "!type": "fn() -> string"
    },
    "toPrecision": {
      "!type": "fn() -> string"
    },
    "toString ": {
      "!type": "fn() -> string"
    },
    "unitInTheLastPlaces": {
      "!type": "fn() -> BigNumber"
    },
    "valueOf ": {
      "!type": "fn() -> number"
    },
    "valueOf  ": {
      "!type": "fn(value: number) -> BigNumber"
    }
  },
  "Menu": {
    "addItem": {
      "!type": "fn(caption: string, functionName: string) -> Menu",
      "!doc": "Adds an item to the menu. The label for a menu item should be in sentence case (only the first\n word capitalized)."
    },
    "addSeparator": {
      "!type": "fn() -> Menu",
      "!doc": "Adds a visual separator to the menu."
    },
    "addSubMenu": {
      "!type": "fn(menu: Menu) -> Menu",
      "!doc": "Adds a sub-menu to the menu."
    },
    "addToUi": {
      "!type": "fn()",
      "!doc": "Inserts the menu into the instance of the editor's user interface."
    }
  },
  "DataTableBuilder": {
    "addColumn": {
      "!type": "fn(type: ColumnType, label: string) -> DataTableBuilder",
      "!doc": "Adds a column to the data table.  Columns will be added from 0 to n.\n\n The first column is often used by charts for labels (for instance, X-axis labels on line\n charts, or slice labels in pie charts).  The other columns are often used for data and\n therefore often require numeric values."
    },
    "addRow": {
      "!type": "fn(values: [object]) -> DataTableBuilder",
      "!doc": "Adds a row to the data table."
    },
    "build": {
      "!type": "fn() -> DataTable",
      "!doc": "Builds and returns a data table."
    },
    "setValue": {
      "!type": "fn(row: number, column: number, value: object) -> DataTableBuilder",
      "!doc": "Sets a specific value in the table.\n\n You may set a value before adding the column to the data table.  However, unless the column\n is added at some point, the value will be ignored.\n\n Not all column values need to be filled in.  Those missing will be considered null."
    }
  },
  "DigestAlgorithm": {
    "MD2": {
      "!type": "DigestAlgorithm"
    },
    "MD5": {
      "!type": "DigestAlgorithm"
    },
    "SHA_1": {
      "!type": "DigestAlgorithm"
    },
    "SHA_256": {
      "!type": "DigestAlgorithm"
    },
    "SHA_384": {
      "!type": "DigestAlgorithm"
    },
    "SHA_512": {
      "!type": "DigestAlgorithm"
    }
  },
  "Blob": {
    "copyBlob": {
      "!type": "fn() -> Blob",
      "!doc": "Returns a copy of this blob."
    },
    "getAllBlobs": {
      "!type": "fn() -> [Blob]",
      "!doc": "Gets all the blobs that are contained within this (possibly composite) blob."
    },
    "getAs": {
      "!type": "fn(contentType: string) -> Blob",
      "!doc": "Return the data inside this object as a blob converted to the specified content type. This\n method adds the appropriate extension to the filename ? for example, \"myfile.pdf\". However, it\n assumes that the part of the filename that follows the last period (if any) is an existing\n extension that should be replaced. Consequently, \"ChristmasList.12.25.2014\" will become\n \"ChristmasList.12.25.pdf\"."
    },
    "getBytes": {
      "!type": "fn() -> [number]",
      "!doc": "Gets the data stored in this blob."
    },
    "getContentType": {
      "!type": "fn() -> string",
      "!doc": "Gets the content type of the bytes in this blob."
    },
    "getDataAsString": {
      "!type": "fn() -> string",
      "!doc": "Gets the data of this blob as a String with UTF-8 encoding."
    },
    "getDataAsString ": {
      "!type": "fn(charset: string) -> string",
      "!doc": "Gets the data of this blob as a string with the specified encoding."
    },
    "getName": {
      "!type": "fn() -> string",
      "!doc": "Gets the name of this blob."
    },
    "isGoogleType": {
      "!type": "fn() -> bool",
      "!doc": "Returns whether this blob is a Google Apps file (Sheets, Docs, etc.)."
    },
    "setBytes": {
      "!type": "fn(data: [number]) -> Blob",
      "!doc": "Sets the data stored in this blob."
    },
    "setContentType": {
      "!type": "fn(contentType: string) -> Blob",
      "!doc": "Sets the content type of the bytes in this blob."
    },
    "setContentTypeFromExtension": {
      "!type": "fn() -> Blob",
      "!doc": "Sets the content type of the bytes in this blob based on the file extension.\n The contentType will be null if it cannot be guessed from its extension."
    },
    "setDataFromString": {
      "!type": "fn(string: string) -> Blob",
      "!doc": "Sets the data of this blob from a string with UTF-8 encoding."
    },
    "setDataFromString ": {
      "!type": "fn(string: string, charset: string) -> Blob",
      "!doc": "Sets the data of this blob from a string with the specified encoding."
    },
    "setName": {
      "!type": "fn(name: string) -> Blob",
      "!doc": "Sets the name of this blob."
    }
  },
  "[]": {
    "length": {
      "!type": "number"
    },
    "concat": {
      "!type": "fn(arrays: Object...) -> []"
    },
    "join": {
      "!type": "fn() -> string"
    },
    "join ": {
      "!type": "fn(separator: string) -> string"
    },
    "pop": {
      "!type": "fn() -> object"
    },
    "push": {
      "!type": "fn(element: object) -> number"
    },
    "reverse": {
      "!type": "fn() -> []"
    },
    "shift": {
      "!type": "fn() -> object"
    },
    "slice": {
      "!type": "fn(start: number) -> []"
    },
    "slice ": {
      "!type": "fn(start: number, end: number) -> []"
    },
    "sort": {
      "!type": "fn() -> []"
    },
    "sort ": {
      "!type": "fn(sortFunction: Function) -> []"
    },
    "splice": {
      "!type": "fn(index: number, howMany: number) -> []"
    },
    "splice ": {
      "!type": "fn(index: number, howMany: number, elements: Object...) -> []"
    },
    "toString ": {
      "!type": "fn() -> string"
    },
    "unshift": {
      "!type": "fn(elements: Object...) -> number"
    },
    "valueOf ": {
      "!type": "fn() -> object"
    }
  },
  "AdWordsApp": {
    "adCustomizerSources": {
      "!type": "fn() -> AdWordsApp.AdCustomizerSourceSelector"
    },
    "adGroups": {
      "!type": "fn() -> AdWordsApp.AdGroupSelector"
    },
    "adParams": {
      "!type": "fn() -> AdWordsApp.AdParamSelector"
    },
    "ads": {
      "!type": "fn() -> AdWordsApp.AdSelector"
    },
    "biddingStrategies": {
      "!type": "fn() -> AdWordsApp.BiddingStrategySelector"
    },
    "budgets": {
      "!type": "fn() -> AdWordsApp.BudgetSelector"
    },
    "bulkUploads": {
      "!type": "fn() -> AdWordsApp.BulkUploads"
    },
    "campaigns": {
      "!type": "fn() -> AdWordsApp.CampaignSelector"
    },
    "createLabel": {
      "!type": "fn(name: string, description: string, backgroundColor: string)"
    },
    "currentAccount": {
      "!type": "fn() -> AdWordsApp.Account"
    },
    "display": {
      "!type": "fn() -> AdWordsApp.Display"
    },
    "excludedPlacementLists": {
      "!type": "fn() -> AdWordsApp.ExcludedPlacementListSelector"
    },
    "extensions": {
      "!type": "fn() -> AdWordsApp.Extensions"
    },
    "getExecutionInfo": {
      "!type": "fn() -> AdWordsApp.ExecutionInfo"
    },
    "keywords": {
      "!type": "fn() -> AdWordsApp.KeywordSelector"
    },
    "labels": {
      "!type": "fn() -> AdWordsApp.LabelSelector"
    },
    "negativeKeywordLists": {
      "!type": "fn() -> AdWordsApp.NegativeKeywordListSelector"
    },
    "newAdCustomizerSourceBuilder": {
      "!type": "fn() -> AdWordsApp.AdCustomizerSourceBuilder"
    },
    "newExcludedPlacementListBuilder": {
      "!type": "fn() -> AdWordsApp.ExcludedPlacementListBuilder"
    },
    "newNegativeKeywordListBuilder": {
      "!type": "fn() -> AdWordsApp.NegativeKeywordListBuilder"
    },
    "productAds": {
      "!type": "fn() -> AdWordsApp.ProductAdSelector"
    },
    "productGroups": {
      "!type": "fn() -> AdWordsApp.ProductGroupSelector"
    },
    "report": {
      "!type": "fn(query: string, optArgs: object) -> AdWordsApp.Report"
    },
    "shoppingAdGroups": {
      "!type": "fn() -> AdWordsApp.ShoppingAdGroupSelector"
    },
    "shoppingCampaigns": {
      "!type": "fn() -> AdWordsApp.ShoppingCampaignSelector"
    },
    "targeting": {
      "!type": "fn() -> AdWordsApp.Targeting"
    }
  },
  "XmlService": {
    "ContentTypes": {
      "!type": "XmlService.ContentType",
      "!doc": "An enumeration representing the types of XML content nodes."
    },
    "createCdata": {
      "!type": "fn(text: string) -> XmlService.Cdata",
      "!doc": "Creates an unattached CDATASection node with the given value."
    },
    "createComment": {
      "!type": "fn(text: string) -> XmlService.Comment",
      "!doc": "Creates an unattached Comment node with the given value."
    },
    "createDocType": {
      "!type": "fn(elementName: string) -> XmlService.DocType",
      "!doc": "Creates an unattached DocumentType node for the root Element node\n with the given name."
    },
    "createDocType ": {
      "!type": "fn(elementName: string, systemId: string) -> XmlService.DocType",
      "!doc": "Creates an unattached DocumentType node for the root Element node\n with the given name, and the given system ID for the external subset data."
    },
    "createDocType  ": {
      "!type": "fn(elementName: string, publicId: string, systemId: string) -> XmlService.DocType",
      "!doc": "Creates an unattached DocumentType node for the root Element node\n with the given name, and the given public ID and system ID for the external subset data."
    },
    "createDocument": {
      "!type": "fn() -> XmlService.Document",
      "!doc": "Creates an empty XML document."
    },
    "createDocument ": {
      "!type": "fn(rootElement: XmlService.Element) -> XmlService.Document",
      "!doc": "Creates an XML document with the given root Element node."
    },
    "createElement": {
      "!type": "fn(name: string) -> XmlService.Element",
      "!doc": "Creates an unattached Element node with the given local name and no namespace."
    },
    "createElement ": {
      "!type": "fn(name: string, namespace: XmlService.Namespace) -> XmlService.Element",
      "!doc": "Creates an unattached Element node with the given local name and namespace."
    },
    "createText": {
      "!type": "fn(text: string) -> XmlService.Text",
      "!doc": "Creates an unattached Text node with the given value."
    },
    "getCompactFormat": {
      "!type": "fn() -> XmlService.Format",
      "!doc": "Creates a Format object for outputting a compact XML document. The formatter\n defaults to UTF-8 encoding, no indentation, and no additional line breaks, but includes\n the XML declaration and its encoding.\n\n \n \n // Log an XML document in compact form.\n var xml = &#39;&lt;root&gt;&lt;a&gt;&lt;b&gt;Text!&lt;/b&gt;&lt;b&gt;More text!&lt;/b&gt;&lt;/a&gt;&lt;/root&gt;&#39;;\n var document = XmlService.parse(xml);\n var output = XmlService.getCompactFormat()\n     .format(document);\n Logger.log(output);\n "
    },
    "getNamespace": {
      "!type": "fn(uri: string) -> XmlService.Namespace",
      "!doc": "Creates a Namespace with the given URI."
    },
    "getNamespace ": {
      "!type": "fn(prefix: string, uri: string) -> XmlService.Namespace",
      "!doc": "Creates a Namespace with the given prefix and URI."
    },
    "getNoNamespace": {
      "!type": "fn() -> XmlService.Namespace",
      "!doc": "Creates a Namespace that represents the absence of a real namespace."
    },
    "getPrettyFormat": {
      "!type": "fn() -> XmlService.Format",
      "!doc": "Creates a Format object for outputting a human-readable XML document. The formatter\n defaults to UTF-8 encoding, two-space indentation, \\r\\n line separators after\n every node, and includes the XML declaration and its encoding.\n\n \n \n // Log an XML document in human-readable form.\n var xml = &#39;&lt;root&gt;&lt;a&gt;&lt;b&gt;Text!&lt;/b&gt;&lt;b&gt;More text!&lt;/b&gt;&lt;/a&gt;&lt;/root&gt;&#39;;\n var document = XmlService.parse(xml);\n var output = XmlService.getPrettyFormat()\n     .format(document);\n Logger.log(output);\n "
    },
    "getRawFormat": {
      "!type": "fn() -> XmlService.Format",
      "!doc": "Creates a Format object for outputting a raw XML document. The formatter defaults to\n UTF-8 encoding, no indentation and no line breaks other than those provided in the XML\n document itself, and includes the XML declaration and its encoding.\n\n \n \n // Log an XML document in raw form.\n var xml = &#39;&lt;root&gt;&lt;a&gt;&lt;b&gt;Text!&lt;/b&gt;&lt;b&gt;More text!&lt;/b&gt;&lt;/a&gt;&lt;/root&gt;&#39;;\n var document = XmlService.parse(xml);\n var output = XmlService.getRawFormat()\n     .format(document);\n Logger.log(output);\n "
    },
    "getXmlNamespace": {
      "!type": "fn() -> XmlService.Namespace",
      "!doc": "Creates a Namespace with the standard xml prefix."
    },
    "parse": {
      "!type": "fn(xml: string) -> XmlService.Document",
      "!doc": "Creates an Document from the given XML, without validating the XML.\n \n \n \n var xml = &#39;&lt;root&gt;&lt;a&gt;&lt;b&gt;Text!&lt;/b&gt;&lt;b&gt;More text!&lt;/b&gt;&lt;/a&gt;&lt;/root&gt;&#39;;\n var doc = XmlService.parse(xml);\n "
    }
  },
  "PromptResponse": {
    "getResponseText": {
      "!type": "fn() -> string",
      "!doc": "Gets the text that the user entered in the dialog's input field. The text is available even if\n the user closed the dialog by clicking a button with a negative connotation, like \"Cancel\" or\n the close button in the dialog's title bar. getSelectedButton() can help to determine\n whether the user intended the response text to be valid."
    },
    "getSelectedButton": {
      "!type": "fn() -> Button",
      "!doc": "Gets the button that the user clicked to dismiss the dialog. If the user clicked the close\n button that is included in every dialog's title bar, this method returns Button.CLOSE."
    }
  },
  "DriveApp": {
    "Access": {
      "!type": "DriveApp.Access",
      "!doc": "An enum representing classes of users who can access a file or folder, besides any individual\n users who have been explicitly given access."
    },
    "Permission": {
      "!type": "DriveApp.Permission",
      "!doc": "An enum representing the permissions granted to users who can access a file or folder, besides\n any individual users who have been explicitly given access."
    },
    "addFile": {
      "!type": "fn(child: DriveApp.File) -> DriveApp.Folder",
      "!doc": "Adds the given file to the root of the user's Drive. This method does not move the file out of its\n existing parent folder; a file can have more than one parent simultaneously."
    },
    "addFolder": {
      "!type": "fn(child: DriveApp.Folder) -> DriveApp.Folder",
      "!doc": "Adds the given folder to the root of the user's Drive. This method does not move the folder out of\n its existing parent folder; a folder can have more than one parent simultaneously."
    },
    "continueFileIterator": {
      "!type": "fn(continuationToken: string) -> DriveApp.FileIterator",
      "!doc": "Resumes a file iteration using a continuation token from a previous iterator. This method\n is useful if processing an iterator in one execution would exceed the maximum execution\n time. Continuation tokens are generally valid for one week."
    },
    "continueFolderIterator": {
      "!type": "fn(continuationToken: string) -> DriveApp.FolderIterator",
      "!doc": "Resumes a folder iteration using a continuation token from a previous iterator. This method\n is useful if processing an iterator in one execution would exceed the maximum execution\n time. Continuation tokens are generally valid for one week."
    },
    "createFile": {
      "!type": "fn(blob: BlobSource) -> DriveApp.File",
      "!doc": "Creates a file in the root of the user's Drive from a given Blob of arbitrary data.\n\n \n // Create an image file in Google Drive using the Maps service.\n var blob = Maps.newStaticMap().setCenter('76 9th Avenue, New York NY').getBlob();\n DriveApp.createFile(blob);\n "
    },
    "createFile ": {
      "!type": "fn(name: string, content: string) -> DriveApp.File",
      "!doc": "Creates a text file in the root of the user's Drive with the given name and contents. Throws an\n exception if content is larger than 10MB.\n\n \n // Create a text file with the content \"Hello, world!\"\n DriveApp.createFile('New Text File', 'Hello, world!');\n "
    },
    "createFile  ": {
      "!type": "fn(name: string, content: string, mimeType: string) -> DriveApp.File",
      "!doc": "Creates a file in the root of the user's Drive with the given name, contents, and MIME type. Throws\n an exception if content is larger than 10MB.\n\n \n \n // Create an HTML file with the content &quot;Hello, world!&quot;\n DriveApp.createFile(&#39;New HTML File&#39;, &#39;&lt;b&gt;Hello, world!&lt;/b&gt;&#39;, MimeType.HTML);\n \n "
    },
    "createFolder": {
      "!type": "fn(name: string) -> DriveApp.Folder",
      "!doc": "Creates a folder in the root of the user's Drive with the given name."
    },
    "getFileById": {
      "!type": "fn(id: string) -> DriveApp.File",
      "!doc": "Gets the file with the given ID. Throws a scripting exception if the file does not exist or the\n user does not have permission to access it."
    },
    "getFiles": {
      "!type": "fn() -> DriveApp.FileIterator",
      "!doc": "Gets a collection of all files in the user's Drive."
    },
    "getFilesByName": {
      "!type": "fn(name: string) -> DriveApp.FileIterator",
      "!doc": "Gets a collection of all files in the user's Drive that have the given name."
    },
    "getFilesByType": {
      "!type": "fn(mimeType: string) -> DriveApp.FileIterator",
      "!doc": "Gets a collection of all files in the user's Drive that have the given MIME type."
    },
    "getFolderById": {
      "!type": "fn(id: string) -> DriveApp.Folder",
      "!doc": "Gets the folder with the given ID. Throws a scripting exception if the folder does not exist or\n the user does not have permission to access it."
    },
    "getFolders": {
      "!type": "fn() -> DriveApp.FolderIterator",
      "!doc": "Gets a collection of all folders in the user's Drive."
    },
    "getFoldersByName": {
      "!type": "fn(name: string) -> DriveApp.FolderIterator",
      "!doc": "Gets a collection of all folders in the user's Drive that have the given name."
    },
    "getRootFolder": {
      "!type": "fn() -> DriveApp.Folder",
      "!doc": "Gets the folder at the root of the user's Drive."
    },
    "getStorageLimit": {
      "!type": "fn() -> number",
      "!doc": "Gets the number of bytes the user is allowed to store in Drive."
    },
    "getStorageUsed": {
      "!type": "fn() -> number",
      "!doc": "Gets the number of bytes the user is currently storing in Drive."
    },
    "getTrashedFiles": {
      "!type": "fn() -> DriveApp.FileIterator",
      "!doc": "Gets a collection of all the files in the trash of the user's Drive."
    },
    "getTrashedFolders": {
      "!type": "fn() -> DriveApp.FolderIterator",
      "!doc": "Gets a collection of all the folders in the trash of the user's Drive."
    },
    "removeFile": {
      "!type": "fn(child: DriveApp.File) -> DriveApp.Folder",
      "!doc": "Removes the given file from the root of the user's Drive. This method does not delete the file, but\n if a file is removed from all of its parents, it cannot be seen in Drive except by searching\n for it or using the \"All items\" view."
    },
    "removeFolder": {
      "!type": "fn(child: DriveApp.Folder) -> DriveApp.Folder",
      "!doc": "Removes the given folder from the root of the user's Drive. This method does not delete the folder\n or its contents, but if a folder is removed from all of its parents, it cannot be seen in Drive\n except by searching for it or using the \"All items\" view."
    },
    "searchFiles": {
      "!type": "fn(params: string) -> DriveApp.FileIterator",
      "!doc": "Gets a collection of all files in the user's Drive that match the given search\n criteria. The search criteria are detailed the Google Drive\n SDK documentation. Note that the params argument is a query string that may\n contain string values, so take care to escape quotation marks correctly (for example\n &quot;title contains &#39;Gulliver\\\\&#39;s Travels&#39;&quot; or &#39;title contains &quot;Gulliver\\&#39;s\n Travels&quot;&#39;).\n\n \n // Log the name of every file in the user's Drive that modified after February 28,\n // 2013 whose name contains \"untitled\".\n var files = DriveApp.searchFiles(\n     'modifiedDate > \"2013-02-28\" and title contains \"untitled\"');\n while (files.hasNext()) {\n   var file = files.next();\n   Logger.log(file.getName());\n }\n "
    },
    "searchFolders": {
      "!type": "fn(params: string) -> DriveApp.FolderIterator",
      "!doc": "Gets a collection of all folders in the user's Drive that match the given search\n criteria. The search criteria are detailed the Google Drive\n SDK documentation. Note that the params argument is a query string that may\n contain string values, so take care to escape quotation marks correctly (for example\n &quot;title contains &#39;Gulliver\\\\&#39;s Travels&#39;&quot; or &#39;title contains &quot;Gulliver\\&#39;s\n Travels&quot;&#39;).\n\n \n // Log the name of every folder in the user's Drive that you own and is starred.\n var folders = DriveApp.searchFolders('starred = true and \"me\" in owners');\n while (folders.hasNext()) {\n   var folder = folders.next();\n   Logger.log(folder.getName());\n }\n "
    }
  },
  "BlobSource": {
    "getAs": {
      "!type": "fn(contentType: string) -> Blob",
      "!doc": "Return the data inside this object as a blob converted to the specified content type. This\n method adds the appropriate extension to the filename ? for example, \"myfile.pdf\". However, it\n assumes that the part of the filename that follows the last period (if any) is an existing\n extension that should be replaced. Consequently, \"ChristmasList.12.25.2014\" will become\n \"ChristmasList.12.25.pdf\"."
    },
    "getBlob": {
      "!type": "fn() -> Blob",
      "!doc": "Return the data inside this object as a blob."
    }
  },
  "MccApp": {
    "accountLabels": {
      "!type": "fn() -> MccApp.AccountLabelSelector"
    },
    "accounts": {
      "!type": "fn() -> MccApp.ManagedAccountSelector"
    },
    "createAccountLabel": {
      "!type": "fn(name: string)"
    },
    "select": {
      "!type": "fn(account: ManagedAccount)"
    }
  },
  "Ui": {
    "Button": {
      "!type": "Button",
      "!doc": "An enum representing predetermined, localized dialog buttons returned by an\n alert or PromptResponse.getSelectedButton()\n to indicate which button in a dialog the user clicked."
    },
    "ButtonSet": {
      "!type": "ButtonSet",
      "!doc": "An enum representing predetermined, localized sets of one or more dialog buttons that can be\n added to an alert or a\n prompt."
    },
    "alert": {
      "!type": "fn(prompt: string) -> Button",
      "!doc": "Opens a dialog box in the user's editor with the given message and an \"OK\" button. This method\n suspends the server-side script while the dialog is open. The script will resume after the user\n dismisses the dialog, but Jdbc\n connections will not persist across the suspension. For more information, see the\n guide to dialogs and sidebars.\n\n \n // Display \"Hello, world!\" in a dialog box with an \"OK\" button. The user can also close the\n // dialog by clicking the close button in its title bar.\n SpreadsheetApp.getUi().alert('Hello, world!');\n "
    },
    "alert ": {
      "!type": "fn(prompt: string, buttons: ButtonSet) -> Button",
      "!doc": "Opens a dialog box in the user's editor with the given message and set of buttons. This method\n suspends the server-side script while the dialog is open. The script will resume after the user\n dismisses the dialog, but Jdbc\n connections will not persist across the suspension. For more information, see the\n guide to dialogs and sidebars.\n\n \n // Display a dialog box with a message and \"Yes\" and \"No\" buttons. The user can also close the\n // dialog by clicking the close button in its title bar.\n var ui = SpreadsheetApp.getUi();\n var response = ui.alert('Are you sure you want to continue?', ui.ButtonSet.YES_NO);\n\n // Process the user's response.\n if (response == ui.Button.YES) {\n   Logger.log('The user clicked \"Yes.\"');\n } else {\n   Logger.log('The user clicked \"No\" or the close button in the dialog\\'s title bar.');\n }\n "
    },
    "alert  ": {
      "!type": "fn(title: string, prompt: string, buttons: ButtonSet) -> Button",
      "!doc": "Opens a dialog box in the user's editor with the given title, message, and set of buttons. This\n method suspends the server-side script while the dialog is open. The script will resume after\n the user dismisses the dialog, but Jdbc\n connections will not persist across the suspension. For more information, see the\n guide to dialogs and sidebars.\n\n \n // Display a dialog box with a title, message, and \"Yes\" and \"No\" buttons. The user can also\n // close the dialog by clicking the close button in its title bar.\n var ui = SpreadsheetApp.getUi();\n var response = ui.alert('Confirm', 'Are you sure you want to continue?', ui.ButtonSet.YES_NO);\n\n // Process the user's response.\n if (response == ui.Button.YES) {\n   Logger.log('The user clicked \"Yes.\"');\n } else {\n   Logger.log('The user clicked \"No\" or the close button in the dialog\\'s title bar.');\n }\n "
    },
    "createAddonMenu": {
      "!type": "fn() -> Menu",
      "!doc": "Creates a builder that can be used to insert a sub-menu into the editor's Add-on menu. The\n menu will not actually be updated until Menu.addToUi() is called. If the script is\n running as an add-on, the sub-menu name will match the add-on's name in the web store; if\n the script is bound to the document directly,\n the sub-menu name will match the script's name. For more information, see the\n guide to menus.\n\n \n // Add an item to the Add-on menu, under a sub-menu whose name is set automatically.\n function onOpen(e) {\n   SpreadsheetApp.getUi()\n       .createAddonMenu()\n       .addItem('Show', 'showSidebar')\n       .addToUi();\n }"
    },
    "createMenu": {
      "!type": "fn(caption: string) -> Menu",
      "!doc": "Creates a builder that can be used to add a menu to the editor's user interface. The menu will\n not actually be added until Menu.addToUi() is called. For more information, see the\n guide to menus. The label for a top-level menu should\n be in headline case (all major words capitalized), although the label for a sub-menu should be\n in sentence case (only the first word capitalized). If the script is published as an\n add-on, the caption parameter is ignored and the\n menu is added as a sub-menu of the Add-ons menu, equivalent to createAddonMenu().\n\n \n // Add a custom menu to the active document, including a separator and a sub-menu.\n function onOpen(e) {\n   SpreadsheetApp.getUi()\n       .createMenu('My Menu')\n       .addItem('My menu item', 'myFunction')\n       .addSeparator()\n       .addSubMenu(SpreadsheetApp.getUi().createMenu('My sub-menu')\n           .addItem('One sub-menu item', 'mySecondFunction')\n           .addItem('Another sub-menu item', 'myThirdFunction'))\n       .addToUi();\n }\n "
    },
    "prompt": {
      "!type": "fn(prompt: string) -> PromptResponse",
      "!doc": "Opens an input dialog box in the user's editor with the given message and an \"OK\" button. This\n method suspends the server-side script while the dialog is open. The script will resume after\n the user dismisses the dialog, but Jdbc\n connections will not persist across the suspension. For more information, see the\n guide to dialogs and sidebars.\n\n \n // Display a dialog box with a message, input field, and an \"OK\" button. The user can also\n // close the dialog by clicking the close button in its title bar.\n var ui = SpreadsheetApp.getUi();\n var response = ui.prompt('Enter your name:');\n\n // Process the user's response.\n if (response.getSelectedButton() == ui.Button.OK) {\n   Logger.log('The user\\'s name is %s.', response.getResponseText());\n } else {\n   Logger.log('The user clicked the close button in the dialog\\'s title bar.');\n }\n "
    },
    "prompt ": {
      "!type": "fn(prompt: string, buttons: ButtonSet) -> PromptResponse",
      "!doc": "Opens an input dialog box in the user's editor with the given message and set of buttons. This\n method suspends the server-side script while the dialog is open. The script will resume after\n the user dismisses the dialog, but Jdbc\n connections will not persist across the suspension. For more information, see the\n guide to dialogs and sidebars.\n\n \n // Display a dialog box with a message, input field, and \"Yes\" and \"No\" buttons. The user can\n // also close the dialog by clicking the close button in its title bar.\n var ui = SpreadsheetApp.getUi();\n var response = ui.prompt('May I know your name?', ui.ButtonSet.YES_NO);\n\n // Process the user's response.\n if (response.getSelectedButton() == ui.Button.YES) {\n   Logger.log('The user\\'s name is %s.', response.getResponseText());\n } else if (response.getSelectedButton() == ui.Button.NO) {\n   Logger.log('The user didn\\'t want to provide a name.');\n } else {\n   Logger.log('The user clicked the close button in the dialog\\'s title bar.');\n }\n "
    },
    "prompt  ": {
      "!type": "fn(title: string, prompt: string, buttons: ButtonSet) -> PromptResponse",
      "!doc": "Opens an input dialog box in the user's editor with the given title, message, and set of\n buttons. This method suspends the server-side script while the dialog is open. The script will\n resume after the user dismisses the dialog, but\n Jdbc connections will not persist across\n the suspension. For more information, see the\n guide to dialogs and sidebars.\n\n \n // Display a dialog box with a title, message, input field, and \"Yes\" and \"No\" buttons. The\n // user can also close the dialog by clicking the close button in its title bar.\n var ui = SpreadsheetApp.getUi();\n var response = ui.prompt('Getting to know you', 'May I know your name?', ui.ButtonSet.YES_NO);\n\n // Process the user's response.\n if (response.getSelectedButton() == ui.Button.YES) {\n   Logger.log('The user\\'s name is %s.', response.getResponseText());\n } else if (response.getSelectedButton() == ui.Button.NO) {\n   Logger.log('The user didn\\'t want to provide a name.');\n } else {\n   Logger.log('The user clicked the close button in the dialog\\'s title bar.');\n }\n "
    },
    "showDialog": {
      "!type": "fn(userInterface: object)",
      "!doc": "Opens a dialog box in the user's editor with custom client-side content. This method does\n not suspend the server-side script while the dialog is open. To communicate with the\n server-side script, the client-side component must make asynchronous callbacks using either the\n google.script API for\n HtmlService or\n server handlers for\n UiApp. To close the dialog\n programmatically, call \n google.script.host.close() on the client side of an HtmlService web\n app or UiInstance.close() from a\n UiApp web app. For more information, see the\n guide to dialogs and sidebars.\n\n \n \n // Display a dialog box with custom HtmlService content.\n var htmlOutput = HtmlService\n     .createHtmlOutput(&#39;&lt;p&gt;A change of speed, a change of style...&lt;/p&gt;&#39;)\n     .setSandboxMode(HtmlService.SandboxMode.IFRAME)\n     .setTitle(&#39;My add-on&#39;)\n     .setWidth(250)\n     .setHeight(300);\n SpreadsheetApp.getUi().showDialog(htmlOutput);\n\n // Display a dialog box with custom UiApp content.\n var uiInstance = UiApp.createApplication()\n     .setTitle(&#39;My add-on&#39;)\n     .setWidth(250)\n     .setHeight(300);\n uiInstance.add(uiInstance.createLabel(&#39;The photograph on the dashboard taken years ago...&#39;));\n SpreadsheetApp.getUi().showDialog(uiInstance);\n "
    },
    "showModalDialog": {
      "!type": "fn(userInterface: object, title: string)",
      "!doc": "Opens a modal dialog box in the user's editor with custom client-side content. This method does\n not suspend the server-side script while the dialog is open. To communicate with the\n server-side script, the client-side component must make asynchronous callbacks using either\n the google.script API for\n HtmlService or\n server handlers for\n UiApp. To close the dialog\n programmatically, call \n google.script.host.close() on the client side of an HtmlService web\n app or UiInstance.close() from a\n UiApp web app. For more information, see the\n guide to dialogs and sidebars.\n\n Modal dialogs prevent the user from interacting with anything other than the dialog. By\n contrast, modeless dialogs and\n sidebars let the user interact with\n the editor. In almost all cases, a modal dialog or sidebar is a better choice than a modeless\n dialog.\n\n \n \n // Display a modal dialog box with custom HtmlService content.\n var htmlOutput = HtmlService\n     .createHtmlOutput(&#39;&lt;p&gt;A change of speed, a change of style...&lt;/p&gt;&#39;)\n     .setSandboxMode(HtmlService.SandboxMode.IFRAME)\n     .setWidth(250)\n     .setHeight(300);\n SpreadsheetApp.getUi().showModalDialog(htmlOutput, &#39;My add-on&#39;);\n\n // Display a modal dialog box with custom UiApp content.\n var uiInstance = UiApp.createApplication()\n     .setWidth(250)\n     .setHeight(300);\n uiInstance.add(uiInstance.createLabel(&#39;The photograph on the dashboard taken years ago...&#39;));\n SpreadsheetApp.getUi().showModalDialog(uiInstance, &#39;My add-on&#39;);\n "
    },
    "showModelessDialog": {
      "!type": "fn(userInterface: object, title: string)",
      "!doc": "Opens a modeless dialog box in the user's editor with custom client-side content. This method\n does not suspend the server-side script while the dialog is open. To communicate with\n the server-side script, the client-side component must make asynchronous callbacks using either\n the google.script API for\n HtmlService or\n server handlers for\n UiApp. To close the dialog\n programmatically, call \n google.script.host.close() on the client side of an HtmlService web\n app or UiInstance.close() from a\n UiApp web app. For more information, see the\n guide to dialogs and sidebars.\n\n Modeless dialogs let the user interact with the editor behind the dialog. By contrast,\n modal dialogs do not. In almost all cases, a modal\n dialog or sidebar is a better choice than a modeless dialog.\n \n\n \n \n // Display a modeless dialog box with custom HtmlService content.\n var htmlOutput = HtmlService\n     .createHtmlOutput(&#39;&lt;p&gt;A change of speed, a change of style...&lt;/p&gt;&#39;)\n     .setSandboxMode(HtmlService.SandboxMode.IFRAME)\n     .setWidth(250)\n     .setHeight(300);\n SpreadsheetApp.getUi().showModelessDialog(htmlOutput, &#39;My add-on&#39;);\n\n // Display a modeless dialog box with custom UiApp content.\n var uiInstance = UiApp.createApplication()\n     .setWidth(250)\n     .setHeight(300);\n uiInstance.add(uiInstance.createLabel(&#39;The photograph on the dashboard taken years ago...&#39;));\n SpreadsheetApp.getUi().showModelessDialog(uiInstance, &#39;My add-on&#39;);\n "
    },
    "showSidebar": {
      "!type": "fn(userInterface: object)",
      "!doc": "Opens a sidebar in the user's editor with custom client-side content. This method does\n not suspend the server-side script while the sidebar is open. To communicate with the\n server-side script, the client-side component must make asynchronous callbacks using either\n the google.script API for\n HtmlService or\n server handlers for\n UiApp. To close the sidebar\n programmatically, call \n google.script.host.close() on the client side of an HtmlService web\n app or UiInstance.close() from a\n UiApp web app. For more information, see the\n guide to dialogs and sidebars.\n\n The sidebar will display on the right side of the editor for users whose environments use a\n left-to-right language and on the left side of the editor for right-to-left languages. All\n sidebars shown by scripts are 300 pixels wide.\n\n \n \n // Display a sidebar with custom HtmlService content.\n var htmlOutput = HtmlService\n     .createHtmlOutput(&#39;&lt;p&gt;A change of speed, a change of style...&lt;/p&gt;&#39;)\n     .setSandboxMode(HtmlService.SandboxMode.IFRAME)\n     .setTitle(&#39;My add-on&#39;);\n SpreadsheetApp.getUi().showSidebar(htmlOutput);\n\n // Display a sidebar with custom UiApp content.\n var uiInstance = UiApp.createApplication()\n     .setTitle(&#39;My add-on&#39;);\n uiInstance.add(uiInstance.createLabel(&#39;The photograph on the dashboard taken years ago...&#39;));\n SpreadsheetApp.getUi().showSidebar(uiInstance);\n "
    }
  },
  "MailApp": {
    "getRemainingDailyQuota": {
      "!type": "fn() -> number",
      "!doc": "Returns the number of remaining emails a user can send for the rest of\n the day.\n\n Quotas are based on the number of email recipients. Specific quota information is available on\n the quota tab of the Apps Script\n dashboard.\n\n \n \n var emailQuotaRemaining = MailApp.getRemainingDailyQuota();\n Logger.log(&quot;Remaining email quota: &quot; + emailQuotaRemaining);\n "
    },
    "sendEmail": {
      "!type": "fn(message: object)",
      "!doc": "Sends an email message. This variation of the method is much more flexible,\n allowing for many more options.\n\n \n \n // This code fetches the Google and YouTube logos, inlines them in an email\n // and sends the email\n function inlineImage() {\n   var googleLogoUrl = &quot;http://www.google.com/intl/en_com/images/srpr/logo3w.png&quot;;\n   var youtubeLogoUrl =\n         &quot;https://developers.google.com/youtube/images/YouTube_logo_standard_white.png&quot;;\n   var googleLogoBlob = UrlFetchApp\n                          .fetch(googleLogoUrl)\n                          .getBlob()\n                          .setName(&quot;googleLogoBlob&quot;);\n   var youtubeLogoBlob = UrlFetchApp\n                           .fetch(youtubeLogoUrl)\n                           .getBlob()\n                           .setName(&quot;youtubeLogoBlob&quot;);\n   MailApp.sendEmail({\n     to: &quot;recipient@example.com&quot;,\n     subject: &quot;Logos&quot;,\n     htmlBody: &quot;inline Google Logo&lt;img src=&#39;cid:googleLogo&#39;&gt; images! &lt;br&gt;&quot; +\n               &quot;inline YouTube Logo &lt;img src=&#39;cid:youtubeLogo&#39;&gt;&quot;,\n     inlineImages:\n       {\n         googleLogo: googleLogoBlob,\n         youtubeLogo: youtubeLogoBlob\n       }\n   });\n }\n "
    },
    "sendEmail ": {
      "!type": "fn(recipient: string, subject: string, body: string)",
      "!doc": "Sends an email message.\n\n \n \n MailApp.sendEmail(&quot;recipient@example.com&quot;,\n                   &quot;TPS reports&quot;,\n                   &quot;Where are the TPS reports?&quot;);\n "
    },
    "sendEmail  ": {
      "!type": "fn(recipient: string, subject: string, body: string, options: object)",
      "!doc": "Sends an email message with optional arguments.\n\n \n \n // Send an email with two attachments: a file from Google Drive (as a PDF) and an HTML file.\n var file = DriveApp.getFileById(&#39;1234567890abcdefghijklmnopqrstuvwxyz&#39;);\n var blob = Utilities.newBlob(&#39;Insert any HTML content here&#39;, &#39;text/html&#39;, &#39;my_document.html&#39;);\n MailApp.sendEmail(&#39;mike@example.com&#39;, &#39;Attachment example&#39;, &#39;Two files are attached.&#39;, {\n     name: &#39;Automatic Emailer Script&#39;,\n     attachments: [file.getAs(MimeType.PDF), blob]\n });\n "
    },
    "sendEmail   ": {
      "!type": "fn(to: string, replyTo: string, subject: string, body: string)",
      "!doc": "Sends an email message. This method allows a user to easily specify\n a Reply-To address for the sent message that can differ from the sender.\n\n \n \n MailApp.sendEmail(&quot;recipient@example.com&quot;,\n                   &quot;replies@example.com&quot;,\n                   &quot;TPS report status&quot;,\n                   &quot;What is the status of those TPS reports?&quot;);\n "
    }
  },
  "Jdbc": {
    "Connection": {
      "!type": "Jdbc.JdbcConnection"
    },
    "DatabaseMetaData": {
      "!type": "Jdbc.JdbcDatabaseMetaData"
    },
    "ParameterMetaData": {
      "!type": "Jdbc.JdbcParameterMetaData"
    },
    "ResultSet": {
      "!type": "Jdbc.JdbcResultSet"
    },
    "ResultSetMetaData": {
      "!type": "Jdbc.JdbcResultSetMetaData"
    },
    "RowIdLifetime": {
      "!type": "Jdbc.JdbcRowIdLifetime"
    },
    "Statement": {
      "!type": "Jdbc.JdbcStatment"
    },
    "Types": {
      "!type": "Jdbc.JdbcTypes"
    },
    "getCloudSqlConnection": {
      "!type": "fn(url: string) -> Jdbc.JdbcConnection",
      "!doc": "Attempts to establish a connection to the given Google Cloud SQL URL."
    },
    "getCloudSqlConnection ": {
      "!type": "fn(url: string, info: object) -> Jdbc.JdbcConnection",
      "!doc": "Attempts to establish a connection to the given Google Cloud SQL URL."
    },
    "getCloudSqlConnection  ": {
      "!type": "fn(url: string, userName: string, password: string) -> Jdbc.JdbcConnection",
      "!doc": "Attempts to establish a connection to the given Google Cloud SQL URL."
    },
    "getConnection": {
      "!type": "fn(url: string) -> Jdbc.JdbcConnection",
      "!doc": "Attempts to establish a connection to the given database URL.\n\n \n \n  var conn = Jdbc.getConnection(&#39;jdbc:mysql://yoursqlserver.example.com:3306/database_name&#39;);\n "
    },
    "getConnection ": {
      "!type": "fn(url: string, info: object) -> Jdbc.JdbcConnection",
      "!doc": "Attempts to establish a connection to the given database URL.\n\n \n \n  var conn = Jdbc.getConnection(&#39;jdbc:mysql://yoursqlserver.example.com:3306/database_name&#39;,\n                                {user: &#39;username&#39;, password: &#39;password&#39;});\n "
    },
    "getConnection  ": {
      "!type": "fn(url: string, userName: string, password: string) -> Jdbc.JdbcConnection",
      "!doc": "Attempts to establish a connection to the given database using a username and password.\n\n \n \n  var conn = Jdbc.getConnection(&#39;jdbc:mysql://yoursqlserver.example.com:3306/database_name&#39;,\n                                &#39;username&#39;, &#39;password&#39;);\n "
    },
    "newDate": {
      "!type": "fn(milliseconds: number) -> Jdbc.JdbcDate",
      "!doc": "Create a date from milliseconds since epoch."
    },
    "newTime": {
      "!type": "fn(milliseconds: number) -> Jdbc.JdbcTime",
      "!doc": "Create a time from milliseconds since epoch."
    },
    "newTimestamp": {
      "!type": "fn(milliseconds: number) -> Jdbc.JdbcTimestamp",
      "!doc": "Create a timestamp from milliseconds since epoch."
    },
    "parseDate": {
      "!type": "fn(date: string) -> Jdbc.JdbcDate",
      "!doc": "Create a date by parsing the SQL date string."
    },
    "parseTime": {
      "!type": "fn(time: string) -> Jdbc.JdbcTime",
      "!doc": "Create a time by parsing the SQL time string."
    },
    "parseTimestamp": {
      "!type": "fn(timestamp: string) -> Jdbc.JdbcTimestamp",
      "!doc": "Create a timestamp by parsing the SQL timestamp string."
    }
  },
  "object": {
    "create": {
      "!type": "fn(proto: object) -> object"
    },
    "create ": {
      "!type": "fn(proto: object, propertiesObject: object) -> object"
    },
    "defineProperties": {
      "!type": "fn(obj: object, props: object)"
    },
    "defineProperty": {
      "!type": "fn(obj: object, prop: string, descriptor: object)"
    },
    "freeze": {
      "!type": "fn(obj: object)"
    },
    "getOwnPropertyDescriptor": {
      "!type": "fn(obj: object, prop: string) -> object"
    },
    "getOwnPropertyNames": {
      "!type": "fn(obj: object) -> [string]"
    },
    "getPrototypeOf": {
      "!type": "fn(obj: object) -> object"
    },
    "isExtensible": {
      "!type": "fn(obj: object) -> bool"
    },
    "isFrozen": {
      "!type": "fn(obj: object) -> bool"
    },
    "isSealed": {
      "!type": "fn(obj: object) -> bool"
    },
    "keys": {
      "!type": "fn(obj: object) -> [string]"
    },
    "preventExtensions": {
      "!type": "fn(obj: object)"
    },
    "seal": {
      "!type": "fn(obj: object)"
    }
  },
  "SpreadsheetApp": {
    "DataValidationCriteria": {
      "!type": "SpreadsheetApp.DataValidationCriteria",
      "!doc": "An enumeration representing the data-validation criteria that can be set on a range."
    },
    "ProtectionType": {
      "!type": "SpreadsheetApp.ProtectionType",
      "!doc": "An enumeration representing the parts of a spreadsheet that can be protected from edits."
    },
    "create": {
      "!type": "fn(name: string) -> SpreadsheetApp.Spreadsheet",
      "!doc": "Creates a new spreadsheet with the given name.\n\n \n \n // The code below creates a new spreadsheet &quot;Finances&quot; and logs the URL for it\n var ssNew = SpreadsheetApp.create(&quot;Finances&quot;);\n Logger.log(ssNew.getUrl());\n "
    },
    "create ": {
      "!type": "fn(name: string, rows: number, columns: number) -> SpreadsheetApp.Spreadsheet",
      "!doc": "Creates a new spreadsheet with the given name and the specified number of rows and columns.\n\n \n \n // The code below creates a new spreadsheet &quot;Finances&quot; with 50 rows and 5 columns and logs the\n // URL for it\n var ssNew = SpreadsheetApp.create(&quot;Finances&quot;, 50, 5);\n Logger.log(ssNew.getUrl());\n "
    },
    "flush": {
      "!type": "fn()",
      "!doc": "Applies all pending Spreadsheet changes.\n\n Spreadsheet operations are sometimes bundled together to improve performance, such as when\n doing multiple calls to Range.getValue(). However, sometimes you may want to make sure that all\n pending changes are made right away, for instance to show users data as a script is executing.\n\n \n \n // The code below changes the background color of cells A1 and B1 twenty times. You should be\n // able to see the updates live in the spreadsheet. If flush() is not called, the updates may\n // be applied live or may all be applied at once when the script completes.\n function colors() {\n   var sheet = SpreadsheetApp.getActiveSheet();\n   for (var i = 0; i &lt; 20; i++) {\n     if ((i % 2) == 0) {\n       sheet.getRange(&#39;A1&#39;).setBackground(&#39;green&#39;);\n       sheet.getRange(&#39;B1&#39;).setBackground(&#39;red&#39;);\n     } else {\n       sheet.getRange(&#39;A1&#39;).setBackground(&#39;red&#39;);\n       sheet.getRange(&#39;B1&#39;).setBackground(&#39;green&#39;);\n     }\n     SpreadsheetApp.flush();\n   }\n }\n "
    },
    "getActive": {
      "!type": "fn() -> SpreadsheetApp.Spreadsheet",
      "!doc": "Returns the currently active spreadsheet, or null if there is none.\n\n Functions that are run in the context of a spreadsheet can get a reference to the corresponding\n Spreadsheet object by calling this function.\n\n \n \n // The code below logs the URL for the active spreadsheet.\n Logger.log(SpreadsheetApp.getActive().getUrl());\n "
    },
    "getActiveRange": {
      "!type": "fn() -> SpreadsheetApp.Range",
      "!doc": "Returns the range of cells that is currently considered active.\n\n This generally means the range that a user has selected in the active sheet, but in a custom\n function it refers to the cell being actively recalculated.\n\n \n \n // The code below will log the background color for the active range\n var color = SpreadsheetApp.getActiveRange().getBackgroundColor();\n Logger.log(color);\n "
    },
    "getActiveSheet": {
      "!type": "fn() -> SpreadsheetApp.Sheet",
      "!doc": "Gets the active sheet in a spreadsheet.\n\n The active sheet in a spreadsheet is the sheet that is being displayed in the spreadsheet UI.\n\n \n \n // The code below will log the name of the active sheet.\n Logger.log(SpreadsheetApp.getActiveSheet().getName());\n "
    },
    "getActiveSpreadsheet": {
      "!type": "fn() -> SpreadsheetApp.Spreadsheet",
      "!doc": "Returns the currently active spreadsheet, or null if there is none.\n\n Functions that are run in the context of a spreadsheet can get a reference to the corresponding\n Spreadsheet object by calling this function.\n\n \n \n // The code below logs the URL for the active spreadsheet.\n Logger.log(SpreadsheetApp.getActiveSpreadsheet().getUrl());\n "
    },
    "getUi": {
      "!type": "fn() -> Ui",
      "!doc": "Returns an instance of the spreadsheet's user-interface environment that allows the script to\n add features like menus, dialogs, and sidebars. A script can only interact with the UI for the\n current instance of an open spreadsheet, and only if the script is\n bound to the spreadsheet. For more information,\n see the guides to menus and\n dialogs and sidebars.\n\n This method only works in the\n new version of Google Sheets.\n The older version of Sheets continues to use an alternate syntax shown in the guides above.\n\n \n // Add a custom menu to the active spreadsheet, including a separator and a sub-menu.\n function onOpen(e) {\n   SpreadsheetApp.getUi()\n       .createMenu('My Menu')\n       .addItem('My menu item', 'myFunction')\n       .addSeparator()\n       .addSubMenu(SpreadsheetApp.getUi().createMenu('My sub-menu')\n           .addItem('One sub-menu item', 'mySecondFunction')\n           .addItem('Another sub-menu item', 'myThirdFunction'))\n       .addToUi();\n }\n "
    },
    "newDataValidation": {
      "!type": "fn() -> SpreadsheetApp.DataValidationBuilder",
      "!doc": "Creates a builder for a data-validation rule.\n\n \n var cell = SpreadsheetApp.getActive().getRange('A1');\n var rule = SpreadsheetApp.newDataValidation()\n     .requireNumberBetween(1, 100)\n     .setAllowInvalid(false)\n     .setHelpText('Number must be between 1 and 100.')\n     .build();\n cell.setDataValidation(rule);\n "
    },
    "open": {
      "!type": "fn(file: DriveApp.File) -> SpreadsheetApp.Spreadsheet",
      "!doc": "Opens the spreadsheet that corresponds to the given File object.\n\n \n \n // Get any starred spreadsheets from Google Drive, then open the spreadsheets and log the name\n // of the first sheet within each spreadsheet.\n var files = DriveApp.searchFiles(\n     &#39;starred = true and mimeType = &quot;&#39; + MimeType.GOOGLE_SHEETS + &#39;&quot;&#39;);\n while (files.hasNext()) {\n   var spreadsheet = SpreadsheetApp.open(files.next());\n   var sheet = spreadsheet.getSheets()[0];\n   Logger.log(sheet.getName());\n }\n "
    },
    "openById": {
      "!type": "fn(id: string) -> SpreadsheetApp.Spreadsheet",
      "!doc": "Opens the spreadsheet with the given ID. A spreadsheet ID can be extracted from its URL. For\n example, the spreadsheet ID in the URL\n https://docs.google.com/spreadsheets/d/abc1234567/edit#gid=0 is \"abc1234567\".\n\n \n \n // The code below opens a spreadsheet using its ID and logs the name for it.\n // Note that the spreadsheet is NOT physically opened on the client side.\n // It is opened on the server only (for modification by the script).\n var ss = SpreadsheetApp.openById(&quot;abc1234567&quot;);\n Logger.log(ss.getName());\n "
    },
    "openByUrl": {
      "!type": "fn(url: string) -> SpreadsheetApp.Spreadsheet",
      "!doc": "Opens the spreadsheet with the given url.\n\n \n \n // The code below opens a spreadsheet using its id and logs the name for it.\n // Note that the spreadsheet is NOT physically opened on the client side.\n // It is opened on the server only (for modification by the script).\n var ss = SpreadsheetApp.openByUrl(\n     &#39;https://docs.google.com/spreadsheets/d/abc1234567/edit&#39;);\n Logger.log(ss.getName());\n "
    },
    "setActiveRange": {
      "!type": "fn(range: SpreadsheetApp.Range) -> SpreadsheetApp.Range",
      "!doc": "Sets the active range for the application.\n\n The spreadsheet UI will display the sheet that contains the chosen range and will select the\n cells defined in the chosen range.\n\n \n \n // The code below will set range C1:D4 in the first sheet as the active range\n var ss = SpreadsheetApp.getActiveSpreadsheet();\n var range = ss.getSheets()[0].getRange(&quot;C1:D4&quot;);\n SpreadsheetApp.setActiveRange(range);\n "
    },
    "setActiveSheet": {
      "!type": "fn(sheet: SpreadsheetApp.Sheet) -> SpreadsheetApp.Sheet",
      "!doc": "Sets the active sheet in a spreadsheet.\n\n The spreadsheet UI will display the chosen sheet unless the sheet belongs to a different\n spreadsheet.\n\n \n \n // The code below will make the 2nd sheet active in the active spreadsheet\n var ss = SpreadsheetApp.getActiveSpreadsheet();\n SpreadsheetApp.setActiveSheet(ss.getSheets()[1]);\n "
    },
    "setActiveSpreadsheet": {
      "!type": "fn(newActiveSpreadsheet: SpreadsheetApp.Spreadsheet)",
      "!doc": "Sets the active spreadsheet.\n\n \n \n // The code below will make the spreadsheet with key &quot;1234567890&quot; the active spreadsheet\n var ss = SpreadsheetApp.openById(&quot;1234567890&quot;);\n SpreadsheetApp.setActiveSpreadsheet(ss);\n "
    }
  }
}